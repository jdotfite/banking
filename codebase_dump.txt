==== File: CACHE-GUIDE.md ====
# Handling Cache Issues During Development

This guide provides solutions for dealing with caching issues when developing the Banking App.

## The Problem

When developing web applications, browser caching can sometimes cause confusion when changes don't appear to take effect. This can happen for several reasons:

1. Browser caching static assets and HTML
2. Service Worker caching (for PWAs)
3. Next.js build cache
4. React component state persistence

## Solutions Implemented

We've implemented several solutions to help manage caching during development:

### 1. Modified Next.js Configuration

The `next.config.js` file has been updated to disable caching in development mode:

```javascript
// Cache-Control headers are set to no-cache in development
async headers() {
  return [
    {
      source: '/(.*)',
      headers: [
        {
          key: 'Cache-Control',
          value: process.env.NODE_ENV === 'development' 
            ? 'no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0' 
            : 'public, max-age=3600, s-maxage=3600, stale-while-revalidate=86400',
        },
        // Other headers...
      ],
    },
  ];
}
```

### 2. Middleware Cache-Busting

The `middleware.ts` file now adds cache-busting headers to all responses in development mode:

```javascript
// Add cache-busting headers in development mode
if (process.env.NODE_ENV === 'development') {
  response.headers.set('Cache-Control', 'no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0');
  response.headers.set('Pragma', 'no-cache');
  response.headers.set('Expires', '0');
  response.headers.set('Surrogate-Control', 'no-store');
  
  // Add a timestamp header for debugging
  response.headers.set('X-Cache-Timestamp', new Date().toISOString());
}
```

### 3. Cache-Clearing Scripts

Two scripts have been added to help clear caches:

- `scripts/clear-cache-and-restart.ps1` (Windows PowerShell)
- `scripts/clear-cache-and-restart.sh` (Unix/Mac/Linux)

These scripts:
- Clear the Next.js `.next` cache directory
- Provide instructions for clearing browser cache
- Restart the development server

### 4. NPM Scripts

New NPM scripts have been added to package.json:

```json
"scripts": {
  "dev:clean": "rimraf .next && next dev",
  "build:clean": "rimraf .next && next build",
  "clear-cache:win": "powershell -ExecutionPolicy Bypass -File ./scripts/clear-cache-and-restart.ps1",
  "clear-cache:unix": "bash ./scripts/clear-cache-and-restart.sh",
  "test-nav": "next dev && echo 'Navigate to http://localhost:3000/test-nav.html to test navigation'"
}
```

### 5. Navigation Test Page

A test page has been created at `public/test-nav.html` that helps you:
- Test the bottom navigation in isolation
- Clear browser caches
- Add timestamp parameters to force refreshes
- Check cache-related headers

## How to Use These Tools

### When Changes Aren't Showing Up

1. **Hard Refresh**: Try a hard refresh first (Ctrl+F5 or Cmd+Shift+R)

2. **Clear Next.js Cache and Restart**:
   - Windows: `npm run clear-cache:win`
   - Mac/Linux: `npm run clear-cache:unix`

3. **Use the Test Navigation Page**:
   - Start the dev server: `npm run dev`
   - Navigate to: http://localhost:3000/test-nav.html
   - Use the buttons to clear cache and reload

4. **Use Browser Developer Tools**:
   - Open DevTools (F12)
   - Go to Network tab
   - Check "Disable cache" while DevTools is open
   - Reload the page

5. **Use Incognito/Private Window**:
   - Chrome: Ctrl+Shift+N
   - Firefox: Ctrl+Shift+P
   - Edge: Ctrl+Shift+N

6. **Add Query Parameters**:
   - Append a timestamp to force a fresh load:
   - Example: `http://localhost:3000/?refresh=123456789`

## Port Differences

If you're seeing different behavior on different ports (e.g., 3000 vs 3001):

- This is likely because each server instance has its own cache
- When you restart the server, it might pick a different port if the original is in use
- Always check which port you're using in the terminal output
- Use the cache-clearing techniques above on the specific port you're testing

## Service Worker Considerations

The PWA functionality is disabled in development mode (see `next.config.js`), but if you've previously installed the app as a PWA, you might need to:

1. Unregister service workers:
   - In Chrome DevTools → Application → Service Workers → Unregister
   
2. Clear site data:
   - In Chrome DevTools → Application → Storage → Clear site data

## Bottom Navigation Specific Issues

The bottom navigation component has been centralized in the AppContainer component to ensure it's loaded only once and consistently positioned across all pages. If you're still experiencing issues with the navigation:

1. Check that you're not importing and using BottomNav in individual page components
2. Verify that the transform styles in BottomNav.tsx are not being overridden
3. Use the test-nav.html page to isolate and test the navigation component




==== File: middleware.ts ====
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

export function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl;
  
  // Check if the user is authenticated by looking for a token in cookies
  const authToken = request.cookies.get('auth_token')?.value;
  const selectedUserId = request.cookies.get('selectedUserId')?.value;
  const isAuthenticated = !!authToken;
  const isNewUser = selectedUserId === 'new';
  
  // Public paths that don't require authentication
  const publicPaths = ['/onboarding', '/login', '/signup', '/forgot-password'];
  
  // If it's a new user, allow access to onboarding flow
  if (isNewUser && publicPaths.includes(pathname)) {
    return NextResponse.next();
  }
  
  // If the user is authenticated and trying to access onboarding/login/signup
  if (isAuthenticated && publicPaths.includes(pathname)) {
    const url = request.nextUrl.clone();
    url.pathname = '/';
    return NextResponse.redirect(url);
  }
  
  // Create the response
  const response = NextResponse.next();
  
  // Add cache-busting headers in development mode
  if (process.env.NODE_ENV === 'development') {
    response.headers.set('Cache-Control', 'no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0');
    response.headers.set('Pragma', 'no-cache');
    response.headers.set('Expires', '0');
    response.headers.set('Surrogate-Control', 'no-store');
    
    // Add a timestamp header for debugging
    response.headers.set('X-Cache-Timestamp', new Date().toISOString());
  }
  
  return response;
}

export const config = {
  matcher: [
    '/((?!_next/static|_next/image|favicon.ico|images|api|.*\\.png$|.*\\.svg$).*)',
  ],
};




==== File: next-env.d.ts ====
/// <reference types="next" />
/// <reference types="next/image-types/global" />
/// <reference types="next/navigation-types/compat/navigation" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/basic-features/typescript for more information.




==== File: next.config.js ====
// next.config.js
const withPWA = require('next-pwa')({
  dest: 'public',            // where sw.js and other assets go
  register: false,           // disable automatic registration - we'll handle it manually
  skipWaiting: true,         // activate new service worker immediately
  disable: false,            // enable PWA in all environments for testing
  buildExcludes: [/app-build-manifest.json$/], // Fix for precaching error
  // Include specific routes in the service worker
  scope: '/',
  sw: 'sw.js',  // Remove leading slash to fix path issues
  // Ensure caching is set up correctly
  runtimeCaching: [
    {
      urlPattern: /^https:\/\/fonts\.(?:googleapis|gstatic)\.com\/.*/i,
      handler: 'CacheFirst',
      options: {
        cacheName: 'google-fonts',
        expiration: {
          maxEntries: 4,
          maxAgeSeconds: 365 * 24 * 60 * 60, // 1 year
        },
      },
    },
    {
      urlPattern: /\.(?:eot|otf|ttc|ttf|woff|woff2|font.css)$/i,
      handler: 'StaleWhileRevalidate',
      options: {
        cacheName: 'static-font-assets',
        expiration: {
          maxEntries: 4,
          maxAgeSeconds: 7 * 24 * 60 * 60, // 7 days
        },
      },
    },
    {
      urlPattern: /\.(?:jpg|jpeg|gif|png|svg|ico|webp)$/i,
      handler: 'StaleWhileRevalidate',
      options: {
        cacheName: 'static-image-assets',
        expiration: {
          maxEntries: 64,
          maxAgeSeconds: 24 * 60 * 60, // 24 hours
        },
      },
    },
    {
      urlPattern: /\/_next\/image\?url=.+$/i,
      handler: 'StaleWhileRevalidate',
      options: {
        cacheName: 'next-image',
        expiration: {
          maxEntries: 64,
          maxAgeSeconds: 24 * 60 * 60, // 24 hours
        },
      },
    },
    {
      urlPattern: /\.(?:mp3|wav|ogg)$/i,
      handler: 'CacheFirst',
      options: {
        rangeRequests: true,
        cacheName: 'static-audio-assets',
        expiration: {
          maxEntries: 32,
          maxAgeSeconds: 24 * 60 * 60, // 24 hours
        },
      },
    },
    {
      urlPattern: /\.(?:mp4)$/i,
      handler: 'CacheFirst',
      options: {
        rangeRequests: true,
        cacheName: 'static-video-assets',
        expiration: {
          maxEntries: 32,
          maxAgeSeconds: 24 * 60 * 60, // 24 hours
        },
      },
    },
    {
      urlPattern: /\.(?:js)$/i,
      handler: 'StaleWhileRevalidate',
      options: {
        cacheName: 'static-js-assets',
        expiration: {
          maxEntries: 32,
          maxAgeSeconds: 24 * 60 * 60, // 24 hours
        },
      },
    },
    {
      urlPattern: /\.(?:css|less)$/i,
      handler: 'StaleWhileRevalidate',
      options: {
        cacheName: 'static-style-assets',
        expiration: {
          maxEntries: 32,
          maxAgeSeconds: 24 * 60 * 60, // 24 hours
        },
      },
    },
    {
      urlPattern: /\/_next\/data\/.+\/.+\.json$/i,
      handler: 'StaleWhileRevalidate',
      options: {
        cacheName: 'next-data',
        expiration: {
          maxEntries: 32,
          maxAgeSeconds: 24 * 60 * 60, // 24 hours
        },
      },
    },
    {
      urlPattern: /\/api\/.*$/i,
      handler: 'NetworkFirst',
      options: {
        cacheName: 'apis',
        expiration: {
          maxEntries: 16,
          maxAgeSeconds: 24 * 60 * 60, // 24 hours
        },
        networkTimeoutSeconds: 10, // fall back to cache if api does not respond within 10 seconds
      },
    },
    {
      urlPattern: /.*/i,
      handler: 'NetworkFirst',
      options: {
        cacheName: 'others',
        expiration: {
          maxEntries: 32,
          maxAgeSeconds: 24 * 60 * 60, // 24 hours
        },
        networkTimeoutSeconds: 10,
      },
    },
  ],
});

/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  swcMinify: true,
  
  // Optimize compilation
  compiler: {
    // Enables the styled-components SWC transform
    styledComponents: true,
    // Remove console.log in production
    removeConsole: process.env.NODE_ENV === 'production',
  },
  
  // Optimize images
  images: {
    domains: [],
    formats: ['image/avif', 'image/webp'],
    minimumCacheTTL: 60,
  },
  
  // Optimize builds
  experimental: {
    optimizeCss: true, // Enable CSS optimization
    optimizePackageImports: ['lucide-react'],
  },
  
  async redirects() {
    return [
      {
        source: '/home',
        destination: '/',
        permanent: true,
      },
    ];
  },
  
  async headers() {
    return [
      {
        source: '/(.*)',
        headers: [
          {
            key: 'Cache-Control',
            value: process.env.NODE_ENV === 'development' 
              ? 'no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0' 
              : 'public, max-age=3600, s-maxage=3600, stale-while-revalidate=86400',
          },
          {
            key: 'Service-Worker-Allowed',
            value: '/',
          },
          {
            key: 'X-Content-Type-Options',
            value: 'nosniff',
          },
          {
            key: 'X-Frame-Options',
            value: 'DENY',
          },
          {
            key: 'X-XSS-Protection',
            value: '1; mode=block',
          },
        ],
      },
    ];
  },
  
  webpack: (config, { isServer }) => {
    if (!isServer) {
      config.resolve.fallback = {
        fs: false,
        path: false,
      };
    }
    
    // Add optimization for CSS modules
    if (!isServer) {
      config.optimization.splitChunks.cacheGroups = {
        ...config.optimization.splitChunks.cacheGroups,
        styles: {
          name: 'styles',
          test: /\.(css|scss)$/,
          chunks: 'all',
          enforce: true,
        },
      };
    }
    
    return config;
  },
};

module.exports = withPWA(nextConfig);




==== File: PERFORMANCE-GUIDE.md ====
# Banking App Performance Guide

This guide explains the optimizations made to improve the performance of the banking app, particularly focusing on development compilation speed and Fast Refresh functionality.

## Recent Optimizations

### 1. CSS Structure Improvements

- **Separated CSS into Base and Dynamic Styles**: 
  - Created `app/base-styles.css` for static styles that rarely change
  - Simplified `app/globals.css` to only include Tailwind directives and import the base styles
  - This prevents full page reloads when making small CSS changes

### 2. Component Structure Improvements

- **Created Provider Components**:
  - `ThemeContextProvider`: Isolates theme context changes
  - `IOSFullScreenProvider`: Separates iOS-specific functionality
  - These changes prevent cascading re-renders when these components change

### 3. Next.js Configuration Optimizations

- **Enhanced webpack Configuration**:
  - Added CSS chunking for better performance
  - Configured SWC compiler optimizations
  - Added package import optimization for `lucide-react`
  - Enabled CSS optimization

### 4. Development Workflow Improvements

- **Created Optimization Scripts**:
  - `scripts/optimize-dev.ps1` (Windows)
  - `scripts/optimize-dev.sh` (Mac/Linux)
  - These scripts clear caches and restart the development server with optimized settings

## How to Use the Optimization Scripts

### Windows

```powershell
# Run from the project root
.\scripts\optimize-dev.ps1
```

### Mac/Linux

```bash
# Make the script executable (one-time)
chmod +x scripts/optimize-dev.sh

# Run from the project root
./scripts/optimize-dev.sh
```

## Best Practices for Maintaining Performance

1. **Keep CSS Modular**:
   - Put rarely changing styles in `base-styles.css`
   - Use Tailwind classes for component-specific styling
   - Avoid large CSS changes to global files

2. **Component Structure**:
   - Use provider pattern for context that doesn't change often
   - Keep components focused and avoid deep nesting
   - Use memoization for expensive calculations

3. **Regular Maintenance**:
   - Periodically run the optimization scripts to clear caches
   - Monitor for new Fast Refresh warnings
   - Update Next.js and dependencies regularly

4. **Code Splitting**:
   - Use dynamic imports for large components not needed on initial load
   - Consider lazy loading for routes that aren't frequently accessed

## Troubleshooting

If you encounter Fast Refresh warnings or slow compilation:

1. Check which files are causing the warnings
2. Consider if those files can be further modularized
3. Run the optimization script to clear caches
4. Ensure you're not importing large libraries unnecessarily




==== File: postcss.config.js ====
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}




==== File: PWA-GUIDE.md ====
# Progressive Web App (PWA) Guide

This document provides information about the PWA functionality in the Banking App, including how it works, how to test it, and how to troubleshoot common issues.

## What is a PWA?

A Progressive Web App (PWA) is a web application that uses modern web capabilities to deliver an app-like experience to users. PWAs are:

- **Installable**: Users can add the app to their home screen
- **Offline-capable**: Works without an internet connection using service workers
- **Responsive**: Adapts to different screen sizes
- **App-like**: Provides a full-screen experience without browser UI

## PWA Features in the Banking App

The Banking App implements the following PWA features:

1. **Install Banner**: A customized prompt that encourages users to install the app
2. **Offline Support**: Core functionality works without an internet connection
3. **App Icon**: Custom icons for different platforms and sizes
4. **Splash Screens**: Custom splash screens for iOS devices
5. **Full-screen Mode**: Removes browser UI when launched from the home screen

## Testing PWA Functionality

To test the PWA functionality:

1. Open Chrome and navigate to the app
2. You should see an install banner at the top of the page
3. Click "Install" to add the app to your device
4. After installation, the app should launch in full-screen mode
5. Test offline functionality by enabling Chrome's offline mode (DevTools > Network > Offline)

## Troubleshooting PWA Issues

### PWA Install Banner Not Showing

If the PWA install banner is not showing:

1. **Check PWA Eligibility**: 
   - Open Chrome DevTools (F12)
   - Go to Application > Manifest
   - Verify that the manifest is properly loaded
   - Check for any errors in the "Identity" and "Presentation" sections

2. **Check Service Worker Registration**:
   - Go to Application > Service Workers
   - Verify that a service worker is registered for the site
   - Check the status (should be "activated" and "running")

3. **Clear PWA State**:
   - Run the reset script: `scripts/reset-pwa-and-restart.ps1` (Windows) or `scripts/reset-pwa-and-restart.sh` (Mac/Linux)
   - This will clear caches, unregister service workers, and restart the development server

4. **Manual Reset**:
   - Open Chrome and navigate to `chrome://serviceworker-internals`
   - Find any entries for your site and click "Unregister"
   - Open Chrome DevTools > Application > Clear Storage
   - Check all options and click "Clear site data"
   - Close all browser tabs for your site

5. **Check Console for Errors**:
   - Open Chrome DevTools > Console
   - Look for any errors related to service worker registration or PWA installation

### PWA Not Working Offline

If the PWA is not working offline:

1. **Check Service Worker Cache**:
   - Open Chrome DevTools > Application > Cache Storage
   - Verify that the necessary files are cached

2. **Check Network Requests**:
   - Open Chrome DevTools > Network
   - Enable offline mode
   - Refresh the page
   - Check which requests are failing

3. **Rebuild the Service Worker**:
   - Run `npm run build` to regenerate the service worker files
   - Test again in a fresh browser session

## Browser Support

PWA features are supported in:

- Chrome (desktop and mobile)
- Edge
- Firefox (partial support)
- Safari (partial support)

Note that Safari has limited PWA support, especially on iOS. The install experience on iOS is different:

1. Users must tap the Share button
2. Then select "Add to Home Screen"
3. The PWA banner in our app provides instructions for iOS users

## Debugging Tools

For advanced debugging:

1. **Chrome DevTools**:
   - Application > Manifest
   - Application > Service Workers
   - Application > Cache Storage
   - Application > Clear Storage

2. **Lighthouse**:
   - Open Chrome DevTools > Lighthouse
   - Select "Progressive Web App" category
   - Run an audit to check PWA compliance

3. **Chrome Flags**:
   - Navigate to `chrome://flags`
   - Search for "PWA" to find and enable experimental PWA features

## Reset Scripts

The app includes scripts to reset the PWA state:

- **Browser Console Script**: `scripts/reset-pwa.js` (copy and paste into browser console)
- **PowerShell Script**: `scripts/reset-pwa-and-restart.ps1` (for Windows)
- **Bash Script**: `scripts/reset-pwa-and-restart.sh` (for Mac/Linux)

These scripts will:
1. Clear localStorage PWA flags
2. Unregister service workers
3. Clear caches
4. Restart the development server (PowerShell/Bash scripts only)

## Implementation Details

The PWA functionality is implemented using:

1. **next-pwa**: A Next.js plugin for PWA support
2. **Workbox**: For service worker generation and caching strategies
3. **Custom Components**:
   - `PWAInstallPrompt.tsx`: Custom install banner
   - `RegisterServiceWorker.tsx`: Service worker registration

Key files:
- `public/manifest.json`: PWA metadata and configuration
- `public/sw.js`: Service worker implementation (generated)
- `public/sw-register.js`: Service worker registration script
- `next.config.js`: PWA configuration in Next.js




==== File: REFACTORING-GUIDE.md ====
# Banking App Refactoring Guide

This guide outlines the refactoring suggestions for the banking app to reduce code duplication, improve reusability, and enhance maintainability.

## 1. Unified Banking Data Provider

### Overview

We've created a new `UnifiedBankingDataProvider` that combines the functionality of both `BankingDataProvider` and `EnhancedBankingDataProvider`. This consolidation eliminates duplicate code for data loading, caching, and filtering, providing a single source of truth for banking data.

### Implementation

The new provider is located at `components/context/UnifiedBankingDataProvider.tsx` and includes:

- Proper TypeScript typing that matches the actual data structure
- Combined functionality from both previous providers
- Enhanced error handling and loading states
- Additional features like cache clearing
- Improved type safety

### How to Use

To replace the existing providers with the unified provider:

1. Open `app/layout.tsx` or wherever the providers are currently set up
2. Replace the existing providers with the new unified provider:

```tsx
// Before
<UserProvider>
  <BankingDataProvider>
    <EnhancedBankingDataProvider>
      {children}
    </EnhancedBankingDataProvider>
  </BankingDataProvider>
</UserProvider>

// After
<UserProvider>
  <UnifiedBankingDataProvider>
    {children}
  </UnifiedBankingDataProvider>
</UserProvider>
```

3. Update imports in components that use the banking data:

```tsx
// Before
import { useBankingData } from '@/components/preloaders/BankingDataPreloader';
// or
import { useEnhancedBankingData } from '@/components/preloaders/EnhancedBankingDataProvider';

// After
import { useBankingData } from '@/components/context/UnifiedBankingDataProvider';
```

4. Update component code to use the new hook:

```tsx
// Before (with EnhancedBankingDataProvider)
const { userData, isLoading } = useEnhancedBankingData();

// After
const { userData, isLoading } = useBankingData();
```

### Benefits

- **Reduced Code Duplication**: Eliminates duplicate data loading and processing logic
- **Simplified Component Tree**: Reduces the number of context providers
- **Improved Type Safety**: Better TypeScript typing that matches the actual data structure
- **Enhanced Features**: Adds cache clearing and better error handling
- **Easier Maintenance**: Single source of truth for banking data

## Additional Refactoring Suggestions

### 2. Create a Reusable Animation Component

Multiple components use React Spring with similar configurations. Create a reusable `AnimatedElement` component to standardize animations.

### 3. Create a Unified Bottom Sheet Component

The `TransactionContainer` and `SimpleDraggableSheet` have similar dragging functionality. Create a unified `BottomSheet` component.

### 4. Extract Icon Mapping to a Separate File

Move the icon mappings from the `Icon` component to a separate configuration file.

### 5. Create a Transaction Context

Create a dedicated context for transaction-related state and logic.

### 6. Create Reusable UI Components

Extract repeated UI patterns into reusable components like `Card` and `IconButton`.

### 7. Create Custom Hooks for Common Logic

Extract common logic into custom hooks like `useTransactionData` and `useBottomSheetPosition`.

### 8. Standardize Styling Patterns

Create a theme file with common values to ensure consistent styling.

### 9. Implement Proper TypeScript Typing

Fix type assertions and improve type safety throughout the codebase.

### 10. Optimize Data Loading

Implement proper data fetching with SWR or React Query for better performance and UX.




==== File: SERVICE-WORKER-GUIDE.md ====
# Service Worker Guide

This guide explains how to fix service worker issues in the Banking App.

## Common Service Worker Issues

The most common service worker error is:

```
Unhandled Runtime Error
TypeError: Failed to update a ServiceWorker for scope ('http://localhost:3000/') with script ('http://localhost:3000/sw.js'): Not found
```

This error occurs when:
1. The service worker script (`sw.js`) is not found or not accessible
2. There are conflicts in service worker registration methods
3. The service worker script contains errors
4. Cache headers are preventing proper service worker registration

## How to Fix Service Worker Issues

We've created scripts to automatically fix service worker issues:

### Windows Users

Run one of these commands in your terminal:

```bash
# Using npm script
npm run fix-sw:win

# Or directly with PowerShell
powershell -ExecutionPolicy Bypass -File ./scripts/fix-sw-and-restart.ps1
```

### Mac/Linux Users

Run one of these commands in your terminal:

```bash
# Using npm script
npm run fix-sw:unix

# Or directly with bash
bash ./scripts/fix-sw-and-restart.sh
```

### Any Platform (Node.js)

```bash
# Using npm script
npm run fix-sw

# Or directly with Node.js
node ./scripts/fix-sw-and-restart.js
```

## What the Fix Scripts Do

The fix scripts perform the following actions:

1. Stop any running development servers
2. Clear the Next.js cache (`.next` directory)
3. Fix the service worker file by removing problematic code
4. Restart the development server

## Manual Fixes

If the automatic scripts don't resolve your issue, you can try these manual steps:

1. Delete the `.next` directory to clear the Next.js cache
2. Delete the service worker files in the `public` directory:
   - `sw.js`
   - `sw.js.map`
   - `workbox-*.js`
   - `workbox-*.js.map`
3. Restart the development server with `npm run dev`

## Preventing Service Worker Issues

To prevent service worker issues:

1. Don't modify the service worker files directly
2. Use the `RegisterServiceWorker` component for service worker registration
3. Avoid adding multiple service worker registration methods
4. Make sure cache headers allow service worker registration

## Debugging Service Worker Issues

If you're still experiencing issues:

1. Open Chrome DevTools (F12)
2. Go to the Application tab
3. Select "Service Workers" in the left sidebar
4. Check for any errors or warnings
5. Use the "Unregister" button to remove problematic service workers
6. Refresh the page and check the console for errors

## Additional Resources

- [Next.js PWA Documentation](https://github.com/shadowwalker/next-pwa)
- [Service Workers API](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API)
- [Workbox Documentation](https://developers.google.com/web/tools/workbox)




==== File: tailwind.config.js ====
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './pages/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
    './app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    fontFamily: {
      outfit: ['var(--font-outfit)'],
    },
    extend: {
      colors: {
        card: {
          red: '#E53E3E', // Slightly adjusted red
          redLight: '#F56565', // For gradient
          redDark: '#C53030', // For gradient
          dark: '#212121', // Custom card background color
        },
        app: {
          customGray: '#1A1A1A', // Exact gray from example
          black: '#121212', // Pure black for background
          darkGray: '#151515', // For transaction container
          mediumGray: '#2D3748', // For inactive icons
          lightGray: '#718096', // For text
          green: '#48BB78', // For positive transactions
        },
      },
      boxShadow: {
        'card': '0 4px 6px -1px rgba(0, 0, 0, 0.2), 0 2px 4px -1px rgba(0, 0, 0, 0.1)',
      }
    },
  },
  plugins: [],
};




==== File: app\base-styles.css ====
@import url('https://fonts.googleapis.com/css2?family=Outfit:wght@100..900&display=swap');

:root {
  --font-outfit: 'Outfit', -apple-system, BlinkMacSystemFont, sans-serif;
}

html,
body {
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  height: 100%;
  padding: 0;
  margin: 0;
  background-color: black;
  color: white;
  font-family: "Outfit", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
}

/* Custom scrollbar */
::-webkit-scrollbar {
  width: 4px;
}

::-webkit-scrollbar-track {
  background: #27272a;
}

::-webkit-scrollbar-thumb {
  background: #4b5563;
  border-radius: 4px;
}

/* Animations */
@keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

@keyframes slideUp {
  from {
    transform: translateY(20px);
    opacity: 0;
  }
  to {
    transform: translateY(0);
    opacity: 1;
  }
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

/* Animation utilities */
.animate-fade-in {
  animation: fadeIn 0.5s ease-out;
}

.animate-slide-up {
  animation: slideUp 0.5s ease-out;
}

.animate-pulse {
  animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

/* Transition utilities */
.transition-height {
  transition-property: height;
}

/* Custom card styling */
.credit-card {
  transition: all 0.3s ease;
  backface-visibility: hidden;
}

.credit-card:hover {
  transform: scale(1.02);
  box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.2), 0 4px 6px -2px rgba(0, 0, 0, 0.1);
}

/* Custom handle styling */
.drag-handle {
  touch-action: none;
  user-select: none;
}

/* Smoother transitions */
.transition-all {
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

/* Transaction container overlay */
.transaction-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  z-index: 15;
  pointer-events: none;
}

/* Improved drag handle */
.drag-handle {
  width: 40px;
  height: 4px;
  background-color: rgba(255, 255, 255, 0.3);
  border-radius: 2px;
  margin: 8px auto;
  cursor: grab;
}

.drag-handle:active {
  cursor: grabbing;
}

/* Stylized cutout handle for transaction container */
.drag-handle-container {
  position: relative;
  width: 100%;
  height: 20px;
  overflow: hidden;
  display: flex;
  justify-content: center;
  margin-top: -10px;
}

.drag-handle {
  width: 40px;
  height: 5px;
  background-color: #212121; /* Transaction area color */
  border-radius: 2.5px;
  position: relative;
  cursor: grab;
  margin-top: 7px;
}

.drag-handle-container:before {
  content: '';
  position: absolute;
  top: 0;
  left: 50%;
  transform: translateX(-50%);
  width: 100px;
  height: 20px;
  background-color: #121212; /* App background color */
  border-bottom-left-radius: 50px;
  border-bottom-right-radius: 50px;
}

/* When dragging */
.drag-handle:active {
  cursor: grabbing;
  background-color: rgba(255, 255, 255, 0.2);
}

/* iOS-specific PWA styles */
@supports (-webkit-touch-callout: none) {
  /* iOS devices only */
  html {
    /* Fill the screen properly even with the notch/home indicator */
    padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
    height: -webkit-fill-available;
  }
  
  body {
    /* Prevent elastic scrolling */
    position: fixed;
    width: 100%;
    height: 100%;
    /* Prevent overscroll effects */
    overflow: hidden;
    min-height: -webkit-fill-available;
  }
  
  /* Main app container should handle scrolling */
  #app-container {
    overflow-y: auto;
    height: 100%;
    /* Enable momentum scrolling on iOS */
    -webkit-overflow-scrolling: touch;
  }

  /* Style when iOS has scrolled (address bar is hidden) */
  body.ios-scrolled {
    /* Styles to apply when address bar is hidden */
  }
}

/* Make sure anchor elements with PWA handle back properly */
a {
  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
}

/* Prevent text selection in app */
.app-no-select {
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}




==== File: app\globals.css ====
/* Import base styles that don't change often */
@import './base-styles.css';

/* Tailwind directives */
@tailwind base;

@layer base {
  html {
    font-family: var(--font-outfit);
  }
}

@tailwind components;
@tailwind utilities;




==== File: app\layout.tsx ====
// app/layout.tsx
import type { Metadata } from 'next';
import { Outfit } from 'next/font/google';
import './globals.css';
import RegisterServiceWorker from '@/components/RegisterServiceWorker';
import PWAInstallPrompt from '@/components/ui/common/PWAInstallPrompt';

const outfit = Outfit({
  subsets: ['latin'],
  weight: ['300', '400', '500', '600'],
  display: 'swap',
  variable: '--font-outfit',
});

export const metadata: Metadata = {
  title: 'Banking App',
  description: 'A modern banking app UI',
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en" className={outfit.variable}>
      <head>
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
        <meta name="theme-color" content="#121212" />
        <link rel="manifest" href="/manifest.json" />
        <link rel="apple-touch-icon" href="/icons/icon-192x192.png" />
        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
        <meta name="apple-mobile-web-app-title" content="Banking App" />
      </head>
      <body className={`${outfit.className} bg-gray-900 min-h-screen font-outfit`}>
        <RegisterServiceWorker />
        <PWAInstallPrompt />
        {children}
        {/* Remove duplicate service worker registration scripts */}
      </body>
    </html>
  );
}




==== File: app\page.tsx ====
'use client';

import React from 'react';
import AppRoot from '@/components/AppRoot';

export default function Page() {
  return (
    <main className="relative min-h-screen">
      <AppRoot />
    </main>
  );
}




==== File: app\admin\page.tsx ====
'use client';

import AdminProfileSelector from '@/components/screens/AdminProfileSelector';
import { useRouter } from 'next/navigation';

export default function AdminPage() {
  const router = useRouter();

  const handleSelectUser = (userId: string | null) => {
    if (userId === 'new') {
      router.push('/onboarding');
    } else if (userId) {
      router.push('/');
    }
  };

  return (
    <div className="min-h-screen bg-gray-900">
      <AdminProfileSelector onSelectUser={handleSelectUser} />
    </div>
  );
}




==== File: app\deposit\page.tsx ====
'use client';

import React from 'react';

export default function DepositPage() {
  return (
    <main className="relative min-h-screen">
      <div className="flex items-center justify-center h-screen bg-black text-white">
        <h1 className="text-2xl font-bold">Mobile Deposit</h1>
      </div>
    </main>
  );
}




==== File: app\forgot-password\page.tsx ====
'use client';

import React, { useState } from 'react';
import { useRouter } from 'next/navigation';
import { animated, useSpring } from 'react-spring';
import { ArrowLeft, Check } from 'lucide-react';
import { theme } from '@/lib/styles/theme';

export default function ForgotPasswordPage() {
  const [email, setEmail] = useState('');
  const [isSubmitted, setIsSubmitted] = useState(false);
  const [error, setError] = useState('');
  const router = useRouter();

  // Animation for page transitions
  const pageAnimation = useSpring({
    opacity: 1,
    transform: 'translateY(0px)',
    from: { opacity: 0, transform: 'translateY(20px)' },
    config: { tension: 280, friction: 60 }
  });

  // Handle form input changes
  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setEmail(e.target.value);
    
    // Clear error when user types
    if (error) setError('');
  };

  // Handle form submission
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    
    // Basic validation
    if (!email) {
      setError('Please enter your email address');
      return;
    }
    
    // In a real app, this would call an API to send a password reset email
    console.log('Password reset requested for:', email);
    
    // Show success message
    setIsSubmitted(true);
  };

  // Go back to login
  const handleBack = () => {
    router.push('/login');
  };

  return (
    <div className="min-h-screen bg-app-black text-white p-6">
      {/* Header */}
      <div className="flex items-center mb-8">
        <button 
          onClick={handleBack}
          className="p-2 rounded-full hover:bg-white/10 transition-colors"
        >
          <ArrowLeft size={24} />
        </button>
        <h1 className="text-xl font-semibold ml-2">Reset your password</h1>
      </div>

      {/* Form */}
      <animated.div style={pageAnimation}>
        {isSubmitted ? (
          <div className="text-center">
            <div className="mx-auto w-16 h-16 bg-green-500 rounded-full flex items-center justify-center mb-6">
              <Check size={32} className="text-white" />
            </div>
            <h2 className="text-xl font-semibold mb-4">Check your email</h2>
            <p className="text-gray-300 mb-6">
              We've sent a password reset link to <strong>{email}</strong>. 
              Please check your inbox and follow the instructions to reset your password.
            </p>
            <p className="text-gray-400 text-sm mb-8">
              Didn't receive the email? Check your spam folder or try again.
            </p>
            <button
              onClick={() => setIsSubmitted(false)}
              className="text-blue-400 hover:underline"
            >
              Try another email
            </button>
          </div>
        ) : (
          <form onSubmit={handleSubmit} className="space-y-6">
            {/* Error message */}
            {error && (
              <div className="bg-red-500/20 border border-red-500 text-red-200 p-3 rounded-lg">
                {error}
              </div>
            )}
            
            <p className="text-gray-300">
              Enter the email address associated with your account, and we'll send you a link to reset your password.
            </p>
            
            {/* Email field */}
            <div>
              <label htmlFor="email" className="block text-sm font-medium text-gray-300 mb-1">
                Email Address
              </label>
              <input
                type="email"
                id="email"
                value={email}
                onChange={handleChange}
                className="w-full p-3 bg-[#1a1a1a] border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary-main"
                required
              />
            </div>

            {/* Submit button */}
            <button
              type="submit"
              className="w-full py-4 bg-green-200 text-black font-medium rounded-lg hover:bg-green-300 transition-colors"
            >
              Send reset link
            </button>
            
            {/* Back to login link */}
            <div className="text-center mt-4">
              <p className="text-gray-400">
                Remember your password?{' '}
                <button
                  type="button"
                  onClick={handleBack}
                  className="text-white hover:underline"
                >
                  Back to login
                </button>
              </p>
            </div>
          </form>
        )}
      </animated.div>
    </div>
  );
}




==== File: app\insights\page.tsx ====
'use client';

import React from 'react';
import Insights from '@/components/screens/Insights';

export default function InsightsPage() {
  return (
    <main className="relative min-h-screen">
      <Insights />
    </main>
  );
}




==== File: app\login\page.tsx ====
'use client';

import React, { useState } from 'react';
import { useRouter } from 'next/navigation';
import { animated, useSpring } from 'react-spring';
import { ArrowLeft, Eye, EyeOff } from 'lucide-react';
import { theme } from '@/lib/styles/theme';

export default function LoginPage() {
  const [showPassword, setShowPassword] = useState(false);
  const [formData, setFormData] = useState({
    email: '',
    password: '',
    rememberMe: false
  });
  const [error, setError] = useState('');
  const router = useRouter();

  // Animation for page transitions
  const pageAnimation = useSpring({
    opacity: 1,
    transform: 'translateY(0px)',
    from: { opacity: 0, transform: 'translateY(20px)' },
    config: { tension: 280, friction: 60 }
  });

  // Handle form input changes
  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value, type, checked } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: type === 'checkbox' ? checked : value
    }));
    
    // Clear error when user types
    if (error) setError('');
  };

  // Handle form submission
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    
    // Basic validation
    if (!formData.email || !formData.password) {
      setError('Please enter both email and password');
      return;
    }
    
    // In a real app, this would call an API to authenticate the user
    // For demo purposes, we'll just simulate a successful login
    console.log('Login attempt:', formData);
    
    // Simulate API call
    setTimeout(() => {
      // Set authentication cookie
      document.cookie = `auth_token=dummy_token; path=/; max-age=${60 * 60 * 24 * 7}`; // 7 days
      
      // Remove the 'new' user flag and set to a real user ID
      localStorage.removeItem('selectedUserId');
      localStorage.setItem('selectedUserId', 'user1');
      document.cookie = `selectedUserId=user1; path=/; max-age=${60 * 60 * 24 * 7}`; // 7 days
      
      // Redirect to the home page after successful login
      router.push('/');
    }, 1000);
  };

  // Go back to onboarding
  const handleBack = () => {
    router.push('/onboarding');
  };

  return (
    <div className="min-h-screen bg-app-black text-white p-6">
      {/* Header */}
      <div className="flex items-center mb-8">
        <button 
          onClick={handleBack}
          className="p-2 rounded-full hover:bg-white/10 transition-colors"
        >
          <ArrowLeft size={24} />
        </button>
        <h1 className="text-xl font-semibold ml-2">Log in to your account</h1>
      </div>

      {/* Form */}
      <animated.div style={pageAnimation}>
        <form onSubmit={handleSubmit} className="space-y-6">
          {/* Error message */}
          {error && (
            <div className="bg-red-500/20 border border-red-500 text-red-200 p-3 rounded-lg">
              {error}
            </div>
          )}
          
          {/* Email field */}
          <div>
            <label htmlFor="email" className="block text-sm font-medium text-gray-300 mb-1">
              Email Address
            </label>
            <input
              type="email"
              id="email"
              name="email"
              value={formData.email}
              onChange={handleChange}
              className="w-full p-3 bg-[#1a1a1a] border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary-main"
              required
            />
          </div>
          
          {/* Password field */}
          <div>
            <label htmlFor="password" className="block text-sm font-medium text-gray-300 mb-1">
              Password
            </label>
            <div className="relative">
              <input
                type={showPassword ? 'text' : 'password'}
                id="password"
                name="password"
                value={formData.password}
                onChange={handleChange}
                className="w-full p-3 bg-[#1a1a1a] border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary-main pr-10"
                required
              />
              <button
                type="button"
                className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400"
                onClick={() => setShowPassword(!showPassword)}
              >
                {showPassword ? <EyeOff size={20} /> : <Eye size={20} />}
              </button>
            </div>
          </div>
          
          {/* Remember me and forgot password */}
          <div className="flex justify-between items-center">
            <div className="flex items-center">
              <input
                type="checkbox"
                id="rememberMe"
                name="rememberMe"
                checked={formData.rememberMe}
                onChange={handleChange}
                className="mr-2"
              />
              <label htmlFor="rememberMe" className="text-sm text-gray-300">
                Remember me
              </label>
            </div>
            <button
              type="button"
              className="text-sm text-blue-400 hover:underline"
              onClick={() => router.push('/forgot-password')}
            >
              Forgot password?
            </button>
          </div>

          {/* Submit button */}
          <button
            type="submit"
            className="w-full py-4 bg-green-200 text-black font-medium rounded-lg hover:bg-green-300 transition-colors"
          >
            Log in
          </button>
          
          {/* Sign up link */}
          <div className="text-center mt-4">
            <p className="text-gray-400">
              Don't have an account?{' '}
              <button
                type="button"
                onClick={() => router.push('/signup')}
                className="text-white hover:underline"
              >
                Sign up
              </button>
            </p>
          </div>
        </form>
      </animated.div>
    </div>
  );
}




==== File: app\more\page.tsx ====
'use client';

import React from 'react';
import More from '@/components/screens/More';

export default function MorePage() {
  return (
    <main className="relative min-h-screen">
      <More />
    </main>
  );
}




==== File: app\new\page.tsx ====
'use client';

import React from 'react';
import NewOperation from '@/components/screens/NewOperation';

export default function NewPage() {
  return (
    <main className="relative min-h-screen">
      <NewOperation />
    </main>
  );
}




==== File: app\onboarding\page.tsx ====
'use client';

import React from 'react';
import Onboarding from '@/components/screens/Onboarding';

export default function OnboardingPage() {
  return <Onboarding />;
}




==== File: app\signup\page.tsx ====
'use client';

import React from 'react';
import SignupFlow from '@/components/screens/signup/SignupFlow';

export default function SignupPage() {
  return <SignupFlow />;
}




==== File: app\transfer\page.tsx ====
'use client';

import React from 'react';

export default function TransferPage() {
  return (
    <main className="relative min-h-screen">
      <div className="flex items-center justify-center h-screen bg-black text-white">
        <h1 className="text-2xl font-bold">Transfer</h1>
      </div>
    </main>
  );
}




==== File: app\wallet\page.tsx ====
'use client';

import React from 'react';
import Wallet from '@/components/screens/Wallet';

export default function WalletPage() {
  return (
    <main className="relative min-h-screen">
      <Wallet />
    </main>
  );
}




==== File: components\AppRoot.tsx ====
// components/AppRoot.tsx
'use client';

import React, { useEffect } from 'react';
import { UserProvider, useUser } from '@/components/context/UserContext';
import { EnhancedBankingDataProvider } from '@/components/preloaders/EnhancedBankingDataProvider';
import { BankingDataProvider } from '@/components/preloaders/BankingDataPreloader';
import AppContainer from '@/components/layout/AppContainer';
import AdminProfileSelector from '@/components/screens/AdminProfileSelector';
import Home from '@/components/screens/Home';
import LoadingSpinner from '@/components/ui/common/LoadingSpinner';

// Inner component that uses the context
const AppContent: React.FC = () => {
  const { selectedUserId, isAdminMode, setSelectedUserId, resetUserSelection } = useUser();

  // Reset to admin screen when app is closed
  useEffect(() => {
    const handleBeforeUnload = () => {
      resetUserSelection();
    };

    window.addEventListener('beforeunload', handleBeforeUnload);
    return () => {
      window.removeEventListener('beforeunload', handleBeforeUnload);
    };
  }, [resetUserSelection]);

  // Redirect new users to onboarding
  useEffect(() => {
    if (selectedUserId === 'new' && typeof window !== 'undefined') {
      window.location.href = '/onboarding';
    }
  }, [selectedUserId]);

  // Handle user selection from admin screen
  const handleSelectUser = (userId: string | null) => {
    setSelectedUserId(userId);
  };

  // Show admin screen if in admin mode
  if (isAdminMode) {
    return <AdminProfileSelector onSelectUser={handleSelectUser} />;
  }

  // Show main app if user is selected
  if (selectedUserId) {
    // If it's a new user, show loading spinner while redirect happens
    if (selectedUserId === 'new') {
      return <LoadingSpinner size="large" fullScreen={true} />;
    }
    return <Home />;
  }

  // Fallback to admin screen if no user is selected
  return <AdminProfileSelector onSelectUser={handleSelectUser} />;
};

// Root component that provides context
const AppRoot: React.FC = () => {
  return (
    <AppContainer>
      <AppContent />
    </AppContainer>
  );
};

export default AppRoot;




==== File: components\IOSFullScreen.tsx ====
// components/IOSFullScreen.tsx
'use client';

import React, { useEffect } from 'react';

/**
 * Component to handle iOS fullscreen behavior
 * This helps with iOS PWA display and handling the safe areas
 */
const IOSFullScreen: React.FC = () => {
  useEffect(() => {
    // Function to handle iOS fullscreen
    const handleIOSFullscreen = () => {
      // Only run on iOS devices
      const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !(window as any).MSStream;
      
      if (isIOS) {
        // Add iOS specific meta tags and classes if needed
        document.documentElement.classList.add('ios-device');
        
        // Handle iOS status bar
        if (window.navigator && (window.navigator as any).standalone) {
          document.documentElement.classList.add('ios-standalone');
        }
      }
    };

    // Run on mount
    handleIOSFullscreen();
    
    // Add event listener for orientation changes
    window.addEventListener('orientationchange', handleIOSFullscreen);
    
    // Cleanup
    return () => {
      window.removeEventListener('orientationchange', handleIOSFullscreen);
    };
  }, []);

  // This component doesn't render anything visible
  return null;
};

export default IOSFullScreen;




==== File: components\RegisterServiceWorker.tsx ====
'use client';

import { useEffect } from 'react';

export default function RegisterServiceWorker() {
  useEffect(() => {
    const registerSW = async () => {
      if ('serviceWorker' in navigator) {
        try {
          // Clear any caches that might be causing issues
          if ('caches' in window) {
            try {
              const cacheNames = await caches.keys();
              await Promise.all(
                cacheNames.map(cacheName => caches.delete(cacheName))
              );
              console.log('All caches cleared successfully');
            } catch (error) {
              console.error('Error clearing caches:', error);
            }
          }
          
          // Unregister any existing service workers first to ensure clean registration
          const registrations = await navigator.serviceWorker.getRegistrations();
          for (const registration of registrations) {
            await registration.unregister();
            console.log('Unregistered existing service worker');
          }
          
          // Register the service worker with explicit scope
          const registration = await navigator.serviceWorker.register('/sw.js', {
            scope: '/',
            updateViaCache: 'none' // Don't use cached versions
          });
          
          console.log('✅ Service Worker registered successfully:', registration.scope);
          
          // Force update check immediately
          registration.update();
          
          // Handle service worker updates
          registration.addEventListener('updatefound', () => {
            const newWorker = registration.installing;
            console.log('Service Worker update found!');
            
            newWorker?.addEventListener('statechange', () => {
              console.log('Service Worker state changed:', newWorker.state);
              
              // When the service worker is installed, refresh the page to activate it
              if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                console.log('New service worker installed, refreshing to activate');
                window.location.reload();
              }
            });
          });
          
          // Check if the service worker is controlling the page
          if (!navigator.serviceWorker.controller) {
            console.log('Page not yet controlled by a service worker.');
          } else {
            console.log('Page is controlled by a service worker');
          }
          
          // Listen for controlling service worker changes
          navigator.serviceWorker.addEventListener('controllerchange', () => {
            console.log('Service Worker controller changed!');
          });
          
          // Check for PWA installability
          if ('getInstalledRelatedApps' in navigator) {
            try {
              // @ts-ignore - TypeScript doesn't know about this API yet
              const relatedApps = await navigator.getInstalledRelatedApps();
              console.log('Related installed apps:', relatedApps);
            } catch (err) {
              console.error('Error checking installed related apps:', err);
            }
          }
          
          // Set up interval to check for updates
          setInterval(() => {
            registration.update();
            console.log('Checking for Service Worker updates...');
          }, 60 * 60 * 1000); // Check every hour
          
        } catch (error) {
          console.error('❌ Service Worker registration failed:', error);
        }
      } else {
        console.warn('Service workers are not supported in this browser.');
      }
    };

    // Register service worker when the component mounts
    registerSW();
    
    // Set up beforeinstallprompt event listener at the window level
    const handleBeforeInstallPrompt = (e: Event) => {
      console.log('beforeinstallprompt event captured in RegisterServiceWorker');
      // Don't prevent default here - let the PWAInstallPrompt component handle it
    };
    
    // Set up appinstalled event listener
    const handleAppInstalled = (e: Event) => {
      console.log('App was installed successfully', e);
    };
    
    // Add event listeners
    window.addEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
    window.addEventListener('appinstalled', handleAppInstalled);
    
    // Clean up event listeners on unmount
    return () => {
      window.removeEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
      window.removeEventListener('appinstalled', handleAppInstalled);
    };
  }, []);

  return null;
}




==== File: components\context\UnifiedBankingDataProvider.tsx ====
'use client';

import React, { useState, useEffect, createContext, useContext, ReactNode } from 'react';
import { bankingData } from '@/lib/data/fakeBankingData';
import { useUser } from '@/components/context/UserContext';
// Import types but create a modified version for our actual data structure
import { BankingDataType as OriginalBankingDataType, BankingUser, BankingAccount, BankingCreditCard, BankingLoan, BankingTransaction, TransactionDateGroup } from '@/lib/types';

// Modified BankingDataType to match the actual structure in fakeBankingData.js
type ActualBankingDataType = {
  users: BankingUser[];
  accounts: BankingAccount[];
  creditCards: BankingCreditCard[];
  loans: BankingLoan[];
  transactions: {
    [userId: string]: {
      [accountId: string]: any[]; // Using any[] instead of BankingTransaction[] for flexibility
    };
  };
  groupedTransactions: {
    [userId: string]: TransactionDateGroup[];
  };
  categoryTotals?: {
    [userId: string]: Record<string, number>;
  };
};

// Define the context types
type UnifiedBankingDataContextType = {
  // Raw data
  data: ActualBankingDataType | null;
  
  // Filtered data for the selected user
  userData: {
    user: BankingUser | undefined;
    accounts: BankingAccount[];
    creditCards: BankingCreditCard[];
    loans: BankingLoan[];
    transactions: any;
    groupedTransactions: TransactionDateGroup[];
  } | null;
  
  // Loading and error states
  isLoading: boolean;
  error: Error | null;
  
  // Functions
  refreshData: () => void;
  clearCache: () => void;
};

// Create the context
const UnifiedBankingDataContext = createContext<UnifiedBankingDataContextType | null>(null);

// Props for the provider component
interface UnifiedBankingDataProviderProps {
  children: ReactNode;
  cacheKey?: string;
  simulateApiDelay?: number;
  preProcessData?: boolean;
}

/**
 * Unified Banking Data Provider
 * 
 * Combines functionality from BankingDataProvider and EnhancedBankingDataProvider
 * - Provides access to preloaded banking data throughout the app
 * - Filters data based on selected user from UserContext
 * - Handles caching, loading states, and error handling
 */
export const UnifiedBankingDataProvider: React.FC<UnifiedBankingDataProviderProps> = ({ 
  children,
  cacheKey = 'members1stBankingData',
  simulateApiDelay = 0,
  preProcessData = false
}) => {
  // State for raw data
  const [data, setData] = useState<ActualBankingDataType | null>(null);
  
  // State for user-filtered data
  const [userData, setUserData] = useState<any>(null);
  
  // Loading and error states
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);
  
  // Get user context
  const { selectedUserId, isNewUser } = useUser();

  // Process data for the selected user
  const processUserData = (bankingDataObj: ActualBankingDataType) => {
    if (selectedUserId && selectedUserId !== 'new') {
      const user = bankingDataObj.users.find((u: BankingUser) => u.id === selectedUserId);
      const accounts = bankingDataObj.accounts.filter((a: BankingAccount) => a.userId === selectedUserId);
      const creditCards = bankingDataObj.creditCards.filter((c: BankingCreditCard) => c.userId === selectedUserId);
      const loans = bankingDataObj.loans.filter((l: BankingLoan) => l.userId === selectedUserId);
      const transactions = bankingDataObj.transactions[selectedUserId] || {};
      const groupedTransactions = bankingDataObj.groupedTransactions[selectedUserId] || [];
      
      setUserData({
        user,
        accounts,
        creditCards,
        loans,
        transactions,
        groupedTransactions
      });
    } else if (isNewUser) {
      // For new user flow, provide empty data structure
      setUserData({
        user: null,
        accounts: [],
        creditCards: [],
        loans: [],
        transactions: {},
        groupedTransactions: []
      });
    } else {
      // No user selected, provide full data
      setUserData({
        user: null,
        accounts: bankingDataObj.accounts,
        creditCards: bankingDataObj.creditCards,
        loans: bankingDataObj.loans,
        transactions: bankingDataObj.transactions,
        groupedTransactions: []
      });
    }
  };

  // Pre-process data if needed
  const preProcess = (rawData: any): ActualBankingDataType => {
    if (!preProcessData) return rawData as ActualBankingDataType;
    
    // Create a deep copy to avoid mutations
    const processedData = JSON.parse(JSON.stringify(rawData)) as any;
    
    // Example: Add transaction totals by category
    processedData.users.forEach((user: BankingUser) => {
      const userTransactions: any[] = [];
      
      // Collect all user transactions
      Object.values(processedData.transactions[user.id] || {}).forEach(accountTxs => {
        userTransactions.push(...(accountTxs as any[]));
      });
      
      // Calculate category totals
      const categoryTotals = userTransactions.reduce((totals: Record<string, number>, tx: any) => {
        if (!tx.isIncoming) {
          const category = tx.category || 'other';
          totals[category] = (totals[category] || 0) + tx.amount;
        }
        return totals;
      }, {});
      
      // Add to user data
      (processedData as any).categoryTotals = (processedData as any).categoryTotals || {};
      (processedData as any).categoryTotals[user.id] = categoryTotals;
    });
    
    return processedData;
  };

  // Load data on mount and when selectedUserId changes
  useEffect(() => {
    const loadData = async () => {
      try {
        setIsLoading(true);
        
        // Simulate API delay if needed
        if (simulateApiDelay > 0) {
          await new Promise(resolve => setTimeout(resolve, simulateApiDelay));
        }
        
        // Get cached data if available
        const cachedData = localStorage.getItem(cacheKey);
        let bankingDataObj: ActualBankingDataType;
        
        if (cachedData) {
          bankingDataObj = JSON.parse(cachedData);
        } else {
          // Process and cache the data
          bankingDataObj = preProcess(bankingData as any);
          localStorage.setItem(cacheKey, JSON.stringify(bankingDataObj));
        }
        
        setData(bankingDataObj);
        
        // Process data for the selected user
        processUserData(bankingDataObj);
      } catch (err) {
        console.error('Error loading banking data:', err);
        setError(err instanceof Error ? err : new Error('Unknown error loading banking data'));
      } finally {
        setIsLoading(false);
      }
    };

    loadData();
  }, [selectedUserId, isNewUser, cacheKey, simulateApiDelay, preProcessData]);

  // Refresh data function
  const refreshData = () => {
    setIsLoading(true);
    
    try {
      // Process and cache the data
      const processedData = preProcess(bankingData as any);
      localStorage.setItem(cacheKey, JSON.stringify(processedData));
      setData(processedData);
      
      // Process data for the selected user
      processUserData(processedData);
    } catch (err) {
      console.error('Error refreshing banking data:', err);
      setError(err instanceof Error ? err : new Error('Unknown error refreshing banking data'));
    } finally {
      setIsLoading(false);
    }
  };

  // Clear cache function
  const clearCache = () => {
    localStorage.removeItem(cacheKey);
  };

  // Context value
  const value: UnifiedBankingDataContextType = {
    data,
    userData,
    isLoading,
    error,
    refreshData,
    clearCache
  };

  return (
    <UnifiedBankingDataContext.Provider value={value}>
      {children}
    </UnifiedBankingDataContext.Provider>
  );
};

// Custom hook to access banking data
export const useBankingData = () => {
  const context = useContext(UnifiedBankingDataContext);
  if (!context) {
    throw new Error('useBankingData must be used within a UnifiedBankingDataProvider');
  }
  return context;
};




==== File: components\context\UserContext.tsx ====
// components/context/UserContext.tsx
'use client';

import React, { createContext, useState, useContext, useEffect, ReactNode } from 'react';
import { bankingData } from '@/lib/data/fakeBankingData';

// Define the context types
type UserContextType = {
  selectedUserId: string | null;
  isNewUser: boolean;
  isAdminMode: boolean;
  setSelectedUserId: (userId: string | null) => void;
  toggleAdminMode: () => void;
  resetUserSelection: () => void;
};

// Create the context with default values
const UserContext = createContext<UserContextType>({
  selectedUserId: null,
  isNewUser: false,
  isAdminMode: true,
  setSelectedUserId: () => {},
  toggleAdminMode: () => {},
  resetUserSelection: () => {},
});

// Props for the provider component
interface UserProviderProps {
  children: ReactNode;
  initialAdminMode?: boolean;
}

// Provider component
export const UserProvider: React.FC<UserProviderProps> = ({ 
  children, 
  initialAdminMode = process.env.NODE_ENV === 'development' 
}) => {
  // State for selected user ID
  const [selectedUserId, setSelectedUserId] = useState<string | null>(null);
  // State for admin mode
  const [isAdminMode, setIsAdminMode] = useState<boolean>(initialAdminMode);
  // Derived state for new user
  const isNewUser = selectedUserId === 'new';

  // Load selected user from localStorage on mount
  useEffect(() => {
    const storedUserId = localStorage.getItem('selectedUserId');
    if (storedUserId) {
      setSelectedUserId(storedUserId === 'new' ? 'new' : storedUserId);
      // If a user is already selected, exit admin mode
      if (isAdminMode) {
        setIsAdminMode(false);
      }
    }
  }, [isAdminMode]);

  // Handle user selection
  const handleSetSelectedUserId = (userId: string | null) => {
    if (userId === 'new') {
      localStorage.setItem('selectedUserId', 'new');
      setSelectedUserId('new');
    } else if (userId) {
      localStorage.setItem('selectedUserId', userId);
      setSelectedUserId(userId);
    } else {
      localStorage.removeItem('selectedUserId');
      setSelectedUserId(null);
    }
    
    // Exit admin mode when a user is selected
    if (isAdminMode) {
      setIsAdminMode(false);
    }
  };

  // Toggle admin mode
  const toggleAdminMode = () => {
    setIsAdminMode(prev => !prev);
  };

  // Reset user selection and go back to admin mode
  const resetUserSelection = () => {
    localStorage.removeItem('selectedUserId');
    setSelectedUserId(null);
    setIsAdminMode(true);
  };

  // Context value
  const value = {
    selectedUserId,
    isNewUser,
    isAdminMode,
    setSelectedUserId: handleSetSelectedUserId,
    toggleAdminMode,
    resetUserSelection,
  };

  return (
    <UserContext.Provider value={value}>
      {children}
    </UserContext.Provider>
  );
};

// Custom hook to use the user context
export const useUser = () => {
  const context = useContext(UserContext);
  if (!context) {
    throw new Error('useUser must be used within a UserProvider');
  }
  return context;
};




==== File: components\layout\AppContainer.tsx ====
// components/layout/AppContainer.tsx
'use client';

import React, { ReactNode } from 'react';
import BottomNav from '@/components/ui/navigation/BottomNav';
import { UserProvider } from '@/components/context/UserContext';
import { EnhancedBankingDataProvider } from '@/components/preloaders/EnhancedBankingDataProvider';
import { BankingDataProvider } from '@/components/preloaders/BankingDataPreloader';
import ThemeContextProvider from '@/lib/context/ThemeContextProvider';
import IOSFullScreenProvider from '@/lib/utils/IOSFullScreenProvider';
import PWAInstallPrompt from '@/components/ui/common/PWAInstallPrompt';

interface AppContainerProps {
  children: ReactNode;
}

/**
 * AppContainer component
 * Wraps the entire application and provides the bottom navigation
 * This ensures the bottom navigation is only loaded once and is consistent across all pages
 */
const AppContainer: React.FC<AppContainerProps> = ({ children }) => {
  return (
    <ThemeContextProvider>
      <IOSFullScreenProvider>
        <UserProvider>
          <BankingDataProvider>
            <EnhancedBankingDataProvider>
              <div className="min-h-screen bg-neutral-800 text-white relative pb-16">
                {/* PWA Install Prompt */}
                <PWAInstallPrompt />
                
                {/* Loading Spinner Container - fixed position above everything */}
                <div className="fixed inset-0 z-[200] pointer-events-none">
                  {/* Spinner will be rendered here when needed */}
                </div>
                
                {/* Main content */}
                <div className="mx-auto max-w-md">
                  <main className="relative">
                    {children}
                  </main>
                </div>
                
                {/* Bottom navigation - fixed at the bottom */}
                <div className="fixed bottom-0 left-0 right-0 z-[100]">
                  <BottomNav />
                </div>
              </div>
            </EnhancedBankingDataProvider>
          </BankingDataProvider>
        </UserProvider>
      </IOSFullScreenProvider>
    </ThemeContextProvider>
  );
};

export default AppContainer;




==== File: components\preloaders\BankingDataPreloader.js ====
// BankingDataPreloader.js
// Specialized component for preloading and processing banking data

import React, { useState, useEffect, useContext, createContext } from 'react';
import { bankingData } from '@/lib/data/fakeBankingData';

// Create context for banking data
const BankingDataContext = createContext(null);

/**
 * Banking Data Provider
 * Provides access to preloaded banking data throughout the app
 */
export const BankingDataProvider = ({ children }) => {
  const [data, setData] = useState(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);

  // Load data on mount
  useEffect(() => {
    // In a real app, this would be an API call
    // We're using the fake data for demo purposes
    const loadData = async () => {
      try {
        // Get cached data if available
        const cachedData = localStorage.getItem('members1stBankingData');
        
        if (cachedData) {
          setData(JSON.parse(cachedData));
        } else {
          // Process and cache the data
          localStorage.setItem('members1stBankingData', JSON.stringify(bankingData));
          setData(bankingData);
        }
      } catch (err) {
        console.error('Error loading banking data:', err);
        setError(err);
      } finally {
        setIsLoading(false);
      }
    };

    loadData();
  }, []);

  // Context value
  const value = {
    data,
    isLoading,
    error,
    refreshData: () => {
      setIsLoading(true);
      localStorage.removeItem('members1stBankingData');
      localStorage.setItem('members1stBankingData', JSON.stringify(bankingData));
      setData(bankingData);
      setIsLoading(false);
    }
  };

  return (
    <BankingDataContext.Provider value={value}>
      {children}
    </BankingDataContext.Provider>
  );
};

// Custom hook to access banking data
export const useBankingData = () => {
  const context = useContext(BankingDataContext);
  if (!context) {
    throw new Error('useBankingData must be used within a BankingDataProvider');
  }
  return context;
};

/**
 * Banking Data Preloader
 * 
 * Preloads and processes all necessary banking data before showing the app
 * 
 * @param {Function} onComplete - Callback when data is loaded
 * @param {Function} onProgress - Progress callback (0-100)
 * @param {Object} options - Configuration options
 */
const BankingDataPreloader = ({ onComplete, onProgress, options = {} }) => {
  // Default options
  const config = {
    simulateApiDelay: options.simulateApiDelay || 800,
    mockNetworkConditions: options.mockNetworkConditions || false,
    preProcessData: options.preProcessData || false,
    ...options
  };

  // Preload stages
  const stages = [
    { name: 'Authenticating', weight: 15 },
    { name: 'Loading account data', weight: 25 },
    { name: 'Processing transactions', weight: 30 },
    { name: 'Preparing interface', weight: 30 }
  ];

  // Load data in stages to simulate real banking app experience
  useEffect(() => {
    let active = true;
    let currentProgress = 0;
    let stageIndex = 0;

    const processStage = async (stage) => {
      if (!active) return;

      // Start this stage
      console.log(`Processing stage: ${stage.name}`);
      
      // Calculate progress range for this stage
      const startProgress = currentProgress;
      const endProgress = currentProgress + stage.weight;
      
      // Simulate processing with progress updates
      const steps = 10;
      for (let i = 0; i < steps; i++) {
        if (!active) return;
        
        await new Promise(resolve => 
          setTimeout(resolve, config.simulateApiDelay / steps)
        );
        
        // Calculate and report progress
        const stageProgress = startProgress + (stage.weight * (i + 1) / steps);
        currentProgress = Math.min(stageProgress, 100);
        onProgress && onProgress(Math.round(currentProgress));
      }
      
      // Optional network condition simulation
      if (config.mockNetworkConditions && Math.random() < 0.1) {
        // 10% chance of slight delay
        await new Promise(resolve => setTimeout(resolve, 500));
      }
    };

    const loadData = async () => {
      try {
        // Process each stage
        for (const stage of stages) {
          await processStage(stage);
          stageIndex++;
        }
        
        // Process banking data based on config
        if (config.preProcessData) {
          // In a real app, we might pre-calculate balances, categorize transactions, etc.
          console.log('Pre-processing banking data...');
          
          // Create a copy of the data to avoid mutations
          const processedData = JSON.parse(JSON.stringify(bankingData));
          
          // Example: Add transaction totals by category
          processedData.users.forEach(user => {
            const userTransactions = [];
            
            // Collect all user transactions
            Object.values(processedData.transactions[user.id] || {}).forEach(accountTxs => {
              userTransactions.push(...accountTxs);
            });
            
            // Calculate category totals
            const categoryTotals = userTransactions.reduce((totals, tx) => {
              if (!tx.isIncoming) {
                const category = tx.category || 'other';
                totals[category] = (totals[category] || 0) + tx.amount;
              }
              return totals;
            }, {});
            
            // Add to user data
            processedData.categoryTotals = processedData.categoryTotals || {};
            processedData.categoryTotals[user.id] = categoryTotals;
          });
          
          // Store processed data
          localStorage.setItem('members1stBankingData', JSON.stringify(processedData));
        } else {
          // Just store the original data
          localStorage.setItem('members1stBankingData', JSON.stringify(bankingData));
        }
        
        // Complete
        onComplete && onComplete();
      } catch (error) {
        console.error('Error in data preloading:', error);
        
        // Store fallback data to allow app to run
        localStorage.setItem('members1stBankingData', JSON.stringify(bankingData));
        
        // Still call onComplete to let app load
        onComplete && onComplete();
      }
    };

    loadData();

    return () => {
      active = false;
    };
  }, [config, onComplete, onProgress]);

  // This component doesn't render anything visual
  return null;
};

export default BankingDataPreloader;




==== File: components\preloaders\CompleteBankingPreloader.js ====
// components/preloaders/CompleteBankingPreloader.js
import React, { useState, useEffect } from 'react';
import ImagePreloader from './ImagePreloader';
import BankingDataPreloader from './BankingDataPreloader';
import { preloaderConfig } from '@/lib/config/preloaderConfig';

/**
 * Comprehensive Banking App Preloader
 * Handles preloading of all required assets and data
 */
const CompleteBankingPreloader = ({ children, onComplete }) => {
  // Preloading states
  const [dataLoadingComplete, setDataLoadingComplete] = useState(false);
  const [imageLoadingComplete, setImageLoadingComplete] = useState(false);
  const [dataProgress, setDataProgress] = useState(0);
  const [imageProgress, setImageProgress] = useState(0);
  
  // Get configuration
  const config = preloaderConfig;
  
  // Calculate overall progress (50% data, 50% images)
  const totalProgress = Math.round((dataProgress * 0.5) + (imageProgress * 0.5));
  
  // Check if everything is loaded
  const isAppReady = dataLoadingComplete && imageLoadingComplete;
  
  // Add a small delay after loading completes for a smoother transition
  const [showApp, setShowApp] = useState(false);
  
  useEffect(() => {
    if (isAppReady) {
      const timer = setTimeout(() => {
        setShowApp(true);
        if (onComplete) onComplete();
      }, config.loadingScreen.transitionDuration);
      
      return () => clearTimeout(timer);
    }
  }, [isAppReady, config.loadingScreen.transitionDuration, onComplete]);
  
  // Loading screen component
  const LoadingScreen = () => (
    <div className="fixed inset-0 bg-[#1c1c1c] flex flex-col items-center justify-center z-50">
      <div className="w-24 h-24">
        <img 
          src="/icons/icon-192x192.png" 
          alt="Members 1st" 
          className="w-full h-full object-contain animate-spin"
          style={{
            animationDuration: '2s',
            animationTimingFunction: 'cubic-bezier(0.68, -0.55, 0.27, 1.55)'
          }}
        />
      </div>
    </div>
  );
  
  return (
    <>
      {/* Preloader components */}
      <BankingDataPreloader 
        onProgress={setDataProgress}
        onComplete={() => setDataLoadingComplete(true)}
        options={{
          preProcessData: config.bankingData.preProcessData,
          simulateApiDelay: config.bankingData.simulateApiDelay
        }}
      />
      
      <ImagePreloader 
        onProgress={setImageProgress}
        onComplete={() => setImageLoadingComplete(true)}
        options={{
          timeout: config.images.timeout,
          retries: config.images.retries,
          parallel: config.images.parallel,
          priorityImages: config.images.priorityImages
        }}
      />
      
      {/* Show app or loading screen */}
      {showApp ? children : <LoadingScreen />}
    </>
  );
};

export default CompleteBankingPreloader;




==== File: components\preloaders\EnhancedBankingDataProvider.tsx ====
// components/preloaders/EnhancedBankingDataProvider.tsx
'use client';

// Disable TypeScript checking for this file
// @ts-nocheck

import React, { useState, useEffect, createContext, useContext, ReactNode } from 'react';
import { bankingData } from '@/lib/data/fakeBankingData';
import { useUser } from '@/components/context/UserContext';

// Define the context types
type EnhancedBankingDataContextType = {
  data: any;
  userData: any;
  isLoading: boolean;
  error: Error | null;
  refreshData: () => void;
};

// Create the context
const EnhancedBankingDataContext = createContext<EnhancedBankingDataContextType | null>(null);

// Props for the provider component
interface EnhancedBankingDataProviderProps {
  children: ReactNode;
}

/**
 * Enhanced Banking Data Provider
 * Provides access to preloaded banking data throughout the app
 * Filters data based on selected user from UserContext
 */
export const EnhancedBankingDataProvider: React.FC<EnhancedBankingDataProviderProps> = ({ children }) => {
  const [data, setData] = useState<any>(null);
  const [userData, setUserData] = useState<any>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);
  
  // Get user context
  const { selectedUserId, isNewUser } = useUser();

  // Load data on mount and when selectedUserId changes
  useEffect(() => {
    const loadData = async () => {
      try {
        setIsLoading(true);
        
        // Get cached data if available
        const cachedData = localStorage.getItem('members1stBankingData');
        let bankingDataObj;
        
        if (cachedData) {
          bankingDataObj = JSON.parse(cachedData);
        } else {
          // Process and cache the data
          localStorage.setItem('members1stBankingData', JSON.stringify(bankingData));
          bankingDataObj = bankingData;
        }
        
        setData(bankingDataObj);
        
        // Filter data for selected user
        if (selectedUserId && selectedUserId !== 'new') {
          const user = bankingDataObj.users.find((u: any) => u.id === selectedUserId);
          const accounts = bankingDataObj.accounts.filter((a: any) => a.userId === selectedUserId);
          const creditCards = bankingDataObj.creditCards.filter((c: any) => c.userId === selectedUserId);
          const loans = bankingDataObj.loans.filter((l: any) => l.userId === selectedUserId);
          const transactions = bankingDataObj.transactions[selectedUserId as keyof typeof bankingDataObj.transactions] || {};
          const groupedTransactions = bankingDataObj.groupedTransactions[selectedUserId as keyof typeof bankingDataObj.groupedTransactions] || [];
          
          setUserData({
            user,
            accounts,
            creditCards,
            loans,
            transactions,
            groupedTransactions
          });
        } else if (isNewUser) {
          // For new user flow, provide empty data structure
          setUserData({
            user: null,
            accounts: [],
            creditCards: [],
            loans: [],
            transactions: {},
            groupedTransactions: []
          });
        } else {
          // No user selected, provide full data
          setUserData({
            user: null,
            accounts: bankingDataObj.accounts,
            creditCards: bankingDataObj.creditCards,
            loans: bankingDataObj.loans,
            transactions: bankingDataObj.transactions,
            groupedTransactions: []
          });
        }
      } catch (err) {
        console.error('Error loading banking data:', err);
        setError(err instanceof Error ? err : new Error('Unknown error loading banking data'));
      } finally {
        setIsLoading(false);
      }
    };

    loadData();
  }, [selectedUserId, isNewUser]);

  // Context value
  const value = {
    data,
    userData,
    isLoading,
    error,
    refreshData: () => {
      setIsLoading(true);
      localStorage.removeItem('members1stBankingData');
      localStorage.setItem('members1stBankingData', JSON.stringify(bankingData));
      setData(bankingData);
      
      // Re-filter data for selected user
      if (selectedUserId && selectedUserId !== 'new') {
        const user = bankingData.users.find((u: any) => u.id === selectedUserId);
        const accounts = bankingData.accounts.filter((a: any) => a.userId === selectedUserId);
        const creditCards = bankingData.creditCards.filter((c: any) => c.userId === selectedUserId);
        const loans = bankingData.loans.filter((l: any) => l.userId === selectedUserId);
        const transactions = bankingData.transactions[selectedUserId as keyof typeof bankingData.transactions] || {};
        const groupedTransactions = bankingData.groupedTransactions[selectedUserId as keyof typeof bankingData.groupedTransactions] || [];
        
        setUserData({
          user,
          accounts,
          creditCards,
          loans,
          transactions,
          groupedTransactions
        });
      } else {
        setUserData({
          user: null,
          accounts: bankingData.accounts,
          creditCards: bankingData.creditCards,
          loans: bankingData.loans,
          transactions: bankingData.transactions,
          groupedTransactions: []
        });
      }
      
      setIsLoading(false);
    }
  };

  return (
    <EnhancedBankingDataContext.Provider value={value}>
      {children}
    </EnhancedBankingDataContext.Provider>
  );
};

// Custom hook to access banking data
export const useEnhancedBankingData = () => {
  const context = useContext(EnhancedBankingDataContext);
  if (!context) {
    throw new Error('useEnhancedBankingData must be used within an EnhancedBankingDataProvider');
  }
  return context;
};




==== File: components\preloaders\ImagePreloader.js ====
// ImagePreloader.js
// Specialized component for preloading banking images

import React, { useState, useEffect } from 'react';

/**
 * Banking App Image Preloader
 * 
 * This utility aggressively preloads all images needed for the initial app experience,
 * including card backgrounds, merchant icons, and UI elements.
 * 
 * @param {Function} onComplete - Callback when all images are loaded
 * @param {Function} onProgress - Callback with loading progress (0-100)
 * @param {Object} options - Configuration options
 */
const ImagePreloader = ({ onComplete, onProgress, options = {} }) => {
  // Configuration with defaults
  const config = {
    timeout: options.timeout || 15000, // 15 second timeout default
    retries: options.retries || 2,     // Retry failed images twice
    parallel: options.parallel || 6,   // Load 6 images in parallel
    ...options
  };
  
  // Track loading state
  const [loadStatus, setLoadStatus] = useState({
    loaded: 0,
    failed: 0,
    total: 0,
    inProgress: 0,
    complete: false
  });
  
  // List all images to preload by category
  const imagesToPreload = {
    essentialUI: [
      // App UI elements - Priority 1
      '/images/icons/logo.png',
      '/images/ui/loading-spinner.svg',
      '/images/ui/header-bg.png'
    ],
    
    avatars: [
      // User avatars - Priority 2
      '/images/avatar/jess-coleman.png',
      '/images/avatar/robert-thompson.png',
    ],
    
    cards: [
      // Credit card images - Priority 3
      '/images/cards/visa-signature-bg.png',
      '/images/cards/visa-platinum-bg.png',
      '/images/cards/visa-logo.svg',
      '/images/cards/chip.png'
    ],
    
    merchantIcons: [
      // Transaction merchant icons - Priority 4
      '/images/icons/merchants/coffee.svg',
      '/images/icons/merchants/shopping.svg',
      '/images/icons/merchants/food.svg',
      '/images/icons/merchants/entertainment.svg',
      '/images/icons/merchants/transport.svg',
      '/images/icons/merchants/utilities.svg',
      '/images/icons/merchants/health.svg',
      '/images/icons/merchants/payroll.svg',
      '/images/icons/merchants/home.svg'
    ],
    
    otherContent: [
      // Marketing and secondary images - Priority 5
      '/images/refer/refer-friend.png',
      '/images/marketing/promo-banner.jpg',
      '/images/ui/card-pattern.svg'
    ]
  };
  
  // Flatten and prioritize images
  const allImages = [
    ...imagesToPreload.essentialUI,
    ...imagesToPreload.avatars,
    ...imagesToPreload.cards,
    ...imagesToPreload.merchantIcons,
    ...imagesToPreload.otherContent
  ];
  
  // Preload images in a controlled manner
  useEffect(() => {
    if (allImages.length === 0) {
      onComplete && onComplete();
      return;
    }
    
    let active = true; // For cleanup
    let queue = [...allImages];
    let loading = 0;
    let loadedCount = 0;
    let failedCount = 0;
    let retryMap = {};
    
    // Set initial state
    setLoadStatus({
      loaded: 0,
      failed: 0,
      total: queue.length,
      inProgress: 0,
      complete: false
    });
    
    // Process the next image in queue
    const processNext = () => {
      if (!active) return;
      
      // If queue is empty and nothing is loading, we're done
      if (queue.length === 0 && loading === 0) {
        setLoadStatus(prev => ({
          ...prev,
          inProgress: 0,
          complete: true
        }));
        onComplete && onComplete();
        return;
      }
      
      // Only load up to config.parallel images at once
      while (queue.length > 0 && loading < config.parallel) {
        const src = queue.shift();
        loading++;
        
        const img = new Image();
        const startTime = Date.now();
        
        // Handle successful load
        img.onload = () => {
          if (!active) return;
          
          loadedCount++;
          loading--;
          
          setLoadStatus(prev => {
            const newStatus = {
              ...prev,
              loaded: prev.loaded + 1,
              inProgress: prev.inProgress - 1
            };
            
            // Calculate and report progress
            const progress = Math.round(((newStatus.loaded + newStatus.failed) / newStatus.total) * 100);
            onProgress && onProgress(progress);
            
            return newStatus;
          });
          
          // Process next image
          processNext();
        };
        
        // Handle failed load
        img.onerror = () => {
          if (!active) return;
          
          // Implement retry logic
          const retryCount = retryMap[src] || 0;
          
          if (retryCount < config.retries) {
            // Put back in queue for retry
            retryMap[src] = retryCount + 1;
            queue.push(src);
          } else {
            // Mark as failed after retries
            failedCount++;
            
            setLoadStatus(prev => {
              const newStatus = {
                ...prev,
                failed: prev.failed + 1,
                inProgress: prev.inProgress - 1
              };
              
              // Calculate and report progress even for failures
              const progress = Math.round(((newStatus.loaded + newStatus.failed) / newStatus.total) * 100);
              onProgress && onProgress(progress);
              
              return newStatus;
            });
          }
          
          loading--;
          processNext();
        };
        
        // Track in-progress loads
        setLoadStatus(prev => ({
          ...prev,
          inProgress: prev.inProgress + 1
        }));
        
        // Start loading image
        img.src = src;
        
        // Set timeout for individual image load
        setTimeout(() => {
          if (img.complete) return;
          // Force error event if image takes too long
          img.dispatchEvent(new Event('error'));
        }, config.timeout);
      }
    };
    
    // Start processing queue
    processNext();
    
    // Cleanup function
    return () => {
      active = false;
    };
  }, [allImages, config, onComplete, onProgress]);
  
  // Component doesn't render anything visible
  return null;
};

export default ImagePreloader;




==== File: components\screens\AdminProfileSelector.tsx ====
// components/screens/AdminProfileSelector.tsx
'use client';

import React, { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { bankingData } from '@/lib/data/fakeBankingData';
import { animated, useSpring } from 'react-spring';
import PWAInstallPrompt from '@/components/ui/common/PWAInstallPrompt';

interface AdminProfileSelectorProps {
  onSelectUser: (userId: string | null) => void;
}

const AdminProfileSelector: React.FC<AdminProfileSelectorProps> = ({ onSelectUser }) => {
  const router = useRouter();
  const [users, setUsers] = useState(bankingData.users);
  const [isLoading, setIsLoading] = useState(true);

  // Animation for the container
  const containerSpring = useSpring({
    from: { opacity: 0, y: 20 },
    to: { opacity: 1, y: 0 },
    config: { tension: 280, friction: 25 },
    delay: 300,
  });

  // Animation for the title
  const titleSpring = useSpring({
    from: { opacity: 0, y: -20 },
    to: { opacity: 1, y: 0 },
    config: { tension: 280, friction: 25 },
    delay: 400,
  });

  // Animation for the cards
  const cardSpring = useSpring({
    from: { opacity: 0, scale: 0.9 },
    to: { opacity: 1, scale: 1 },
    config: { tension: 280, friction: 25 },
    delay: 500,
  });

  // Simulate loading
  useEffect(() => {
    const timer = setTimeout(() => {
      setIsLoading(false);
    }, 800);
    return () => clearTimeout(timer);
  }, []);

  // Handle user selection
  const handleSelectUser = (userId: string | null) => {
    // Store the selected user ID in localStorage
    if (userId === 'new') {
      // For new user flow
      localStorage.setItem('selectedUserId', 'new');
      onSelectUser('new');
    } else if (userId) {
      // For existing users
      localStorage.setItem('selectedUserId', userId);
      onSelectUser(userId);
    } else {
      // Fallback (should not happen)
      localStorage.removeItem('selectedUserId');
      onSelectUser(null);
    }
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-screen bg-[#1c1c1c]">
        <div className="w-24 h-24">
          <img 
            src="/icons/icon-192x192.png" 
            alt="Members 1st" 
            className="w-full h-full object-contain animate-spin"
            style={{
              animationDuration: '2s',
              animationTimingFunction: 'cubic-bezier(0.68, -0.55, 0.27, 1.55)'
            }}
          />
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-app-black text-white p-5">
      <animated.div style={titleSpring} className="text-center mb-8 pt-6">
        <h1 className="text-2xl font-bold mb-2">Banking App Admin</h1>
        <p className="text-neutral-400">Select a profile to continue</p>
      </animated.div>

      <animated.div style={containerSpring} className="max-w-md mx-auto">
        {/* New User Option */}
        <animated.div 
          style={cardSpring} 
          className="bg-[#212121] rounded-xl p-5 mb-5 cursor-pointer hover:shadow-lg transition-shadow"
          onClick={() => handleSelectUser('new')}
        >
          <div className="flex items-center">
            <div className="w-12 h-12 bg-white rounded-full flex items-center justify-center mr-4">
              <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 text-neutral-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 6v6m0 0v6m0-6h6m-6 0H6" />
              </svg>
            </div>
            <div>
              <h2 className="text-xl font-bold">New User</h2>
              <p className="text-neutral-400">Start with a fresh account</p>
            </div>
          </div>
        </animated.div>

        <h3 className="text-lg font-medium mb-3 text-neutral-300">Existing Profiles</h3>
        
        {/* Existing Users */}
        {users.map((user, index) => {
          // Find user's account
          const userAccount = bankingData.accounts.find(account => account.userId === user.id);
          // Find user's credit card
          const userCard = bankingData.creditCards.find(card => card.userId === user.id);
          
          return (
            <animated.div 
              key={user.id}
              style={cardSpring} 
              className="bg-[#212121] rounded-xl p-5 mb-4 cursor-pointer hover:bg-neutral-700 transition-colors"
              onClick={() => handleSelectUser(user.id)}
            >
              <div className="flex items-center mb-3">
                <img 
                  src={user.avatar || '/images/avatar/placeholder.svg'} 
                  alt={user.name} 
                  className="w-12 h-12 rounded-full mr-4 object-cover border border-gray-700"
                />
                <div className="flex-1">
                  <div className="flex justify-between items-start">
                    <div>
                      <h2 className="text-xl font-bold">{user.name}</h2>
                      <p className="text-neutral-400">{user.occupation}</p>
                    </div>
                    <button 
                      className="text-neutral-400 hover:text-white transition-colors"
                      onClick={(e) => {
                        e.stopPropagation();
                        // TODO: Implement account modification
                        console.log('Edit account:', user.id);
                      }}
                    >
                      <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                      </svg>
                    </button>
                  </div>
                </div>
              </div>
              
              <div className="grid grid-cols-2 gap-3 text-sm">
                <div className="bg-neutral-700 p-3 rounded-lg">
                  <p className="text-neutral-400 mb-1">Checking Balance</p>
                  <p className="text-white font-medium">${userAccount?.balance.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</p>
                </div>
                <div className="bg-neutral-900 p-3 rounded-lg">
                  <p className="text-neutral-400 mb-1">Credit Card</p>
                  <p className="text-white font-medium">{userCard?.name || 'None'}</p>
                </div>
              </div>
            </animated.div>
          );
        })}

        <div className="mt-8 text-center text-xs text-neutral-500">
          <p>This screen is only visible in development mode</p>
          <p className="mt-1">Banking App Admin v1.0</p>
        </div>
      </animated.div>
    </div>
  );
};

export default AdminProfileSelector;




==== File: components\screens\Home.tsx ====
// components/screens/Home.tsx
'use client';

import React, { useState, useEffect, useRef } from 'react';
import { animated, useSpring } from 'react-spring';
import { getDefaultCard } from '@/lib/data/cards';
import { getTransactions } from '@/lib/data/transactions';
import { useEnhancedBankingData } from '@/components/preloaders/EnhancedBankingDataProvider';
import CreditCardComponent from '../ui/card/CreditCard'; 
import TransactionContainer from '../ui/transactions/TransactionContainer';
import Header from '../ui/navigation/Header';
import LoadingSpinner from '../ui/common/LoadingSpinner';
import Icon from '../ui/icons/Icon';
import { BankingDataType, BankingCreditCard } from '@/lib/types';
import { Lock } from 'lucide-react';

const Home: React.FC = () => {
  const card = getDefaultCard();
  const transactions = getTransactions();
  const [isLoading, setIsLoading] = useState(true);
  const [showInfo, setShowInfo] = useState(false);
  const [balance, setBalance] = useState(25552.92);
  const payButtonsRef = useRef<HTMLDivElement>(null);
  const [buttonBottomPosition, setButtonBottomPosition] = useState(0);
  const [isTransactionCollapsed, setIsTransactionCollapsed] = useState(true);
  const [showTransactions, setShowTransactions] = useState(false);
  const isManageClickRef = useRef(false);
  
  // Get banking data from context
  const { userData, isLoading: isBankingDataLoading } = useEnhancedBankingData();
  
  // React Spring animations
  const cardSpring = useSpring({
    opacity: isLoading ? 0 : 1,
    transform: isLoading ? 'translateY(20px)' : 'translateY(0px)',
    delay: 100,
    config: { tension: 280, friction: 25 }
  });
  
  const sectionSpring = useSpring({
    opacity: isLoading ? 0 : 1,
    transform: isLoading ? 'translateY(20px)' : 'translateY(0px)',
    delay: 200,
    config: { tension: 280, friction: 25 }
  });
  
  const actionsSpring = useSpring({
    opacity: isLoading ? 0 : 1,
    transform: isLoading ? 'translateY(20px)' : 'translateY(0px)',
    delay: 300,
    config: { tension: 280, friction: 25 }
  });

  // Get card info from banking data if available
  const cardInfo = userData?.creditCards?.[0];
  const rewardsBalance = cardInfo?.rewardsBalance || 0;

  // Loading simulation
  useEffect(() => {
    const timer = setTimeout(() => {
      setIsLoading(false);
    }, 800);
    return () => clearTimeout(timer);
  }, []);

  // Calculate button positions for transaction container
  useEffect(() => {
    if (!isLoading) {
      const calculatePositions = () => {
        if (payButtonsRef.current) {
          const rect = payButtonsRef.current.getBoundingClientRect();
          if (rect.bottom > 0) {
            setButtonBottomPosition(rect.bottom);
          }
        }
      };
      
      calculatePositions();
      const animationDelay = setTimeout(calculatePositions, 350);
      window.addEventListener('resize', calculatePositions);
      
      return () => {
        clearTimeout(animationDelay);
        window.removeEventListener('resize', calculatePositions);
      };
    }
  }, [isLoading, showInfo]); 

  // Handle transactions click
  const handleTransactionsClick = () => {
    setShowTransactions(true);
    setIsTransactionCollapsed(false);
  };

  // Handle manage button click
  const handleManageClick = () => {
    isManageClickRef.current = true;
    setIsTransactionCollapsed(!isTransactionCollapsed);
    
    if (showTransactions === false && !isTransactionCollapsed) {
      setShowTransactions(true);
    }
    
    setTimeout(() => {
      isManageClickRef.current = false;
    }, 100);
  };

  // Handle collapse state changes
  const handleCollapseChange = (collapsed: boolean) => {
    setIsTransactionCollapsed(collapsed);
    
    if (collapsed) {
      setTimeout(() => {
        setShowTransactions(false);
      }, 300);
    }
  };

  // Show loading spinner if loading
  if (isLoading || isBankingDataLoading) {
    return (
      <LoadingSpinner size="large" fullScreen={true} />
    );
  }

  // Get user name and transactions from data
  const userName = userData?.user?.name?.split(' ')[0] || 'Guest';
  const bankingTransactions = userData?.groupedTransactions || transactions;

  return (
    <div className="relative min-h-screen bg-app-black text-white">
      <Header userName={userName} />
      
      <div className="px-5  mx-auto max-w-md">
        {/* Card with React Spring animation */}
        <animated.div style={cardSpring} className="mb-4">
          <CreditCardComponent 
            showInfoState={[showInfo, setShowInfo]}
          />
        </animated.div>
        
        {/* Main sections grid */}
        <animated.div style={sectionSpring} className="grid grid-cols-2 gap-4 mb-4">
          {/* Transactions section */}
          <div 
            className="bg-[#212121] rounded-xl p-4 cursor-pointer hover:bg-neutral-700 transition-colors"
            onClick={handleTransactionsClick}
          >
            <h3 className="text-sm font-medium mb-1">Transactions</h3>
            <p className="text-xs text-gray-400 mb-2">Spent in April</p>
            <div className="flex space-x-1 mb-1">
              <div className="h-1 w-1/4 rounded-full bg-purple-500"></div>
              <div className="h-1 w-1/4 rounded-full bg-red-500"></div>
              <div className="h-1 w-1/4 rounded-full bg-blue-500"></div>
              <div className="h-1 w-1/4 rounded-full bg-yellow-500"></div>
            </div>
          </div>
          
          {/* Rewards section */}
          <div className="bg-[#212121] rounded-xl p-4">
            <h3 className="text-sm font-medium mb-1">Rewards</h3>
            <p className="text-xs text-gray-400 mb-2">Cash back earned</p>
            <p className="text-green-500 font-semibold">${rewardsBalance.toFixed(2)}</p>
          </div>
        </animated.div>
        
        {/* Action buttons */}
        <animated.div style={sectionSpring} className="grid grid-cols-2 gap-4 mb-4" ref={payButtonsRef}>
          <button 
            className="bg-[#212121] rounded-xl p-4 flex items-center justify-center hover:bg-neutral-700 transition-colors"
            onClick={handleTransactionsClick}
          >
            <div className="w-10 h-10 rounded-full bg-neutral-700 flex items-center justify-center mr-2">
              <Icon name="repeat" className="w-5 h-5 text-gray-200" />
            </div>
            <span className="text-sm text-gray-300">Pay</span>
          </button>
          
          <button className="bg-[#212121] rounded-xl p-4 flex items-center justify-center hover:bg-neutral-700 transition-colors">
            <div className="w-10 h-10 rounded-full bg-neutral-700 flex items-center justify-center mr-2">
              <Icon name="settings" className="w-5 h-5 text-gray-200" />
            </div>
            <span className="text-sm text-gray-300">Manage</span>
          </button>
        </animated.div>
        
        {/* Refer and Earn section */}
        <animated.div style={actionsSpring} className="bg-[#212121] rounded-xl p-4 mb-4 relative overflow-hidden">
          <div className="flex justify-between">
            <div>
              <h3 className="text-sm font-medium mb-1">Refer and Earn</h3>
              <p className="text-xs text-gray-400 max-w-[70%]">
                Share a referral link to your friend and get rewarded
              </p>
              <button className="mt-2 text-xs text-white bg-neutral-700 px-3 py-1 rounded-full hover:bg-neutral-600 transition-colors">
                Learn more
              </button>
            </div>
            <div className="absolute right-2 bottom-2">
              <img src="/images/marketing/refer-friend.png" alt="Refer a friend" className="h-24 object-contain" />
            </div>
          </div>
        </animated.div>
        
        {/* Additional action buttons */}
        <animated.div style={actionsSpring} className="grid grid-cols-2 gap-4 mb-4">
          <button className="bg-[#212121] rounded-xl p-4 flex items-center justify-center hover:bg-neutral-700 transition-colors">
            <div className="w-10 h-10 rounded-full bg-neutral-700 flex items-center justify-center mr-2">
              <Icon name="transfer" className="w-5 h-5 text-gray-200" />
            </div>
            <span className="text-sm text-gray-300">Balance Transfer</span>
          </button>
          
          <button className="bg-[#212121] rounded-xl p-4 flex items-center justify-center hover:bg-neutral-700 transition-colors">
            <div className="w-10 h-10 rounded-full bg-neutral-700 flex items-center justify-center mr-2">
              <Lock className="w-5 h-5 text-gray-200" />
            </div>
            <span className="text-sm text-gray-300">Lock/Unlock</span>
          </button>
        </animated.div>
        
        {/* Statements section */}
        <animated.div style={actionsSpring} className="bg-[#212121] rounded-xl p-4 mb-4">
          <div className="flex justify-between items-center">
            <h3 className="text-sm font-medium">Statements and Documents</h3>
            <button className="text-xs text-gray-400 hover:text-white transition-colors">
              View All
            </button>
          </div>
        </animated.div>
        
        {/* Transaction Container */}
        {showTransactions && buttonBottomPosition > 0 && (
          <TransactionContainer 
            transactionGroups={bankingTransactions}
            buttonBottomPosition={buttonBottomPosition}
            isCollapsed={isTransactionCollapsed}
            onCollapseChange={handleCollapseChange}
          />
        )}
      </div>
    </div>
  );
};

export default Home;




==== File: components\screens\Insights.tsx ====
import React from 'react';

const Insights: React.FC = () => {
  return (
    <div className="flex items-center justify-center h-screen bg-black text-white">
      <h1 className="text-2xl font-bold">Insights View</h1>
    </div>
  );
};

export default Insights;




==== File: components\screens\More.tsx ====
import React from 'react';

const More: React.FC = () => {
  return (
    <div className="flex items-center justify-center h-screen bg-black text-white">
      <h1 className="text-2xl font-bold">More View</h1>
    </div>
  );
};

export default More;




==== File: components\screens\NewOperation.tsx ====
import React from 'react';

const NewOperation: React.FC = () => {
  return (
    <div className="flex items-center justify-center h-screen bg-black text-white">
      <h1 className="text-2xl font-bold">New Operation View</h1>
    </div>
  );
};

export default NewOperation;




==== File: components\screens\Onboarding.tsx ====
'use client';

import React, { useState, useRef, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { animated, useSpring } from 'react-spring';
import { ChevronLeft, ChevronRight } from 'lucide-react';
import { theme } from '@/lib/styles/theme';
import AnimatedElement from '@/components/ui/common/AnimatedElement';

// Define the onboarding slides content
const slides = [
  {
    id: 'banking',
    title: 'Banking that puts you first',
    subtitle: 'Start building credit, say goodbye to monthly fees, and enjoy personalized service from a credit union that cares.',
    bgColor: '#7c2984', // Purple
    textColor: 'white',
    image: '/images/onboarding/shanice-m1st.png',
    imageAlt: 'Members 1st Banking App Screenshot'
  },
  {
    id: 'mobile',
    title: 'Banking in your pocket',
    subtitle: 'Manage your money on the go with our easy-to-use mobile app and digital wallet integration.',
    bgColor: '#039fd7', // Blue
    textColor: 'white',
    image: '/images/onboarding/mike-m1st.png',
    imageAlt: 'Mobile Banking Illustration'
  },
  {
    id: 'card',
    title: 'Personal Concierge',
    subtitle: ': Chat one-on-one with a local Member Concierge directly in the app, no chatbots—just real people who know you, your goals, and your community.',
    bgColor: '#5ea63a', // Green
    textColor: 'white',
    image: '/images/onboarding/woman-m1st.png',
    imageAlt: 'Members 1st Credit Card'
  },
  {
    id: 'fees',
    title: 'Say goodbye to fees',
    subtitle: 'No monthly fees, no minimum balances, and access to over 30,000 fee-free ATMs nationwide.',
    bgColor: '#f36919', // Orange
    textColor: 'white',
    image: '/images/onboarding/guy-bye.png',
    imageAlt: 'No Fees Illustration'
  },
  {
    id: 'credit',
    title: 'Build your credit score',
    subtitle: 'Start building credit with our Signature Rewards card and track your FICO score for free.',
    bgColor: '#213d70', // Blue Dark
    textColor: 'white',
    image: '/images/onboarding/credit-score.png',
    imageAlt: 'Credit Score Illustration'
  },
  {
    id: 'security',
    title: 'Bank securely anywhere',
    subtitle: 'Enjoy peace of mind with our advanced security features and 24/7 fraud monitoring.',
    bgColor: '#d90981', // Pink
    textColor: 'white',
    image: '/images/onboarding/shield-security.png',
    imageAlt: 'Security Features Illustration'
  }
];

const Onboarding: React.FC = () => {
  const [currentSlide, setCurrentSlide] = useState(0);
  const [slideDirection, setSlideDirection] = useState<'left' | 'right'>('right');
  const [initialLoad, setInitialLoad] = useState(true);
  const [autoAdvance, setAutoAdvance] = useState(true);
  const touchStartX = useRef(0);
  const autoAdvanceTimerRef = useRef<NodeJS.Timeout | null>(null);
  const router = useRouter();
  
  // Handle initial load
  useEffect(() => {
    // Set initialLoad to false after component mounts
    setInitialLoad(false);
    
    // Start auto-advance timer
    startAutoAdvanceTimer();
    
    // Cleanup timer on unmount
    return () => {
      if (autoAdvanceTimerRef.current) {
        clearTimeout(autoAdvanceTimerRef.current);
      }
    };
  }, []);
  
  // Start auto-advance timer
  const startAutoAdvanceTimer = () => {
    if (autoAdvanceTimerRef.current) {
      clearTimeout(autoAdvanceTimerRef.current);
    }
    
    if (autoAdvance) {
      autoAdvanceTimerRef.current = setTimeout(() => {
        if (currentSlide < slides.length - 1) {
          setSlideDirection('right');
          setCurrentSlide(prev => prev + 1);
        } else {
          // Loop back to the first slide
          setSlideDirection('right');
          setCurrentSlide(0);
        }
      }, 4000); // 4 seconds
    }
  };

  // Handle slide change
  const goToSlide = (index: number) => {
    setSlideDirection(index > currentSlide ? 'right' : 'left');
    setCurrentSlide(index);
    // Reset auto-advance timer when manually changing slides
    startAutoAdvanceTimer();
  };

  // Handle next slide
  const nextSlide = () => {
    if (currentSlide < slides.length - 1) {
      setSlideDirection('right');
      setCurrentSlide(prev => prev + 1);
    } else {
      // Loop back to the first slide
      setSlideDirection('right');
      setCurrentSlide(0);
    }
    // Reset auto-advance timer when manually changing slides
    startAutoAdvanceTimer();
  };

  // Handle previous slide
  const prevSlide = () => {
    if (currentSlide > 0) {
      setSlideDirection('left');
      setCurrentSlide(prev => prev - 1);
    } else {
      // Loop to the last slide
      setSlideDirection('left');
      setCurrentSlide(slides.length - 1);
    }
    // Reset auto-advance timer when manually changing slides
    startAutoAdvanceTimer();
  };

  // Handle touch events for swiping
  const handleTouchStart = (e: React.TouchEvent) => {
    touchStartX.current = e.touches[0].clientX;
    // Pause auto-advance during touch interaction
    if (autoAdvanceTimerRef.current) {
      clearTimeout(autoAdvanceTimerRef.current);
    }
  };

  const handleTouchEnd = (e: React.TouchEvent) => {
    const touchEndX = e.changedTouches[0].clientX;
    const diff = touchStartX.current - touchEndX;

    // Swipe right to left (next)
    if (diff > 50) {
      nextSlide();
    }
    // Swipe left to right (previous)
    else if (diff < -50) {
      prevSlide();
    } else {
      // If no significant swipe, restart the timer
      startAutoAdvanceTimer();
    }
  };

  // Handle sign up button click
  const handleSignUp = () => {
    router.push('/signup');
  };

  // Handle login button click
  const handleLogin = () => {
    router.push('/login');
  };

  // Animation for slide transition
  const slideAnimation = useSpring({
    opacity: 1,
    transform: 'translateX(0%)',
    from: { 
      opacity: initialLoad ? 0 : 0, 
      transform: initialLoad ? 'translateX(0%)' : `translateX(${slideDirection === 'right' ? '100%' : '-100%'})` 
    },
    reset: !initialLoad,
    config: { tension: 280, friction: 60 },
    onRest: () => {
      // Restart auto-advance timer after animation completes
      startAutoAdvanceTimer();
    }
  });

  // Animation for buttons
  const buttonAnimation = useSpring({
    from: { opacity: 0, transform: 'translateY(20px)' },
    to: { opacity: 1, transform: 'translateY(0px)' },
    delay: 300,
    config: { tension: 280, friction: 60 }
  });

  return (
    <div 
      className="flex flex-col h-screen w-full overflow-hidden"
      style={{ 
        backgroundColor: slides[currentSlide].bgColor,
        color: slides[currentSlide].textColor,
        transition: 'background-color 0.5s ease-in-out'
      }}
    >
      {/* Logo */}
      <div className="flex justify-center pt-12 pb-4">
        <img 
          src="/images/icons/logo.svg" 
          alt="Members 1st Credit Union" 
          className="h-10"
        />
      </div>

      {/* Main content area - Image only */}
      <div 
        className="relative flex-1"
        onTouchStart={handleTouchStart}
        onTouchEnd={handleTouchEnd}
      >
        <animated.div 
          style={slideAnimation}
          className="absolute inset-0 flex items-end justify-center"
        >
          {/* Image - positioned to touch the gray area */}
          <div className="w-full h-full flex items-end justify-center">
            <img 
              src={slides[currentSlide].image} 
              alt={slides[currentSlide].imageAlt}
              className="max-h-[80%] max-w-full object-contain"
            />
          </div>
        </animated.div>
      </div>

      {/* Dark gray bottom section - with text content moved here */}
      <div className="w-full bg-neutral-900 text-white min-h-[400px] flex flex-col">
        {/* Text content */}
        <div className="w-full px-6 pt-8 pb-4 text-center flex-1">
          <h1 className="text-3xl font-bold mb-4">{slides[currentSlide].title}</h1>
          <p className="text-md opacity-90 line-clamp-3">{slides[currentSlide].subtitle}</p>
        </div>
        {/* Pagination dots */}
        <div className="flex justify-center space-x-2 py-8">
          {slides.map((_, index) => (
            <button
              key={index}
              onClick={() => goToSlide(index)}
              className={`w-2 h-2 rounded-full transition-all ${
                index === currentSlide 
                  ? 'bg-white w-4' 
                  : 'bg-white/50'
              }`}
              aria-label={`Go to slide ${index + 1}`}
            />
          ))}
        </div>

        {/* Action buttons */}
        <animated.div 
          style={buttonAnimation}
          className="px-6 pb-4 space-y-4"
        >
          <button
            onClick={handleSignUp}
            className="w-full py-4 bg-gray-200 text-black font-medium rounded-lg hover:bg-gray-300 transition-colors"
          >
            Sign up
          </button>
          <button
            onClick={handleLogin}
            className="w-full py-4 bg-transparent text-white font-medium hover:bg-white/10 transition-colors"
          >
            Log in
          </button>
        </animated.div>
      </div>
    </div>
  );
};

export default Onboarding;




==== File: components\screens\Wallet.tsx ====
import React from 'react';

const Wallet: React.FC = () => {
  return (
    <div className="flex items-center justify-center h-screen bg-black text-white">
      <h1 className="text-2xl font-bold">Wallet View</h1>
    </div>
  );
};

export default Wallet;




==== File: components\screens\signup\AddressScreen.tsx ====
'use client';

import React, { useState } from 'react';

interface AddressScreenProps {
  formData: {
    streetAddress: string;
    aptSuite: string;
    zipCode: string;
    city: string;
    state: string;
  };
  onChange: (field: string, value: string) => void;
  onNext: () => void;
}

const AddressScreen: React.FC<AddressScreenProps> = ({ formData, onChange, onNext }) => {
  const [errors, setErrors] = useState({
    streetAddress: '',
    zipCode: '',
    city: '',
    state: ''
  });

  // US states for dropdown
  const states = [
    'AL', 'AK', 'AZ', 'AR', 'CA', 'CO', 'CT', 'DE', 'FL', 'GA',
    'HI', 'ID', 'IL', 'IN', 'IA', 'KS', 'KY', 'LA', 'ME', 'MD',
    'MA', 'MI', 'MN', 'MS', 'MO', 'MT', 'NE', 'NV', 'NH', 'NJ',
    'NM', 'NY', 'NC', 'ND', 'OH', 'OK', 'OR', 'PA', 'RI', 'SC',
    'SD', 'TN', 'TX', 'UT', 'VT', 'VA', 'WA', 'WV', 'WI', 'WY'
  ];

  // Validate form before proceeding
  const validateForm = () => {
    let isValid = true;
    const newErrors = {
      streetAddress: '',
      zipCode: '',
      city: '',
      state: ''
    };

    // Validate street address
    if (!formData.streetAddress.trim()) {
      newErrors.streetAddress = 'Street address is required';
      isValid = false;
    }

    // Validate ZIP code (5 digits)
    if (!formData.zipCode.trim()) {
      newErrors.zipCode = 'ZIP code is required';
      isValid = false;
    } else if (!/^\d{5}$/.test(formData.zipCode)) {
      newErrors.zipCode = 'Please enter a valid 5-digit ZIP code';
      isValid = false;
    }

    // Validate city
    if (!formData.city.trim()) {
      newErrors.city = 'City is required';
      isValid = false;
    }

    // Validate state
    if (!formData.state) {
      newErrors.state = 'State is required';
      isValid = false;
    }

    setErrors(newErrors);
    return isValid;
  };

  // Handle next button click
  const handleNext = (e: React.FormEvent) => {
    e.preventDefault();
    if (validateForm()) {
      onNext();
    }
  };

  return (
    <div className="max-w-md mx-auto">
      {/* Form title */}
      <h1 className="text-3xl font-bold mb-4">Your home address</h1>
      <p className="text-gray-600 mb-6">We need to verify your home address. This is also where we'll send your new card.</p>

      {/* Form */}
      <form onSubmit={handleNext}>
        <div className="space-y-4">
          {/* Street address */}
          <div>
            <input
              type="text"
              placeholder="Street address (no P.O. boxes)"
              value={formData.streetAddress}
              onChange={(e) => onChange('streetAddress', e.target.value)}
              className="w-full p-4 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-gray-800 text-gray-700"
            />
            {errors.streetAddress && <p className="text-red-500 text-sm mt-1">{errors.streetAddress}</p>}
          </div>

          {/* Apt/Suite (optional) */}
          <div>
            <input
              type="text"
              placeholder="Apt / Suite number (optional)"
              value={formData.aptSuite}
              onChange={(e) => onChange('aptSuite', e.target.value)}
              className="w-full p-4 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-gray-800 text-gray-700"
            />
          </div>

          {/* ZIP Code */}
          <div>
            <input
              type="text"
              placeholder="ZIP Code"
              value={formData.zipCode}
              onChange={(e) => onChange('zipCode', e.target.value.replace(/\D/g, '').substring(0, 5))}
              className="w-full p-4 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-gray-800 text-gray-700"
            />
            {errors.zipCode && <p className="text-red-500 text-sm mt-1">{errors.zipCode}</p>}
          </div>

          {/* City and State */}
          <div className="grid grid-cols-2 gap-4">
            <div>
              <input
                type="text"
                placeholder="City"
                value={formData.city}
                onChange={(e) => onChange('city', e.target.value)}
                className="w-full p-4 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-gray-800 text-gray-700"
              />
              {errors.city && <p className="text-red-500 text-sm mt-1">{errors.city}</p>}
            </div>
            <div>
              <select
                value={formData.state}
                onChange={(e) => onChange('state', e.target.value)}
                className="w-full p-4 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-gray-800 text-gray-700 appearance-none"
              >
                <option value="">State</option>
                {states.map(state => (
                  <option key={state} value={state}>{state}</option>
                ))}
              </select>
              {errors.state && <p className="text-red-500 text-sm mt-1">{errors.state}</p>}
            </div>
          </div>
        </div>

        {/* Next button */}
        <button
          type="submit"
          className="w-full p-4 bg-transparent border-2 border-black text-black uppercase font-medium rounded-lg mt-6 hover:bg-gray-50 transition-colors"
        >
          NEXT
        </button>
      </form>
    </div>
  );
};

export default AddressScreen;




==== File: components\screens\signup\BasicInfoScreen.tsx ====
'use client';

import React, { useState } from 'react';
import Image from 'next/image';

interface BasicInfoScreenProps {
  formData: {
    firstName: string;
    lastName: string;
    email: string;
  };
  onChange: (field: string, value: string) => void;
  onNext: () => void;
}

const BasicInfoScreen: React.FC<BasicInfoScreenProps> = ({ formData, onChange, onNext }) => {
  const [errors, setErrors] = useState({
    firstName: '',
    lastName: '',
    email: ''
  });

  // Validate form before proceeding
  const validateForm = () => {
    let isValid = true;
    const newErrors = {
      firstName: '',
      lastName: '',
      email: ''
    };

    // Validate first name
    if (!formData.firstName.trim()) {
      newErrors.firstName = 'First name is required';
      isValid = false;
    }

    // Validate last name
    if (!formData.lastName.trim()) {
      newErrors.lastName = 'Last name is required';
      isValid = false;
    }

    // Validate email
    if (!formData.email.trim()) {
      newErrors.email = 'Email is required';
      isValid = false;
    } else if (!/\S+@\S+\.\S+/.test(formData.email)) {
      newErrors.email = 'Please enter a valid email address';
      isValid = false;
    }

    setErrors(newErrors);
    return isValid;
  };

  // Handle next button click
  const handleNext = (e: React.FormEvent) => {
    e.preventDefault();
    if (validateForm()) {
      onNext();
    }
  };

  return (
    <div className="max-w-md mx-auto">
      {/* Image */}
      <div className="flex justify-center mb-6">
        <img 
          src="/images/signup/steps.png" 
          alt="Signup steps"
          className="max-h-[200px] max-w-full object-contain"
        />
      </div>

      {/* Form title */}
      <h1 className="text-gray-600 text-3xl font-bold mb-4">Let's get started</h1>
      <p className="text-gray-600 mb-6">Let's start with some basic information.</p>

      {/* Form */}
      <form onSubmit={handleNext}>
        <div className="space-y-4">
          {/* First name */}
          <div>
            <input
              type="text"
              placeholder="First name"
              value={formData.firstName}
              onChange={(e) => onChange('firstName', e.target.value)}
              className="w-full p-4 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-gray-800 text-gray-700"
            />
            {errors.firstName && <p className="text-red-500 text-sm mt-1">{errors.firstName}</p>}
          </div>

          {/* Last name */}
          <div>
            <input
              type="text"
              placeholder="Last name"
              value={formData.lastName}
              onChange={(e) => onChange('lastName', e.target.value)}
              className="w-full p-4 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-gray-800 text-gray-700"
            />
            {errors.lastName && <p className="text-red-500 text-sm mt-1">{errors.lastName}</p>}
          </div>

          {/* Legal name note */}
          <p className="text-gray-500 text-sm">Use your legal name. You can add a preferred name later.</p>

          {/* Email */}
          <div>
            <input
              type="email"
              placeholder="Email"
              value={formData.email}
              onChange={(e) => onChange('email', e.target.value)}
              className="w-full p-4 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-gray-800 text-gray-700"
            />
            {errors.email && <p className="text-red-500 text-sm mt-1">{errors.email}</p>}
          </div>
        </div>

        {/* Next button */}
        <button
          type="submit"
          className="w-full p-4 bg-transparent border-2 border-black text-black uppercase font-medium rounded-lg mt-6 hover:bg-gray-50 transition-colors"
        >
          NEXT
        </button>

        {/* Legal disclosures */}
        <p className="text-center text-gray-500 text-sm mt-4">
          See legal disclosures
        </p>
      </form>
    </div>
  );
};

export default BasicInfoScreen;




==== File: components\screens\signup\CreatePasswordScreen.tsx ====
'use client';

import React, { useState, useEffect } from 'react';

interface CreatePasswordScreenProps {
  formData: {
    password: string;
  };
  onChange: (field: string, value: string) => void;
  onNext: () => void;
}

const CreatePasswordScreen: React.FC<CreatePasswordScreenProps> = ({ formData, onChange, onNext }) => {
  const [error, setError] = useState('');
  const [passwordStrength, setPasswordStrength] = useState(0);
  const [showPassword, setShowPassword] = useState(false);

  // Update password strength when password changes
  useEffect(() => {
    calculatePasswordStrength(formData.password);
  }, [formData.password]);

  // Calculate password strength
  const calculatePasswordStrength = (password: string) => {
    if (!password) {
      setPasswordStrength(0);
      return;
    }

    let strength = 0;
    
    // Length check
    if (password.length >= 8) {
      strength += 1;
    }
    
    // Uppercase check
    if (/[A-Z]/.test(password)) {
      strength += 1;
    }
    
    // Lowercase check
    if (/[a-z]/.test(password)) {
      strength += 1;
    }
    
    // Number check
    if (/\d/.test(password)) {
      strength += 1;
    }
    
    // Special character check
    if (/[^A-Za-z0-9]/.test(password)) {
      strength += 1;
    }
    
    setPasswordStrength(strength);
  };

  // Validate password
  const validatePassword = () => {
    if (!formData.password) {
      setError('Password is required');
      return false;
    }

    if (formData.password.length < 8) {
      setError('Password must be at least 8 characters long');
      return false;
    }

    if (!/[A-Z]/.test(formData.password) || !/[a-z]/.test(formData.password) || !/\d/.test(formData.password)) {
      setError('Password must include uppercase, lowercase, and numbers');
      return false;
    }

    setError('');
    return true;
  };

  // Handle next button click
  const handleNext = (e: React.FormEvent) => {
    e.preventDefault();
    if (validatePassword()) {
      onNext();
    }
  };

  // Toggle password visibility
  const togglePasswordVisibility = () => {
    setShowPassword(!showPassword);
  };

  return (
    <div className="max-w-md mx-auto">
      {/* Form title */}
      <h1 className="text-3xl font-bold mb-4">Create password</h1>
      <p className="text-gray-600 mb-6">Strong passwords keep your account safer.</p>

      {/* Form */}
      <form onSubmit={handleNext}>
        <div className="space-y-4">
          {/* Password input */}
          <div className="relative">
            <input
              type={showPassword ? 'text' : 'password'}
              placeholder="Password"
              value={formData.password}
              onChange={(e) => onChange('password', e.target.value)}
              className="w-full p-4 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-gray-800 text-gray-700"
            />
            <button
              type="button"
              onClick={togglePasswordVisibility}
              className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400"
            >
              {showPassword ? 'Hide' : 'Show'}
            </button>
            {error && <p className="text-red-500 text-sm mt-1">{error}</p>}
          </div>

          {/* Password strength indicator */}
          <div className="w-full bg-gray-200 h-2 rounded-full overflow-hidden">
            <div 
              className={`h-full ${
                passwordStrength === 0 ? 'w-0' :
                passwordStrength === 1 ? 'w-1/5 bg-red-500' :
                passwordStrength === 2 ? 'w-2/5 bg-orange-500' :
                passwordStrength === 3 ? 'w-3/5 bg-yellow-500' :
                passwordStrength === 4 ? 'w-4/5 bg-blue-500' :
                'w-full bg-green-500'
              }`}
            ></div>
          </div>

          {/* Password requirements */}
          <p className="text-gray-500 text-sm">
            Use 8+ characters with uppercase, lowercase, and numbers
          </p>
        </div>

        {/* Next button */}
        <button
          type="submit"
          className="w-full p-4 bg-transparent border-2 border-black text-black uppercase font-medium rounded-lg mt-6 hover:bg-gray-50 transition-colors"
        >
          NEXT
        </button>
      </form>
    </div>
  );
};

export default CreatePasswordScreen;




==== File: components\screens\signup\DateOfBirthScreen.tsx ====
'use client';

import React, { useState } from 'react';

interface DateOfBirthScreenProps {
  formData: {
    dateOfBirth: string;
  };
  onChange: (field: string, value: string) => void;
  onNext: () => void;
}

const DateOfBirthScreen: React.FC<DateOfBirthScreenProps> = ({ formData, onChange, onNext }) => {
  const [error, setError] = useState('');

  // Validate date of birth
  const validateDateOfBirth = () => {
    if (!formData.dateOfBirth) {
      setError('Date of birth is required');
      return false;
    }

    // Check if the user is at least 18 years old
    const dob = new Date(formData.dateOfBirth);
    const today = new Date();
    const age = today.getFullYear() - dob.getFullYear();
    const monthDiff = today.getMonth() - dob.getMonth();
    
    if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < dob.getDate())) {
      // If birthday hasn't occurred yet this year, subtract one year
      const adjustedAge = age - 1;
      if (adjustedAge < 18) {
        setError('You must be 18 years or older to join Chime');
        return false;
      }
    } else if (age < 18) {
      setError('You must be 18 years or older to join Chime');
      return false;
    }

    setError('');
    return true;
  };

  // Handle next button click
  const handleNext = (e: React.FormEvent) => {
    e.preventDefault();
    if (validateDateOfBirth()) {
      onNext();
    }
  };

  return (
    <div className="max-w-md mx-auto">
      {/* Form title */}
      <h1 className="text-3xl font-bold mb-4">Your date of birth</h1>
      <p className="text-gray-600 mb-6">You must be 18 years old or older to join Chime.</p>

      {/* Form */}
      <form onSubmit={handleNext}>
        <div className="space-y-4">
          {/* Date of birth input */}
          <div>
            <input
              type="date"
              placeholder="Date of birth"
              value={formData.dateOfBirth}
              onChange={(e) => onChange('dateOfBirth', e.target.value)}
              className="w-full p-4 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-gray-800 text-gray-700"
            />
            {error && <p className="text-red-500 text-sm mt-1">{error}</p>}
          </div>
        </div>

        {/* Next button */}
        <button
          type="submit"
          className="w-full p-4 bg-transparent border-2 border-black text-black uppercase font-medium rounded-lg mt-6 hover:bg-gray-50 transition-colors"
        >
          NEXT
        </button>
      </form>
    </div>
  );
};

export default DateOfBirthScreen;




==== File: components\screens\signup\MobilePhoneScreen.tsx ====
'use client';

import React, { useState } from 'react';

interface MobilePhoneScreenProps {
  formData: {
    mobilePhone: string;
  };
  onChange: (field: string, value: string) => void;
  onNext: () => void;
}

const MobilePhoneScreen: React.FC<MobilePhoneScreenProps> = ({ formData, onChange, onNext }) => {
  const [error, setError] = useState('');

  // Validate phone number
  const validatePhoneNumber = () => {
    if (!formData.mobilePhone) {
      setError('Mobile phone number is required');
      return false;
    }

    // Simple US phone number validation (10 digits)
    const phoneRegex = /^\d{10}$/;
    if (!phoneRegex.test(formData.mobilePhone.replace(/\D/g, ''))) {
      setError('Please enter a valid 10-digit phone number');
      return false;
    }

    setError('');
    return true;
  };

  // Format phone number as user types
  const handlePhoneChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const input = e.target.value.replace(/\D/g, '');
    let formattedInput = input;

    // Format as (XXX) XXX-XXXX
    if (input.length > 0) {
      formattedInput = input.substring(0, 10);
    }

    onChange('mobilePhone', formattedInput);
  };

  // Handle next button click
  const handleNext = (e: React.FormEvent) => {
    e.preventDefault();
    if (validatePhoneNumber()) {
      onNext();
    }
  };

  return (
    <div className="max-w-md mx-auto">
      {/* Logo */}
      <div className="flex justify-center mb-6">
        <div className="text-green-500 text-3xl font-bold">chime</div>
      </div>

      {/* Form title */}
      <h1 className="text-3xl font-bold mb-4">Your mobile phone</h1>
      <p className="text-gray-600 mb-6">Your number is used to protect your account and keep in touch.</p>

      {/* Form */}
      <form onSubmit={handleNext}>
        <div className="space-y-4">
          {/* Phone number input */}
          <div>
            <input
              type="tel"
              placeholder="Mobile phone number (no VOIP)"
              value={formData.mobilePhone}
              onChange={handlePhoneChange}
              className="w-full p-4 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-gray-800 text-gray-700"
            />
            {error && <p className="text-red-500 text-sm mt-1">{error}</p>}
          </div>

          {/* Marketing consent text */}
          <p className="text-gray-500 text-sm mt-4">
            By selecting Next, you agree to receive periodic automated marketing text messages. Consent not required, cancel anytime. Message and data rates may apply. By selecting either option below, you agree to receive transactional updates and to the Telephone Use Agreement and Privacy Notice.
          </p>
        </div>

        {/* Next button */}
        <button
          type="submit"
          className="w-full p-4 bg-transparent border-2 border-black text-black uppercase font-medium rounded-lg mt-6 hover:bg-gray-50 transition-colors"
        >
          NEXT
        </button>

        {/* Transactional messages only option */}
        <button
          type="button"
          onClick={() => {
            if (validatePhoneNumber()) {
              onNext();
            }
          }}
          className="w-full p-4 bg-transparent border-2 border-black text-black uppercase font-medium rounded-lg mt-4 hover:bg-gray-50 transition-colors"
        >
          GET TRANSACTIONAL MESSAGES ONLY
        </button>
      </form>

      {/* Number pad (for display only - not functional) */}
      <div className="mt-8 bg-gray-900 rounded-t-lg p-4">
        <div className="grid grid-cols-3 gap-2">
          {[1, 2, 3, 4, 5, 6, 7, 8, 9, '*', 0, '#'].map((num, index) => (
            <div 
              key={index} 
              className="bg-gray-800 rounded-full p-4 text-center text-white text-xl font-medium"
            >
              {num}
              {num === 2 && <div className="text-xs text-gray-400">ABC</div>}
              {num === 3 && <div className="text-xs text-gray-400">DEF</div>}
              {num === 4 && <div className="text-xs text-gray-400">GHI</div>}
              {num === 5 && <div className="text-xs text-gray-400">JKL</div>}
              {num === 6 && <div className="text-xs text-gray-400">MNO</div>}
              {num === 7 && <div className="text-xs text-gray-400">PQRS</div>}
              {num === 8 && <div className="text-xs text-gray-400">TUV</div>}
              {num === 9 && <div className="text-xs text-gray-400">WXYZ</div>}
            </div>
          ))}
        </div>
      </div>
    </div>
  );
};

export default MobilePhoneScreen;




==== File: components\screens\signup\SignupFlow.tsx ====
'use client';

import React, { useState } from 'react';
import { useRouter } from 'next/navigation';
import { X } from 'lucide-react';
import BasicInfoScreen from './BasicInfoScreen';
import DateOfBirthScreen from './DateOfBirthScreen';
import MobilePhoneScreen from './MobilePhoneScreen';
import AddressScreen from './AddressScreen';
import CreatePasswordScreen from './CreatePasswordScreen';

// Define the steps in the signup flow
enum SignupStep {
  BASIC_INFO = 0,
  DATE_OF_BIRTH = 1,
  MOBILE_PHONE = 2,
  ADDRESS = 3,
  CREATE_PASSWORD = 4
}

// Define the form data structure
interface SignupFormData {
  firstName: string;
  lastName: string;
  email: string;
  dateOfBirth: string;
  mobilePhone: string;
  streetAddress: string;
  aptSuite: string;
  zipCode: string;
  city: string;
  state: string;
  password: string;
}

const SignupFlow: React.FC = () => {
  const router = useRouter();
  const [currentStep, setCurrentStep] = useState<SignupStep>(SignupStep.BASIC_INFO);
  const [formData, setFormData] = useState<SignupFormData>({
    firstName: '',
    lastName: '',
    email: '',
    dateOfBirth: '',
    mobilePhone: '',
    streetAddress: '',
    aptSuite: '',
    zipCode: '',
    city: '',
    state: '',
    password: ''
  });

  // Handle form data changes
  const handleChange = (field: string, value: string) => {
    setFormData(prev => ({
      ...prev,
      [field]: value
    }));
  };

  // Handle next step
  const handleNext = () => {
    if (currentStep < SignupStep.CREATE_PASSWORD) {
      setCurrentStep(prev => prev + 1);
    } else {
      // Final step - complete signup
      completeSignup();
    }
  };

  // Handle back button
  const handleBack = () => {
    if (currentStep > SignupStep.BASIC_INFO) {
      setCurrentStep(prev => prev - 1);
    } else {
      // First step - go back to onboarding
      router.push('/onboarding');
    }
  };

  // Handle close button
  const handleClose = () => {
    router.push('/');
  };

  // Complete signup and redirect to admin page
  const completeSignup = () => {
    console.log('Signup completed with data:', formData);
    
    // In a real app, this would call an API to create the account
    // For now, we'll just redirect to the admin page
    localStorage.removeItem('selectedUserId');
    router.push('/');
  };

  // Render the current step
  const renderStep = () => {
    switch (currentStep) {
      case SignupStep.BASIC_INFO:
        return (
          <BasicInfoScreen 
            formData={formData} 
            onChange={handleChange} 
            onNext={handleNext} 
          />
        );
      case SignupStep.DATE_OF_BIRTH:
        return (
          <DateOfBirthScreen 
            formData={formData} 
            onChange={handleChange} 
            onNext={handleNext} 
          />
        );
      case SignupStep.MOBILE_PHONE:
        return (
          <MobilePhoneScreen 
            formData={formData} 
            onChange={handleChange} 
            onNext={handleNext} 
          />
        );
      case SignupStep.ADDRESS:
        return (
          <AddressScreen 
            formData={formData} 
            onChange={handleChange} 
            onNext={handleNext} 
          />
        );
      case SignupStep.CREATE_PASSWORD:
        return (
          <CreatePasswordScreen 
            formData={formData} 
            onChange={handleChange} 
            onNext={handleNext} 
          />
        );
      default:
        return null;
    }
  };

  return (
    <div className="min-h-screen bg-white">
      {/* Header with close button */}
      <div className="h-16 bg-black flex items-center px-4">
        <button 
          onClick={handleClose}
          className="p-2 text-white"
          aria-label="Close"
        >
          <X size={24} />
        </button>
      </div>

      {/* Current step content */}
      <div className="px-4">
        {renderStep()}
      </div>
    </div>
  );
};

export default SignupFlow;




==== File: components\ui\card\CardSelector.tsx ====
'use client';

import React, { useState } from 'react';
import { CardType } from '@/lib/types';
import CreditCard from './CreditCard';

interface CardSelectorProps {
  cards: CardType[];
  activeCardId: string;
  onCardChange: (cardId: string) => void;
}

const CardSelector: React.FC<CardSelectorProps> = ({ cards, activeCardId, onCardChange }) => {
  const [currentIndex, setCurrentIndex] = useState(
    cards.findIndex(card => card.id === activeCardId) || 0
  );

  const handleCardChange = (index: number) => {
    setCurrentIndex(index);
    onCardChange(cards[index].id);
  };

  return (
    <div className="w-full">
      <div className="relative overflow-hidden">
        {/* Current card */}
        <div className="transition-all duration-300 ease-in-out">
          {/* Note: CreditCard component expects showInfoState prop, not card prop */}
          <CreditCard />
        </div>
        
        {/* Card indicators */}
        {cards.length > 1 && (
          <div className="flex justify-center mt-4 space-x-2">
            {cards.map((card, index) => (
              <button
                key={card.id}
                className={`w-2 h-2 rounded-full transition-all ${
                  index === currentIndex ? 'bg-white scale-125' : 'bg-gray-600'
                }`}
                onClick={() => handleCardChange(index)}
                aria-label={`Select card ${index + 1}`}
              />
            ))}
          </div>
        )}
      </div>
    </div>
  );
};

export default CardSelector;




==== File: components\ui\card\CreditCard.tsx ====
// components/ui/card/CreditCard.tsx
'use client';

import React, { useEffect, useRef, useState } from 'react';
import { animated, useSpring, config } from 'react-spring';
import { Info } from 'lucide-react';
import { CardType } from '@/lib/types';
import { useEnhancedBankingData } from '@/components/preloaders/EnhancedBankingDataProvider';
import { BankingDataType, BankingCreditCard } from '@/lib/types';

interface CreditCardProps {
  showInfoState?: [boolean, React.Dispatch<React.SetStateAction<boolean>>];
}

const CreditCard: React.FC<CreditCardProps> = ({ 
  showInfoState
}) => {
  // Use local or parent-controlled state for showInfo
  const [showInfo, setShowInfo] = showInfoState || React.useState(false);
  const cardRef = useRef<HTMLDivElement>(null);
  const contentRef = useRef<HTMLDivElement>(null);
  const [contentHeight, setContentHeight] = useState(0);
  
  // Get banking data if available
  const { userData } = useEnhancedBankingData();
  
  // Get card info from banking data
  const cardInfo = userData?.creditCards?.[0];
  
  // Measure the content height when it changes
  useEffect(() => {
    if (contentRef.current) {
      setContentHeight(contentRef.current.scrollHeight);
    }
  }, [userData, showInfo]);
  
  // Create spring animation for the info panel
  const infoSpring = useSpring({
    height: showInfo ? contentHeight : 0,
    opacity: showInfo ? 1 : 0,
    transform: showInfo ? 'translateY(0px)' : 'translateY(-8px)',
    marginTop: showInfo ? 8 : 0,
    config: {
      mass: 1,
      tension: 280,
      friction: 26,
      clamp: false,
      velocity: 0.01
    },
    immediate: false
  });

  // Get card details from banking data with fallbacks
  const balance = cardInfo?.currentBalance || 0;
  const availableCredit = cardInfo?.availableCredit || 0;
  const minimumPayment = cardInfo?.minimumPayment || 0;
  const dueDate = cardInfo?.dueDate ? new Date(cardInfo.dueDate).toLocaleDateString('en-US', {
    month: 'numeric',
    day: 'numeric',
    year: 'numeric'
  }) : '';
  const cardNumber = cardInfo?.cardNumber || '';
  const cardColor = cardInfo?.color || '#7b2528';

  return (
    <div className="w-full" ref={cardRef}>
      {/* Credit Card with balance directly inside */}
      <div
        className="relative w-full rounded-xl overflow-hidden shadow-lg transform transition-all duration-300 hover:scale-[1.01]"
        style={{
          backgroundColor: cardColor,
        }}
      >
        {/* Card content */}
        <div className="p-5 flex flex-col">
          {/* Card top section with balance and info button */}
          <div className="flex justify-between items-start">
            <div className="text-white">
              <p className="text-gray-300 text-sm">Your Balance</p>
              <h1 className="text-white text-4xl font-semibold">${balance.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}</h1>
            </div>
            <button
              onClick={() => setShowInfo(!showInfo)}
              className="bg-white/30 px-3 py-1 rounded-full text-white text-xs flex items-center transition-all hover:bg-white/40"
            >
              <Info className="w-4 h-4 mr-1" />
              Show info
            </button>
          </div>
          
          {/* Additional card info - Animated with React Spring */}
          <animated.div 
            style={infoSpring}
            className="text-white overflow-hidden"
          >
            <div ref={contentRef}>
              <div className="grid grid-cols-2 gap-y-2">
                <div className="text-gray-300 text-sm">Available Credit:</div>
                <div className="text-right font-medium text-sm">${availableCredit.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}</div>
                
                <div className="text-gray-300 text-sm">Minimum Payment:</div>
                <div className="text-right font-medium text-sm">${minimumPayment.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}</div>
                
                <div className="text-gray-300 text-sm">Due Date:</div>
                <div className="text-right font-medium text-sm">{dueDate}</div>
                
                <div className="text-gray-300 text-sm">AutoPay:</div>
                <div className="text-right font-medium text-sm">
                  ON | <a href="#" className="text-neutral-400 hover:underline">Settings</a>
                </div>
              </div>
            </div>
          </animated.div>
          
          {/* VISA bar at bottom */}
          <div className="relative mt-4 -mx-5 -mb-5 bg-black/40 py-2 px-5 flex justify-between items-center">
            <div className="text-white text-xl font-bold">VISA</div>
            <div className="text-white text-base">{cardNumber}</div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default CreditCard;




==== File: components\ui\charts\SpendingChart.tsx ====
// components/ui/charts/SpendingChart.tsx
'use client';

import React from 'react';
import { PieChart, Pie, Cell, ResponsiveContainer } from 'recharts';
import { animated, useSpring } from 'react-spring';

interface SpendingData {
  name: string;
  value: number;
  color: string;
}

interface PeriodOption {
  id: string;
  name: string;
  label: string;
}

interface SpendingChartProps {
  selectedPeriod: string;
  periodOptions: PeriodOption[];
}

const SpendingChart: React.FC<SpendingChartProps> = ({ selectedPeriod, periodOptions }) => {
  // Period-specific data with more accurate colors matching the inspiration image
  const periodData = {
    day: [
      { name: 'Shopping', value: 120, color: '#8b5cf6' }, // Purple
      { name: 'Food', value: 84, color: '#f87171' }, // Red
      { name: 'Entertainment', value: 65, color: '#60a5fa' }, // Blue
      { name: 'Transport', value: 48, color: '#fbbf24' }, // Yellow
      { name: 'Other', value: 30, color: '#4ade80' }, // Green
    ],
    week: [
      { name: 'Shopping', value: 280, color: '#8b5cf6' },
      { name: 'Food', value: 175, color: '#f87171' },
      { name: 'Entertainment', value: 120, color: '#60a5fa' },
      { name: 'Transport', value: 95, color: '#fbbf24' },
      { name: 'Other', value: 60, color: '#4ade80' },
    ],
    month: [
      { name: 'Shopping', value: 450, color: '#8b5cf6' },
      { name: 'Food', value: 300, color: '#f87171' },
      { name: 'Entertainment', value: 250, color: '#60a5fa' },
      { name: 'Transport', value: 244, color: '#fbbf24' },
      { name: 'Other', value: 100, color: '#4ade80' },
    ],
    year: [
      { name: 'Shopping', value: 4820, color: '#8b5cf6' },
      { name: 'Food', value: 3600, color: '#f87171' },
      { name: 'Entertainment', value: 2950, color: '#60a5fa' },
      { name: 'Transport', value: 3100, color: '#fbbf24' },
      { name: 'Other', value: 1200, color: '#4ade80' },
    ],
  };
  
  // Get data for the current period
  const data = periodData[selectedPeriod as keyof typeof periodData];
  
  // Calculate total spent
  const totalSpent = data.reduce((sum, item) => sum + item.value, 0);
  
  // Format as currency
  const formatCurrency = (value: number) => {
    return `$${value.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
  };
  
  // Get the label for the current period
  const getPeriodLabel = () => {
    const option = periodOptions.find(p => p.id === selectedPeriod);
    return option ? option.label : 'this month';
  };

  // Add animation for chart
  const chartAnimation = useSpring({
    from: { opacity: 0, transform: 'scale(0.9)' },
    to: { opacity: 1, transform: 'scale(1)' },
    config: { tension: 280, friction: 25 },
  });

  return (
    <animated.div className="w-full" style={chartAnimation}>
      {/* Chart container - reduced thickness to match inspiration better */}
      <div className="relative" style={{ height: '260px' }}>
        <ResponsiveContainer width="100%" height="100%">
          <PieChart>
            <Pie
              data={data}
              cx="50%"
              cy="50%"
              innerRadius={95}
              outerRadius={115}
              startAngle={90}
              endAngle={-270}
              dataKey="value"
              strokeWidth={0}
              paddingAngle={5} // Increased spacing between segments
            >
              {data.map((entry, index) => (
                // Using type assertion to bypass TypeScript's type checking
                <Cell 
                  key={`cell-${index}`} 
                  fill={entry.color} 
                  strokeWidth={0}
                  {...({ cornerRadius: 6 } as any)} // Type assertion to bypass TypeScript check
                />
              ))}
            </Pie>
          </PieChart>
        </ResponsiveContainer>
        
        {/* Centered text overlay - adjusted font size */}
        <div className="absolute flex flex-col items-center justify-center inset-0 pointer-events-none">
          <p className="text-gray-400 mb-1" style={{ fontSize: '15px' }}>Spent {getPeriodLabel()}</p>
          <p className="text-white font-semibold" style={{ fontSize: '36px' }}>{formatCurrency(totalSpent)}</p>
        </div>
      </div>
    </animated.div>
  );
};

export default SpendingChart;



==== File: components\ui\common\AnimatedElement.tsx ====
'use client';

import React, { ReactNode } from 'react';
import { animated, useSpring, SpringConfig } from 'react-spring';

// Define animation presets
export type AnimationPreset = 
  | 'fadeIn' 
  | 'fadeOut' 
  | 'slideUp' 
  | 'slideDown' 
  | 'slideLeft' 
  | 'slideRight' 
  | 'scale' 
  | 'bounce';

// Define animation configuration
export type AnimationConfig = {
  delay?: number;
  duration?: number;
  config?: SpringConfig;
  immediate?: boolean;
  onRest?: () => void;
};

// Define component props
export interface AnimatedElementProps {
  children: ReactNode;
  animation?: AnimationPreset;
  customAnimation?: Record<string, any>; // For custom animations
  config?: AnimationConfig;
  className?: string;
  style?: React.CSSProperties;
  as?: keyof JSX.IntrinsicElements | React.ComponentType<any>;
}

/**
 * AnimatedElement - A reusable component for animations
 * 
 * This component provides consistent animations throughout the app
 * by encapsulating React Spring configurations into reusable presets.
 */
export const AnimatedElement: React.FC<AnimatedElementProps> = ({ 
  children, 
  animation = 'fadeIn',
  customAnimation,
  config = {},
  className = '',
  style = {},
  as: Component = 'div'
}) => {
  // Default spring configuration
  const defaultConfig: SpringConfig = { 
    mass: 1, 
    tension: 280, 
    friction: 25 
  };

  // Animation presets
  const animations = {
    fadeIn: { 
      from: { opacity: 0 }, 
      to: { opacity: 1 } 
    },
    fadeOut: { 
      from: { opacity: 1 }, 
      to: { opacity: 0 } 
    },
    slideUp: { 
      from: { opacity: 0, transform: 'translateY(20px)' }, 
      to: { opacity: 1, transform: 'translateY(0px)' } 
    },
    slideDown: { 
      from: { opacity: 0, transform: 'translateY(-20px)' }, 
      to: { opacity: 1, transform: 'translateY(0px)' } 
    },
    slideLeft: { 
      from: { opacity: 0, transform: 'translateX(20px)' }, 
      to: { opacity: 1, transform: 'translateX(0px)' } 
    },
    slideRight: { 
      from: { opacity: 0, transform: 'translateX(-20px)' }, 
      to: { opacity: 1, transform: 'translateX(0px)' } 
    },
    scale: { 
      from: { opacity: 0, transform: 'scale(0.9)' }, 
      to: { opacity: 1, transform: 'scale(1)' } 
    },
    bounce: { 
      from: { transform: 'scale(0.8)', opacity: 0 },
      to: { transform: 'scale(1)', opacity: 1 },
      config: { 
        tension: 300,
        friction: 10,
        mass: 1
      }
    }
  };

  // Get the animation preset or use custom animation
  const animationProps = customAnimation || animations[animation];
  
  // Create spring animation
  const spring = useSpring({
    ...animationProps,
    delay: config.delay || 0,
    config: config.config || defaultConfig,
    immediate: config.immediate || false,
    onRest: config.onRest
  });

  // Render the animated component
  return (
    <animated.div 
      style={{ 
        ...spring,
        ...style
      }}
      className={className}
    >
      {children}
    </animated.div>
  );
};

/**
 * Example usage:
 * 
 * <AnimatedElement animation="slideUp" config={{ delay: 200 }}>
 *   <p>This content will slide up with a 200ms delay</p>
 * </AnimatedElement>
 * 
 * <AnimatedElement 
 *   customAnimation={{ 
 *     from: { opacity: 0, transform: 'rotate(45deg)' }, 
 *     to: { opacity: 1, transform: 'rotate(0deg)' } 
 *   }}
 * >
 *   <p>This content will have a custom animation</p>
 * </AnimatedElement>
 */

export default AnimatedElement;




==== File: components\ui\common\Card.tsx ====
'use client';

import React, { ReactNode } from 'react';
import { animated, useSpring } from 'react-spring';

export interface CardProps {
  children: ReactNode;
  onClick?: () => void;
  className?: string;
  variant?: 'default' | 'interactive' | 'elevated';
  padding?: 'none' | 'small' | 'medium' | 'large';
  animate?: boolean;
}

/**
 * Card - A reusable card component
 * 
 * This component provides a consistent card UI throughout the app
 * with various styling options and interactive states.
 */
export const Card: React.FC<CardProps> = ({ 
  children, 
  onClick,
  className = '',
  variant = 'default',
  padding = 'medium',
  animate = false
}) => {
  // Define padding classes based on the padding prop
  const paddingClasses = {
    none: '',
    small: 'p-2',
    medium: 'p-4',
    large: 'p-6'
  };
  
  // Define variant classes
  const variantClasses = {
    default: 'bg-[#212121]',
    interactive: 'bg-[#212121] cursor-pointer hover:bg-neutral-700 transition-colors',
    elevated: 'bg-[#212121] shadow-lg'
  };
  
  // Determine if the card is interactive
  const isInteractive = variant === 'interactive' || !!onClick;
  
  // Animation for hover effect
  const [spring, api] = useSpring(() => ({
    transform: 'scale(1)',
    config: { mass: 1, tension: 350, friction: 25 }
  }));
  
  // Handle hover events for animation
  const handleMouseEnter = () => {
    if (animate && isInteractive) {
      api.start({ transform: 'scale(1.02)' });
    }
  };
  
  const handleMouseLeave = () => {
    if (animate && isInteractive) {
      api.start({ transform: 'scale(1)' });
    }
  };

  return (
    <animated.div 
      className={`
        rounded-xl 
        ${paddingClasses[padding]} 
        ${isInteractive ? variantClasses.interactive : variantClasses[variant]} 
        ${className}
      `}
      onClick={onClick}
      onMouseEnter={handleMouseEnter}
      onMouseLeave={handleMouseLeave}
      style={animate ? spring : undefined}
    >
      {children}
    </animated.div>
  );
};

export default Card;




==== File: components\ui\common\IconButton.tsx ====
'use client';

import React from 'react';
import { getIconByName } from '@/lib/config/iconMappings';

export interface IconButtonProps {
  icon: string;
  label?: string;
  onClick?: () => void;
  className?: string;
  iconClassName?: string;
  labelClassName?: string;
  variant?: 'primary' | 'secondary' | 'ghost';
  size?: 'small' | 'medium' | 'large';
  disabled?: boolean;
}

/**
 * IconButton - A reusable button with an icon
 * 
 * This component provides a consistent button UI with icons throughout the app
 * with various styling options and interactive states.
 */
export const IconButton: React.FC<IconButtonProps> = ({ 
  icon,
  label,
  onClick,
  className = '',
  iconClassName = '',
  labelClassName = '',
  variant = 'primary',
  size = 'medium',
  disabled = false
}) => {
  // Get the icon component
  const IconComponent = getIconByName(icon);
  
  // Define size classes
  const sizeClasses = {
    small: {
      button: 'p-2',
      icon: 'w-4 h-4',
      iconContainer: 'w-8 h-8',
      text: 'text-xs'
    },
    medium: {
      button: 'p-4',
      icon: 'w-5 h-5',
      iconContainer: 'w-10 h-10',
      text: 'text-sm'
    },
    large: {
      button: 'p-5',
      icon: 'w-6 h-6',
      iconContainer: 'w-12 h-12',
      text: 'text-base'
    }
  };
  
  // Define variant classes
  const variantClasses = {
    primary: {
      button: 'bg-[#212121] hover:bg-neutral-700',
      iconContainer: 'bg-neutral-700',
      icon: 'text-gray-200',
      label: 'text-gray-300'
    },
    secondary: {
      button: 'bg-neutral-800 hover:bg-neutral-700',
      iconContainer: 'bg-neutral-700',
      icon: 'text-gray-300',
      label: 'text-gray-400'
    },
    ghost: {
      button: 'bg-transparent hover:bg-neutral-800',
      iconContainer: 'bg-neutral-800',
      icon: 'text-gray-300',
      label: 'text-gray-400'
    }
  };
  
  // Disabled state classes
  const disabledClasses = disabled 
    ? 'opacity-50 cursor-not-allowed' 
    : 'transition-colors cursor-pointer';

  return (
    <button 
      className={`
        ${sizeClasses[size].button}
        ${variantClasses[variant].button}
        ${disabledClasses}
        rounded-xl flex items-center justify-center
        ${className}
      `}
      onClick={disabled ? undefined : onClick}
      disabled={disabled}
    >
      <div className={`
        ${sizeClasses[size].iconContainer}
        ${variantClasses[variant].iconContainer}
        rounded-full flex items-center justify-center
        ${label ? 'mr-2' : ''}
      `}>
        <IconComponent className={`
          ${sizeClasses[size].icon}
          ${variantClasses[variant].icon}
          ${iconClassName}
        `} />
      </div>
      
      {label && (
        <span className={`
          ${sizeClasses[size].text}
          ${variantClasses[variant].label}
          ${labelClassName}
        `}>
          {label}
        </span>
      )}
    </button>
  );
};

export default IconButton;




==== File: components\ui\common\LoadingSpinner.tsx ====
import React from 'react';

interface LoadingSpinnerProps {
  size?: 'small' | 'medium' | 'large';
  color?: string;
  fullScreen?: boolean;
}

const LoadingSpinner: React.FC<LoadingSpinnerProps> = ({ 
  size = 'medium', 
  color = 'text-white',
  fullScreen = false
}) => {
  const sizeClasses = {
    small: 'w-4 h-4',
    medium: 'w-8 h-8',
    large: 'w-12 h-12',
  };

  // If fullScreen is true, make the spinner cover the entire screen with a high z-index
  if (fullScreen) {
    return (
      <div className="fixed inset-0 flex justify-center items-center bg-black bg-opacity-50 z-[200]">
        <div className={`${sizeClasses[size]} ${color} animate-spin`}>
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
            <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
            <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
          </svg>
        </div>
      </div>
    );
  }

  return (
    <div className="flex justify-center items-center z-[200]">
      <div className={`${sizeClasses[size]} ${color} animate-spin`}>
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
          <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
          <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
        </svg>
      </div>
    </div>
  );
};

export default LoadingSpinner;




==== File: components\ui\common\PWAInstallPrompt.tsx ====
'use client';

import React, { useState, useEffect } from 'react';
import { X, Download, Share } from 'lucide-react';

interface BeforeInstallPromptEvent extends Event {
  prompt: () => Promise<void>;
  userChoice: Promise<{ outcome: 'accepted' | 'dismissed'; platform: string }>;
}

const PWAInstallPrompt: React.FC = () => {
  const [installPrompt, setInstallPrompt] = useState<BeforeInstallPromptEvent | null>(null);
  const [showPrompt, setShowPrompt] = useState(false);
  const [isIOS, setIsIOS] = useState(false);
  
  useEffect(() => {
    // Clear any existing PWA prompt flags to ensure the prompt shows
    localStorage.removeItem('pwaPromptSeen');
    
    const iosCheck = /iPad|iPhone|iPod/.test(navigator.userAgent) && !(window as any).MSStream;
    setIsIOS(iosCheck);
    
    const isStandalone = 
      window.matchMedia('(display-mode: standalone)').matches || 
      (window.navigator as any).standalone || 
      document.referrer.includes('android-app://');
    
    if (isStandalone) {
      setShowPrompt(false);
      return;
    }
    
    // Store the event for later use
    let deferredPrompt: BeforeInstallPromptEvent | null = null;
    
    const handler = (e: Event) => {
      // Prevent the default browser install prompt
      e.preventDefault();
      console.log('beforeinstallprompt event captured successfully');
      
      // Store the event for later use
      deferredPrompt = e as BeforeInstallPromptEvent;
      setInstallPrompt(deferredPrompt);
      
      // Always show the install prompt when the event is fired
      setShowPrompt(true);
    };

    // Add event listeners
    window.addEventListener('beforeinstallprompt', handler);
    
    window.addEventListener('appinstalled', () => {
      console.log('PWA was installed successfully');
      setShowPrompt(false);
    });
    
    // For iOS devices, always show the install instructions
    if (iosCheck && !isStandalone) {
      console.log('iOS device detected, showing install instructions');
      setShowPrompt(true);
    }
    
    // Debug logging for PWA eligibility
    console.log('PWA install prompt component initialized');
    console.log('Is standalone mode:', isStandalone);
    console.log('Is iOS device:', iosCheck);
    
    if ('getInstalledRelatedApps' in navigator) {
      console.log('getInstalledRelatedApps is available');
      // @ts-ignore - TypeScript doesn't know about this API yet
      navigator.getInstalledRelatedApps().then((apps: any[]) => {
        console.log('Installed related apps:', apps);
      }).catch((err: any) => {
        console.error('Error checking installed apps:', err);
      });
    }

    return () => {
      window.removeEventListener('beforeinstallprompt', handler);
    };
  }, []);

  const handleInstall = async () => {
    console.log('Install button clicked, installPrompt available:', !!installPrompt);
    
    if (installPrompt) {
      try {
        // Show the install prompt
        console.log('Calling prompt() method...');
        await installPrompt.prompt();
        
        // Wait for the user to respond to the prompt
        console.log('Waiting for user choice...');
        const choiceResult = await installPrompt.userChoice;
        
        console.log('User choice was:', choiceResult.outcome);
        
        if (choiceResult.outcome === 'accepted') {
          console.log('User accepted the install prompt');
          setShowPrompt(false);
        } else {
          console.log('User dismissed the install prompt');
          // Don't permanently dismiss, allow the prompt to show again later
          setTimeout(() => setShowPrompt(true), 24 * 60 * 60 * 1000); // Show again after 24 hours
        }
        
        // Clear the saved prompt since it can't be used twice
        setInstallPrompt(null);
      } catch (error) {
        console.error('Install error:', error);
      }
    } else if (isIOS) {
      // For iOS, show instructions for adding to home screen
      alert('To install this app on your iPhone: tap the Share button, then "Add to Home Screen"');
      setShowPrompt(false);
    } else {
      console.log('No install prompt available');
      // If no install prompt is available, just hide the banner temporarily
      setShowPrompt(false);
      // Try again after a short delay
      setTimeout(() => setShowPrompt(true), 60 * 1000); // Show again after 1 minute
    }
  };

  const handleDismiss = () => {
    setShowPrompt(false);
    // Don't permanently dismiss, allow the prompt to show again later
    setTimeout(() => setShowPrompt(true), 3 * 24 * 60 * 60 * 1000); // Show again after 3 days
  };

  if (!showPrompt) return null;

  return (
    <div className="fixed top-0 left-0 right-0 bg-white text-gray-800 p-3 shadow-md z-50 border-b border-gray-200">
      <div className="max-w-6xl mx-auto flex items-center justify-between">
        <div className="flex items-center">
          <img 
            src="/icons/icon-192x192.png" 
            alt="App Logo"
            className="w-8 h-8 mr-3"
          />
          <div>
            <h3 className="font-semibold">Install Banking App</h3>
            <p className="text-sm opacity-90">
              {isIOS ? 'Add to home screen for full app experience' : 'Install for better experience'}
            </p>
          </div>
        </div>
        <div className="flex items-center space-x-2">
          {!isIOS && (
            <button
              onClick={handleInstall}
              className="bg-neutral-800 text-white px-3 py-1 rounded text-sm font-medium hover:bg-blue-700 transition-colors"
            >
              Install
            </button>
          )}
          {isIOS && (
            <button
              onClick={handleInstall}
              className="bg-neutral-800 text-white px-3 py-1 rounded text-sm font-medium hover:bg-blue-700 transition-colors flex items-center"
            >
              <Share size={16} className="mr-1" /> Add to Home
            </button>
          )}
          <button
            onClick={handleDismiss}
            className="text-gray-800 hover:text-gray-600"
            aria-label="Close"
          >
            <X size={20} />
          </button>
        </div>
      </div>
    </div>
  );
};

export default PWAInstallPrompt;




==== File: components\ui\common\SimpleDraggableSheet.tsx ====
'use client';

import React, { useState, useRef, useEffect } from 'react';

interface SimpleDraggableSheetProps {
  children: React.ReactNode;
  minHeight: number;
  maxHeight: number;
  initialHeight?: number;
}

const SimpleDraggableSheet: React.FC<SimpleDraggableSheetProps> = ({
  children,
  minHeight,
  maxHeight,
  initialHeight = minHeight,
}) => {
  const [height, setHeight] = useState(initialHeight);
  const [isDragging, setIsDragging] = useState(false);
  const startYRef = useRef(0);
  const startHeightRef = useRef(initialHeight);
  const sheetRef = useRef<HTMLDivElement>(null);

  // Handle drag start
  const handleTouchStart = (e: React.TouchEvent | React.MouseEvent) => {
    const clientY = 'touches' in e ? e.touches[0].clientY : (e as React.MouseEvent).clientY;
    startYRef.current = clientY;
    startHeightRef.current = height;
    setIsDragging(true);
  };

  // Handle drag move
  const handleTouchMove = (e: TouchEvent | MouseEvent) => {
    if (!isDragging) return;
    
    const clientY = 'touches' in e ? e.touches[0].clientY : (e as MouseEvent).clientY;
    const deltaY = startYRef.current - clientY;
    const newHeight = Math.min(maxHeight, Math.max(minHeight, startHeightRef.current + deltaY));
    
    setHeight(newHeight);
  };

  // Handle drag end
  const handleTouchEnd = () => {
    setIsDragging(false);
    
    // Snap to closest position (min or max)
    const midPoint = (minHeight + maxHeight) / 2;
    if (height < midPoint) {
      setHeight(minHeight);
    } else {
      setHeight(maxHeight);
    }
  };

  // Add and remove event listeners
  useEffect(() => {
    const handleMouseMove = (e: MouseEvent) => handleTouchMove(e);
    const handleMouseUp = () => handleTouchEnd();
    
    if (isDragging) {
      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('mouseup', handleMouseUp);
      document.addEventListener('touchmove', handleTouchMove);
      document.addEventListener('touchend', handleTouchEnd);
    }
    
    return () => {
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
      document.removeEventListener('touchmove', handleTouchMove);
      document.removeEventListener('touchend', handleTouchEnd);
    };
  }, [isDragging]);

  return (
    <div 
      ref={sheetRef}
      className="fixed bottom-0 left-0 right-0 bg-[#212121] rounded-t-xl transition-all duration-300 ease-in-out overflow-hidden
        md:left-1/2 md:transform md:-translate-x-1/2 md:max-w-md"
      style={{ 
        height: `${height}px`,
        transition: isDragging ? 'none' : 'height 0.3s ease'
      }}
    >
      {/* Drag handle */}
      <div 
        className="w-full flex justify-center py-2 cursor-grab"
        onTouchStart={handleTouchStart}
        onMouseDown={handleTouchStart}
      >
        <div className="w-10 h-1 bg-gray-600 rounded-full"></div>
      </div>
      
      {/* Content */}
      <div className="overflow-y-auto h-[calc(100%-24px)]">
        {children}
      </div>
    </div>
  );
};

export default SimpleDraggableSheet;



==== File: components\ui\icons\Icon.tsx ====
// components/ui/icons/Icon.tsx
import React from 'react';
import * as LucideIcons from 'lucide-react';

interface IconProps {
  name: string;
  className?: string;
}

const Icon: React.FC<IconProps> = ({ name, className = 'w-6 h-6' }) => {
  // Map for standard icons (navigation, UI elements, etc.)
  const standardIconMap: Record<string, any> = {
    car: LucideIcons.Car,
    deposit: LucideIcons.PlusCircle,
    home: LucideIcons.Home,
    insights: LucideIcons.LineChart,
    add: LucideIcons.Plus,
    wallet: LucideIcons.Wallet,
    more: LucideIcons.MoreHorizontal,
    shopping: LucideIcons.ShoppingBag,
    transfer: LucideIcons.ArrowLeftRight, // Using the correct name from documentation
    subscription: LucideIcons.Repeat,
    entertainment: LucideIcons.Music,
    notificationBell: LucideIcons.Bell,
    repeat: LucideIcons.Repeat, // For pay button
  };

  // Map for merchant-specific icons
  const merchantIconMap: Record<string, any> = {
    netflix: LucideIcons.Tv,
    spotify: LucideIcons.Music,
    amazon: LucideIcons.ShoppingCart,
    uber: LucideIcons.Car,
    starbucks: LucideIcons.Coffee,
    zara: LucideIcons.ShoppingBag,
    payroll: LucideIcons.Landmark,
  };

  // Map for category-specific icons
  const categoryIconMap: Record<string, any> = {
    food: LucideIcons.UtensilsCrossed,
    dining: LucideIcons.UtensilsCrossed,
    travel: LucideIcons.Plane,
    transport: LucideIcons.Bus,
    utilities: LucideIcons.Lightbulb,
    health: LucideIcons.Stethoscope,
    coffee: LucideIcons.Coffee,
  };

  // Try to render the icon based on name
  // First check standard icons, then merchant icons, then category icons
  const IconComponent = standardIconMap[name] || merchantIconMap[name] || categoryIconMap[name] || LucideIcons.CreditCard;
  
  return <IconComponent className={className} />;
};

export default Icon;



==== File: components\ui\navigation\BottomNav.tsx ====
// components/ui/navigation/BottomNav.tsx
'use client';

import React from 'react';
import Link from 'next/link';
import { usePathname } from 'next/navigation';
import { animated, useSpring } from 'react-spring';
import Icon from '../icons/Icon';
import { NavItemType } from '@/lib/types';

const BottomNav: React.FC = () => {
  const pathname = usePathname();
  
  // Define the navigation items with new arrangement
  const items: NavItemType[] = [
    { name: 'Deposit', icon: 'deposit', href: '/deposit' },
    { name: 'Insights', icon: 'insights', href: '/insights' },
    { name: 'Accounts', icon: 'wallet', href: '/' },
    { name: 'Transfer', icon: 'transfer', href: '/transfer' },
    { name: 'More', icon: 'more', href: '/more' },
  ];
  
  // Create a spring animation for the navbar
  const navbarSpring = useSpring({
    from: { y: 20 },
    to: { y: 0 },
    config: { tension: 280, friction: 25 },
    delay: 300,
  });

  return (
    <animated.div 
      style={{
        opacity: 1, // Always visible
        transform: `translateY(${navbarSpring.y}px)`,
        zIndex: 100
      }}
      className="fixed bottom-0 left-0 right-0 bg-[#212121] py-3 px-4 flex justify-between items-center
        md:left-1/2 md:transform md:-translate-x-1/2 md:max-w-sm
        lg:max-w-md xl:max-w-md"
    >
      {items.map((item) => {
        const isActive = pathname === item.href;
        const isSpecial = item.name === 'Accounts';

        return (
          <Link 
            key={item.name} 
            href={item.href}
            className="flex flex-col items-center"
          >
            <div
              className={`
                ${isActive ? 'text-white' : 'text-gray-400'} 
                ${isSpecial ? 'bg-red-600 p-3 rounded-full -mt-8 shadow-lg border border-red-700' : ''}
                transition-all duration-200
              `}
            >
              <Icon name={item.icon} className={`${isSpecial ? 'w-6 h-6' : 'w-5 h-5'}`} />
            </div>
            <span
              className={`text-xs mt-1 ${isActive ? 'text-white' : 'text-gray-400'}`}
            >
              {item.name}
            </span>
          </Link>
        );
      })}
    </animated.div>
  );
};

export default BottomNav;




==== File: components\ui\navigation\Header.tsx ====
// components/ui/navigation/Header.tsx
'use client';

import React from 'react';
import { Bell } from 'lucide-react';
import { animated, useSpring } from 'react-spring';
import { useEnhancedBankingData } from '@/components/preloaders/EnhancedBankingDataProvider';

interface HeaderProps {
  userName: string;
}

const Header: React.FC<HeaderProps> = ({ userName }) => {
  // Get user data for avatar
  const { userData } = useEnhancedBankingData();
  const userAvatar = userData?.user?.avatar || '/images/avatar/placeholder.svg';
  // Create a spring animation for the header
  const headerSpring = useSpring({
    from: { opacity: 0, y: -10 },
    to: { opacity: 1, y: 0 },
    config: { tension: 280, friction: 25 },
  });

  // Animation for the notification dot
  const notificationSpring = useSpring({
    from: { transform: 'scale(0)' },
    to: { transform: 'scale(1)' },
    delay: 500,
    config: { tension: 400, friction: 20 },
  });

  return (
    <animated.div style={headerSpring} className="px-5 pt-8 pb-6 mx-auto max-w-md">
      <div className="flex justify-between items-center">
        <div className="flex items-center">
          <div className="w-10 h-10 rounded-full mr-3 overflow-hidden border border-gray-700">
            <img 
              src={userAvatar} 
              alt="Profile" 
              className="w-full h-full object-cover"
            />
          </div>
          <div className="text-xl font-medium tracking-tight">Welcome, {userName}!</div>
        </div>
        <button className="relative p-1">
          <Bell className="w-6 h-6" />
          <animated.span 
            style={notificationSpring}
            className="absolute top-0 right-0 w-2 h-2 bg-red-500 rounded-full transform -translate-y-1/4 translate-x-1/4"
          ></animated.span>
        </button>
      </div>
    </animated.div>
  );
};

export default Header;




==== File: components\ui\transactions\TransactionContainer.tsx ====
// components/ui/transactions/TransactionContainer.tsx
'use client';

import React, { useState, useRef, useEffect } from 'react';
import { animated, useSpring } from 'react-spring';
import { useDrag } from '@use-gesture/react';
import TransactionList from './TransactionList';
import { TransactionDateGroup } from '@/lib/types';
import SpendingChart from '../charts/SpendingChart';

interface TransactionContainerProps {
  transactionGroups: TransactionDateGroup[];
  buttonBottomPosition: number;
  isCollapsed?: boolean;
  onCollapseChange?: (collapsed: boolean) => void;
}

const TransactionContainer: React.FC<TransactionContainerProps> = ({ 
  transactionGroups,
  buttonBottomPosition,
  isCollapsed = false,
  onCollapseChange
}) => {
  // Track internal view state
  const [viewMode, setViewMode] = useState<'collapsed' | 'default' | 'fullscreen'>(
    isCollapsed ? 'collapsed' : 'fullscreen' // Default to fullscreen when opening
  );
  
  // Shared period state for both chart and transactions
  const [selectedPeriod, setSelectedPeriod] = useState('month');
  
  const containerRef = useRef<HTMLDivElement>(null);
  const isDraggingRef = useRef(false);
  const isAnimatingRef = useRef(false);
  
  // Heights for each state
  const [collapsedHeight, setCollapsedHeight] = useState(80); // Just enough for header
  const [defaultHeight, setDefaultHeight] = useState(500);
  const [fullscreenHeight, setFullscreenHeight] = useState(window.innerHeight);
  const [navbarHeight] = useState(64); // Bottom navigation height
  
  // Synchronize with parent's collapsed state
  useEffect(() => {
    if (isCollapsed) {
      setViewMode('collapsed');
    } else {
      setViewMode('fullscreen'); // Open in fullscreen
    }
  }, [isCollapsed]);
  
  // Calculate heights based on content position
  useEffect(() => {
    if (buttonBottomPosition <= 0) return;
    
    const calculateHeights = () => {
      const viewportHeight = window.innerHeight;
      
      // Calculate the available space between buttons and navbar
      const availableHeight = viewportHeight - buttonBottomPosition - navbarHeight;
      
      // Collapsed height - just enough for title and drag handle
      const calculatedCollapsedHeight = 80;
      
      // Default height - uses most of available space
      const calculatedDefaultHeight = Math.max(
        availableHeight - 20, // Leave a small gap
        Math.min(availableHeight * 0.95, 400) // Ensure minimum height
      );
      
      // Fullscreen - covers from top of viewport to navbar
      const calculatedFullscreenHeight = viewportHeight - navbarHeight;
      
      setCollapsedHeight(calculatedCollapsedHeight);
      setDefaultHeight(calculatedDefaultHeight);
      setFullscreenHeight(calculatedFullscreenHeight);
    };
    
    calculateHeights();
    window.addEventListener('resize', calculateHeights);
    return () => window.removeEventListener('resize', calculateHeights);
  }, [buttonBottomPosition, navbarHeight]);
  
  // Get current height based on view mode
  const getCurrentHeight = (mode = viewMode) => {
    switch (mode) {
      case 'collapsed': return collapsedHeight;
      case 'default': return defaultHeight;
      case 'fullscreen': return fullscreenHeight;
    }
  };
  
  // Set up spring animation for the height
  const [{ height }, api] = useSpring(() => ({
    from: { height: isCollapsed ? collapsedHeight : fullscreenHeight },
    to: { height: isCollapsed ? collapsedHeight : fullscreenHeight },
    config: { mass: 1, tension: 280, friction: 25 },
    immediate: false,
    onRest: () => {
      isAnimatingRef.current = false;
      
      // Notify parent about collapse state changes
      if (onCollapseChange && (viewMode === 'collapsed') !== isCollapsed) {
        onCollapseChange(viewMode === 'collapsed');
      }
    }
  }));
  
  // Update spring when view mode or heights change
  useEffect(() => {
    if (isDraggingRef.current) return;
    
    const targetHeight = getCurrentHeight();
    if (targetHeight > 0) {
      isAnimatingRef.current = true;
      
      api.start({ 
        height: targetHeight,
        immediate: false,
        config: { mass: 1, tension: 280, friction: 25 }
      });
    }
  }, [viewMode, collapsedHeight, defaultHeight, fullscreenHeight, api]);
  
  // Handle expand button click (from collapsed state)
  const handleExpandClick = () => {
    if (isAnimatingRef.current) return;
    
    // When expanding from collapsed, go to fullscreen view
    setViewMode('fullscreen');
    
    // Notify parent
    if (onCollapseChange) {
      onCollapseChange(false);
    }
  };
  
  // Filter options
  const periodOptions = [
    { id: 'day', name: 'Day', label: 'today' },
    { id: 'week', name: 'Week', label: 'this week' },
    { id: 'month', name: 'Month', label: 'this month' },
    { id: 'year', name: 'Year', label: 'this year' },
  ];
  
  // Handle period change - unified for both chart and transactions
  const handlePeriodChange = (period: string) => {
    setSelectedPeriod(period);
  };
  
  // Set up drag gesture
  const bind = useDrag(({ movement: [_, my], last, velocity, first, active }) => {
    // Handle drag start
    if (first) {
      isDraggingRef.current = true;
    }
    
    // During active drag
    if (active && !last) {
      // Calculate new height based on drag
      const currentHeight = getCurrentHeight();
      const newHeight = currentHeight - my;
      const minHeight = collapsedHeight - 5;
      const maxHeight = fullscreenHeight + 5;
      
      // Apply constraints and update immediately
      const constrainedHeight = Math.max(minHeight, Math.min(maxHeight, newHeight));
      api.start({
        height: constrainedHeight,
        immediate: true
      });
    }
    
    // Handle drag end
    if (last) {
      // Calculate velocity and thresholds
      const [, vy] = velocity;
      const isFlick = Math.abs(vy) > 0.5;
      const dragThreshold = isFlick ? 20 : 60;
      
      // Determine target state based on current state, drag distance and velocity
      let targetMode = viewMode;
      
      if (viewMode === 'fullscreen') {
        // From fullscreen, dragging down
        if (my > dragThreshold) {
          targetMode = my > 150 || vy > 1 ? 'collapsed' : 'default';
        }
      } else if (viewMode === 'default') {
        // From default, dragging up or down
        if (my < -dragThreshold || vy < -0.5) {
          targetMode = 'fullscreen';
        } else if (my > dragThreshold || vy > 0.5) {
          targetMode = 'collapsed';
        }
      } else if (viewMode === 'collapsed') {
        // From collapsed, dragging up - always go to fullscreen
        if (my < -dragThreshold || vy < -0.5) {
          targetMode = 'fullscreen';
        }
      }
      
      // Animate to the target height
      if (targetMode !== viewMode) {
        isAnimatingRef.current = true;
        setViewMode(targetMode);
        
        // Start animating to the target height
        api.start({
          height: getCurrentHeight(targetMode),
          immediate: false,
          config: { 
            mass: 1, 
            tension: 280, 
            friction: 25 
          }
        });
        
        // Notify parent if needed
        if (onCollapseChange && (targetMode === 'collapsed') !== isCollapsed) {
          onCollapseChange(targetMode === 'collapsed');
        }
      } else {
        // If no change in mode, still animate back to current height
        isAnimatingRef.current = true;
        api.start({
          height: getCurrentHeight(),
          immediate: false
        });
      }
      
      // Clear dragging flag after a short delay
      setTimeout(() => {
        isDraggingRef.current = false;
      }, 50);
    }
  });

  return (
    <animated.div
      ref={containerRef}
      className={`
        fixed left-0 right-0 overflow-hidden
        md:left-1/2 md:transform md:-translate-x-1/2 md:max-w-md
        ${viewMode === 'fullscreen' ? 'bg-app-black rounded-none' : 'bg-[#212121] rounded-t-3xl shadow-lg'}`
      }
      style={{ 
        height,
        bottom: navbarHeight, // Position above bottom navigation
        top: 'auto', // Never attach to top
        maxHeight: viewMode === 'fullscreen' ? `calc(100vh - ${navbarHeight}px)` : 'none',
        zIndex: 50, // Ensure proper z-index
      }}
    >
      {/* Drag handle */}
      <div 
        className="drag-handle-container mt-1" 
        {...bind()}
      >
        <div className="drag-handle" />
      </div>
      
      {/* Header with title and controls */}
      <div className="flex justify-between items-center px-6 pt-2 py-2">
        <h2 className="text-white text-xl font-medium">
          Transactions
        </h2>
        
        {viewMode === 'fullscreen' && (
          <button 
            className="text-gray-400 text-sm hover:text-white transition-colors"
            onClick={() => {
              // Direct collapse
              setViewMode('collapsed');
              if (onCollapseChange) {
                onCollapseChange(true);
              }
            }}
          >
            Collapse
          </button>
        )}
        
        {viewMode === 'collapsed' && (
          <button 
            className="text-gray-400 text-sm hover:text-white transition-colors"
            onClick={handleExpandClick}
          >
            Expand
          </button>
        )}
      </div>
      
      {/* Chart section - Spending Chart First */}
      {viewMode === 'fullscreen' && (
        <div className="px-6 mt-2 mb-4">
          <SpendingChart 
            selectedPeriod={selectedPeriod} 
            periodOptions={periodOptions}
          />
        </div>
      )}
      
      {/* Period selector tabs - MOVED BELOW the chart to match inspiration */}
      {viewMode === 'fullscreen' && (
        <div className="px-6 mb-6">
          <div className="flex justify-between rounded-lg overflow-hidden" style={{ backgroundColor: '#1a1a1a' }}>
            {periodOptions.map((option) => (
              <button
                key={option.id}
                className={`flex-1 py-3 text-center text-sm font-medium transition-colors ${
                  selectedPeriod === option.id
                    ? 'bg-[#333333] text-white'
                    : 'text-gray-400 hover:text-white'
                }`}
                onClick={() => handlePeriodChange(option.id)}
              >
                {option.name}
              </button>
            ))}
          </div>
        </div>
      )}
      
      {/* Transaction list with proper overflow handling */}
      <div 
        className="overflow-y-auto" 
        style={{ 
          height: viewMode === 'collapsed' ? 0 : viewMode === 'fullscreen' ? 'calc(100% - 340px)' : 'calc(100% - 60px)',
          opacity: viewMode === 'collapsed' ? 0 : 1,
          transition: 'opacity 0.2s ease-in-out' 
        }}
      > 
        <TransactionList 
          transactionGroups={transactionGroups} 
          selectedPeriod={selectedPeriod}
        />
      </div>
    </animated.div>
  );
};

export default TransactionContainer;




==== File: components\ui\transactions\TransactionItem.tsx ====
// components/ui/transactions/TransactionItem.tsx
import React from 'react';
import { animated, useSpring } from 'react-spring';
import Icon from '../icons/Icon';
import { TransactionType } from '@/lib/types';

interface TransactionItemProps {
  transaction: TransactionType;
  isLastInGroup?: boolean;
  index?: number;
}

const TransactionItem: React.FC<TransactionItemProps> = ({ 
  transaction, 
  isLastInGroup = false,
  index = 0
}) => {
  // Use a consistent gray color for all icon backgrounds to match the inspiration
  const iconBgColor = 'bg-neutral-700'; // Closer to #3b3b3b // Subtle gray that matches the inspiration
  
  // Create a spring animation with a staggered delay based on index
  const springs = useSpring({
    from: { opacity: 0, x: -5 },
    to: { opacity: 1, x: 0 },
    delay: index * 50, // Stagger the animations
    config: { mass: 1, tension: 280, friction: 25 }
  });

  return (
    <animated.div 
      style={springs}
      className={`flex items-center justify-between py-3 hover:bg-neutral-700/30 px-4 rounded-lg transition-colors ${!isLastInGroup ? 'border-b border-gray-700/30' : ''}`}
    >
      <div className="flex items-center">
        <div className={`${iconBgColor} w-10 h-10 rounded-full flex items-center justify-center mr-3`}>
          <Icon name={transaction.icon} className="w-5 h-5 text-white" />
        </div>
        <div>
          <div className="font-medium tracking-tight text-white">{transaction.merchant}</div>
          <div className="text-gray-400 text-sm">
            {transaction.location || transaction.message}
          </div>
        </div>
      </div>
      <div className="text-right">
        <div className={`font-medium tracking-tight ${transaction.isIncoming ? 'text-green-500' : 'text-white'}`}>
          {transaction.isIncoming ? '+' : ''}${transaction.amount.toFixed(2)}
        </div>
        <div className="text-gray-400 text-sm">{transaction.timestamp}</div>
      </div>
    </animated.div>
  );
};

export default TransactionItem;



==== File: components\ui\transactions\TransactionList.tsx ====
// components/ui/transactions/TransactionList.tsx
import React, { useState, useEffect } from 'react';
import { animated, useTransition } from 'react-spring';
import TransactionItem from './TransactionItem';
import { TransactionDateGroup } from '@/lib/types';
import { getTransactionsByPeriod } from '@/lib/data/transactions';
import { useBankingData } from '@/components/preloaders/BankingDataPreloader';

interface TransactionListProps {
  transactionGroups: TransactionDateGroup[];
  selectedPeriod: string;
}

const TransactionList: React.FC<TransactionListProps> = ({ 
  transactionGroups: initialGroups,
  selectedPeriod
}) => {
  const [transactionGroups, setTransactionGroups] = useState<TransactionDateGroup[]>(initialGroups);
  const { data } = useBankingData();

  // Update transactions when period changes
  useEffect(() => {
    // If banking data is available, try to use it first
    if (data && (data as any).groupedTransactions && (data as any).groupedTransactions.user1) {
      setTransactionGroups((data as any).groupedTransactions.user1);
    } else {
      // Fall back to predefined transactions
      const updatedTransactions = getTransactionsByPeriod(selectedPeriod);
      setTransactionGroups(updatedTransactions);
    }
  }, [selectedPeriod, data]);

  // React Spring transitions for period changes
  const transitions = useTransition(
    // Use the selected period as the item we're transitioning
    { period: selectedPeriod, groups: transactionGroups },
    {
      from: { opacity: 0, transform: 'translate3d(0,-20px,0)' },
      enter: { opacity: 1, transform: 'translate3d(0,0px,0)' },
      leave: { opacity: 0, transform: 'translate3d(0,-20px,0)' },
      // Using a unique key based on the period to prevent old content from mixing with new
      keys: item => item.period,
      config: { mass: 1, tension: 280, friction: 25 }
    }
  );

  // Transitions for individual groups
  const groupTransitions = useTransition(
    transactionGroups,
    {
      from: { opacity: 0, transform: 'translate3d(0,20px,0)' },
      enter: { opacity: 1, transform: 'translate3d(0,0px,0)' },
      leave: { opacity: 0, transform: 'translate3d(0,20px,0)' },
      trail: 100, // Stagger the animations
      keys: group => group.date,
      config: { mass: 1, tension: 280, friction: 25 }
    }
  );

  return (
    <div className="pb-32">
      {/* Use the main transition for the entire list */}
      {transitions((style, item) => (
        <animated.div style={style}>
          {/* Then animate each group separately */}
          {groupTransitions((groupStyle, group) => (
            <animated.div 
              style={groupStyle}
              className="mb-4"
            >
              <div className="sticky top-0 bg-[#1a1a1a] px-6 py-2 text-neutral-400 text-xs uppercase font-semibold z-10 ">
                {group.date}
              </div>
              <div>
                {group.transactions.map((transaction, transactionIndex) => (
                  <TransactionItem 
                    key={transaction.id}
                    transaction={transaction} 
                    isLastInGroup={transactionIndex === group.transactions.length - 1}
                  />
                ))}
              </div>
            </animated.div>
          ))}
        </animated.div>
      ))}
    </div>
  );
};

export default TransactionList;




==== File: lib\config\iconMappings.ts ====
/**
 * Icon Mappings Configuration
 * 
 * This file contains all icon mappings used throughout the application.
 * Centralizing these mappings makes it easier to maintain and update icons.
 */

import * as LucideIcons from 'lucide-react';

/**
 * Standard UI icons used for navigation, buttons, and general UI elements
 */
export const standardIconMap: Record<string, any> = {
  // Navigation icons
  home: LucideIcons.Home,
  wallet: LucideIcons.Wallet,
  insights: LucideIcons.LineChart,
  deposit: LucideIcons.PlusCircle,
  transfer: LucideIcons.ArrowLeftRight,
  more: LucideIcons.MoreHorizontal,
  
  // Action icons
  add: LucideIcons.Plus,
  edit: LucideIcons.Edit,
  delete: LucideIcons.Trash,
  search: LucideIcons.Search,
  settings: LucideIcons.Settings,
  
  // Notification icons
  notificationBell: LucideIcons.Bell,
  alert: LucideIcons.AlertTriangle,
  info: LucideIcons.Info,
  
  // Payment icons
  repeat: LucideIcons.Repeat, // For recurring payments
  calendar: LucideIcons.Calendar, // For scheduled payments
  
  // Misc UI icons
  chevronDown: LucideIcons.ChevronDown,
  chevronUp: LucideIcons.ChevronUp,
  chevronLeft: LucideIcons.ChevronLeft,
  chevronRight: LucideIcons.ChevronRight,
  close: LucideIcons.X,
  check: LucideIcons.Check,
  lock: LucideIcons.Lock,
  unlock: LucideIcons.Unlock,
};

/**
 * Merchant-specific icons for transaction displays
 */
export const merchantIconMap: Record<string, any> = {
  // Streaming services
  netflix: LucideIcons.Tv,
  hulu: LucideIcons.Tv,
  disney: LucideIcons.Tv,
  
  // Music services
  spotify: LucideIcons.Music,
  appleMusic: LucideIcons.Music,
  
  // Shopping
  amazon: LucideIcons.ShoppingCart,
  target: LucideIcons.ShoppingBag,
  walmart: LucideIcons.ShoppingBag,
  zara: LucideIcons.ShoppingBag,
  
  // Transportation
  uber: LucideIcons.Car,
  lyft: LucideIcons.Car,
  
  // Food & Drink
  starbucks: LucideIcons.Coffee,
  mcdonalds: LucideIcons.UtensilsCrossed,
  chipotle: LucideIcons.UtensilsCrossed,
  
  // Financial
  payroll: LucideIcons.Landmark,
  venmo: LucideIcons.DollarSign,
  paypal: LucideIcons.DollarSign,
};

/**
 * Category-specific icons for transaction categorization
 */
export const categoryIconMap: Record<string, any> = {
  // Food & Dining
  food: LucideIcons.UtensilsCrossed,
  dining: LucideIcons.UtensilsCrossed,
  groceries: LucideIcons.ShoppingCart,
  coffee: LucideIcons.Coffee,
  
  // Transportation
  transport: LucideIcons.Bus,
  travel: LucideIcons.Plane,
  gas: LucideIcons.Fuel,
  
  // Housing & Utilities
  utilities: LucideIcons.Lightbulb,
  rent: LucideIcons.Home,
  mortgage: LucideIcons.Home,
  home: LucideIcons.Home,
  
  // Shopping
  shopping: LucideIcons.ShoppingBag,
  clothing: LucideIcons.Shirt,
  electronics: LucideIcons.Smartphone,
  
  // Health & Wellness
  health: LucideIcons.Stethoscope,
  fitness: LucideIcons.Dumbbell,
  medical: LucideIcons.Heart, // Using Heart instead of FirstAid which isn't available
  
  // Entertainment
  entertainment: LucideIcons.Music,
  subscription: LucideIcons.Repeat,
  movies: LucideIcons.Film,
  
  // Financial
  income: LucideIcons.TrendingUp,
  investment: LucideIcons.LineChart,
  savings: LucideIcons.PiggyBank,
  
  // Other
  other: LucideIcons.CircleDot,
  uncategorized: LucideIcons.HelpCircle,
};

/**
 * Get the appropriate icon component based on name
 * Checks all icon maps in order of priority
 */
export const getIconByName = (name: string): any => {
  return (
    standardIconMap[name] || 
    merchantIconMap[name] || 
    categoryIconMap[name] || 
    LucideIcons.CreditCard // Default fallback icon
  );
};




==== File: lib\config\preloaderConfig.ts ====
// lib/config/preloaderConfig.ts
export const preloaderConfig = {
  // General preloader settings
  enabled: true,  // Set to false to disable preloading in all environments
  devModeEnabled: false, // Whether to enable preloading in development mode
  
  // Banking data preloader settings
  bankingData: {
    simulateApiDelay: 1500, // Milliseconds to simulate API loading time
    preProcessData: true,   // Whether to pre-process data for faster rendering
    persistData: true,      // Whether to persist data in localStorage
    clearCacheOnReload: false // Whether to clear cache on full page reload
  },
  
  // Image preloader settings
  images: {
    timeout: 10000,    // Milliseconds to wait before timing out image preloading
    retries: 2,        // Number of retries for failed image loads
    parallel: 8,       // Number of images to load in parallel
    priorityImages: [  // These images will be loaded first
      '/images/icons/logo.png',
      '/images/card/card-signature-rewards.png',  // First onboarding slide image
      '/images/avatar/jess-coleman.png',
      '/images/cards/visa-signature-bg.png',
      '/images/refer/refer-friend.png'
    ]
  },
  
  // Loading screen appearance
  loadingScreen: {
    logo: '/icons/icon-transparent.png',
    minDisplayTime: 1000, // Minimum time to show loading screen in milliseconds
    transitionDuration: 500 // Transition duration in milliseconds
  }
};

export default preloaderConfig;




==== File: lib\context\ThemeContext.tsx ====
// lib/context/ThemeContext.tsx
'use client';

import React, { createContext, useState, useContext, useEffect, ReactNode } from 'react';

type Theme = 'dark' | 'light' | 'system';

interface ThemeContextType {
  theme: Theme;
  setTheme: (theme: Theme) => void;
  isDarkMode: boolean;
}

const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

interface ThemeProviderProps {
  children: ReactNode;
  defaultTheme?: Theme;
}

export const ThemeProvider: React.FC<ThemeProviderProps> = ({ 
  children, 
  defaultTheme = 'dark' 
}) => {
  const [theme, setTheme] = useState<Theme>(defaultTheme);
  const [isDarkMode, setIsDarkMode] = useState<boolean>(true);

  // Initialize theme from localStorage on mount
  useEffect(() => {
    const savedTheme = localStorage.getItem('theme') as Theme | null;
    if (savedTheme) {
      setTheme(savedTheme);
    }
  }, []);

  // Update localStorage when theme changes
  useEffect(() => {
    localStorage.setItem('theme', theme);
    
    // Apply theme to document
    const root = document.documentElement;
    
    // Remove all theme classes
    root.classList.remove('theme-dark', 'theme-light');
    
    // Determine if we should use dark mode
    let shouldUseDarkMode = theme === 'dark';
    
    if (theme === 'system') {
      shouldUseDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches;
      
      // Add listener for system theme changes
      const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
      const handleChange = (e: MediaQueryListEvent) => {
        setIsDarkMode(e.matches);
        root.classList.toggle('theme-dark', e.matches);
        root.classList.toggle('theme-light', !e.matches);
      };
      
      mediaQuery.addEventListener('change', handleChange);
      return () => mediaQuery.removeEventListener('change', handleChange);
    }
    
    // Apply the appropriate theme class
    root.classList.add(shouldUseDarkMode ? 'theme-dark' : 'theme-light');
    setIsDarkMode(shouldUseDarkMode);
  }, [theme]);

  return (
    <ThemeContext.Provider value={{ theme, setTheme, isDarkMode }}>
      {children}
    </ThemeContext.Provider>
  );
};

export const useTheme = (): ThemeContextType => {
  const context = useContext(ThemeContext);
  if (context === undefined) {
    throw new Error('useTheme must be used within a ThemeProvider');
  }
  return context;
};




'use client';

import React, { ReactNode } from 'react';
import { ThemeProvider } from './ThemeContext';

interface ThemeContextProviderProps {
  children: ReactNode;
  defaultTheme?: 'dark' | 'light' | 'system';
}

/**
 * Separate provider component to prevent unnecessary re-renders
 */
const ThemeContextProvider: React.FC<ThemeContextProviderProps> = ({ 
  children, 
  defaultTheme = 'dark' 
}) => {
  return (
    <ThemeProvider defaultTheme={defaultTheme}>
      {children}
    </ThemeProvider>
  );
};

export default ThemeContextProvider;




==== File: lib\data\cards.ts ====
import { CardType } from '../types';

export const cards: CardType[] = [
  {
    id: '1',
    type: 'VISA',
    number: ' 9891',
    expiry: '/',
    cvv: '',
    color: '#E53E3E', // Updated red color that better matches the inspiration
  },
  // You can add more cards here
];

export const getCard = (id: string): CardType | undefined => {
  return cards.find(card => card.id === id);
};

export const getDefaultCard = (): CardType => {
  return cards[0];
};




==== File: lib\data\fakeBankingData.js ====
// Members 1st Credit Union Demo Banking Data Generator
// This script creates realistic fake data for demo purposes

// Utility functions
const formatCurrency = (amount) => {
    return amount.toLocaleString('en-US', { 
      style: 'currency', 
      currency: 'USD',
      minimumFractionDigits: 2,
      maximumFractionDigits: 2
    });
  };
  
  const formatDate = (date) => {
    return date.toLocaleDateString('en-US', {
      year: 'numeric',
      month: '2-digit',
      day: '2-digit'
    });
  };
  
  const generateAccountNumber = () => {
    return Math.floor(Math.random() * 9000000) + 1000000;
  };
  
  const generateCardNumber = () => {
    return `•••• ${Math.floor(Math.random() * 9000) + 1000}`;
  };
  
  const generateLoanNumber = () => {
    return `LOAN-${Math.floor(Math.random() * 900000) + 100000}`;
  };
  
  const generateRandomAmount = (min, max) => {
    return Number((Math.random() * (max - min) + min).toFixed(2));
  };
  
  // Transaction generation utilities
  const merchants = [
    { name: 'Starbucks', category: 'dining', icon: 'coffee', averageAmount: 5.45, frequency: 'high' },
    { name: 'Whole Foods', category: 'groceries', icon: 'shopping', averageAmount: 85.32, frequency: 'medium' },
    { name: 'Amazon', category: 'shopping', icon: 'shopping', averageAmount: 35.47, frequency: 'medium' },
    { name: 'Netflix', category: 'subscription', icon: 'entertainment', averageAmount: 14.99, frequency: 'monthly' },
    { name: 'Target', category: 'shopping', icon: 'shopping', averageAmount: 65.32, frequency: 'medium' },
    { name: 'Uber', category: 'transport', icon: 'car', averageAmount: 24.50, frequency: 'medium' },
    { name: 'AT&T', category: 'utilities', icon: 'utilities', averageAmount: 89.99, frequency: 'monthly' },
    { name: 'Chevron', category: 'transport', icon: 'car', averageAmount: 48.75, frequency: 'medium' },
    { name: 'Giant Food', category: 'groceries', icon: 'shopping', averageAmount: 125.45, frequency: 'medium' },
    { name: 'Home Depot', category: 'home', icon: 'shopping', averageAmount: 87.35, frequency: 'low' },
    { name: 'Chipotle', category: 'dining', icon: 'food', averageAmount: 18.25, frequency: 'medium' },
    { name: 'Spotify', category: 'subscription', icon: 'entertainment', averageAmount: 9.99, frequency: 'monthly' },
    { name: 'CVS Pharmacy', category: 'health', icon: 'health', averageAmount: 32.50, frequency: 'low' },
    { name: 'PetSmart', category: 'pets', icon: 'shopping', averageAmount: 45.75, frequency: 'low' },
    { name: 'AMC Theaters', category: 'entertainment', icon: 'entertainment', averageAmount: 28.50, frequency: 'low' }
  ];
  
  const locations = {
    'Starbucks': ['East Shore', 'Camp Hill', 'Mechanicsburg'],
    'Target': ['Harrisburg', 'Colonial Park'],
    'Chipotle': ['Camp Hill', 'Carlisle Pike'],
    'Home Depot': ['Mechanicsburg', 'Carlisle'],
    'Giant Food': ['Linglestown Rd', 'Camp Hill', 'Carlisle Pike'],
    'Chevron': ['Jonestown Rd', 'Carlisle Pike', 'Cameron St'],
    'CVS Pharmacy': ['Market St', 'Camp Hill', 'Mechanicsburg'],
    'AMC Theaters': ['Colonial Park Mall']
  };
  
  const getRandomLocation = (merchantName) => {
    if (locations[merchantName]) {
      const locs = locations[merchantName];
      return locs[Math.floor(Math.random() * locs.length)];
    }
    return null;
  };
  
  const getRandomTime = () => {
    const hours = Math.floor(Math.random() * 12) + 1;
    const minutes = Math.floor(Math.random() * 60);
    const ampm = Math.random() > 0.5 ? 'AM' : 'PM';
    return `${hours}:${minutes.toString().padStart(2, '0')}${ampm}`;
  };
  
  const generateId = () => {
    return Math.random().toString(36).substring(2, 11);
  };
  
  const selectWeightedMerchant = (merchants) => {
    // Simple weighted selection
    const frequencyWeights = {
      'high': 0.5,
      'medium': 0.3,
      'low': 0.15,
      'monthly': 0.05
    };
    
    // Calculate total weight
    const totalWeight = merchants.reduce((sum, merchant) => {
      return sum + frequencyWeights[merchant.frequency];
    }, 0);
    
    // Select based on weight
    let random = Math.random() * totalWeight;
    let cumulativeWeight = 0;
    
    for (const merchant of merchants) {
      cumulativeWeight += frequencyWeights[merchant.frequency];
      if (random <= cumulativeWeight) {
        return merchant;
      }
    }
    
    return merchants[0]; // Fallback
  };
  
  // Generate transactions for a specific account
  const createTransactions = (userId, accountId, months = 3) => {
    const transactions = [];
    const currentDate = new Date();
    
    // Create 3 months of transaction history
    for (let day = 0; day < (months * 30); day++) {
      const date = new Date(currentDate);
      date.setDate(date.getDate() - day);
      
      // Add 0-5 transactions per day (weighted toward fewer)
      const dailyTransactionCount = Math.floor(Math.random() * 3) + (day % 7 === 5 ? 3 : 0); // More on weekends
      
      for (let t = 0; t < dailyTransactionCount; t++) {
        // Select random merchant with weighting toward frequent ones
        const merchant = selectWeightedMerchant(merchants);
        
        // Vary amount slightly from average
        const amount = merchant.averageAmount * (0.85 + (Math.random() * 0.3));
        const location = getRandomLocation(merchant.name);
        
        transactions.push({
          id: `txn-${Date.now()}-${Math.floor(Math.random() * 1000)}`,
          userId,
          accountId,
          date: date.toISOString(),
          merchant: merchant.name,
          category: merchant.category,
          icon: merchant.icon,
          amount: parseFloat(amount.toFixed(2)),
          isIncoming: Math.random() < 0.15, // 15% are income/refunds
          status: 'completed',
          location: location,
          message: location ? null : 'Online Purchase',
          timestamp: getRandomTime()
        });
      }
      
      // Add monthly salary for employed person on appropriate days
      if (userId === 'user1' && (day % 14 === 0)) { // Bi-weekly payroll
        transactions.push({
          id: `txn-${Date.now()}-${Math.floor(Math.random() * 1000)}`,
          userId,
          accountId,
          date: date.toISOString(),
          merchant: 'Payroll Deposit',
          category: 'income',
          icon: 'payroll',
          amount: 2654.33, // Net bi-weekly pay
          isIncoming: true,
          status: 'completed',
          message: 'Direct Deposit - Salary',
          timestamp: '9:00AM'
        });
      }
      
      // Monthly retirement income for second user
      if (userId === 'user2' && (day % 30 === 1)) {
        transactions.push({
          id: `txn-${Date.now()}-${Math.floor(Math.random() * 1000)}`,
          userId,
          accountId,
          date: date.toISOString(),
          merchant: 'Social Security',
          category: 'income',
          icon: 'payroll',
          amount: 2218.00,
          isIncoming: true,
          status: 'completed',
          message: 'Direct Deposit - SS Benefit',
          timestamp: '3:30AM'
        });
      }
      
      // Add monthly mortgage/rent payments
      if (day % 30 === 5) {
        transactions.push({
          id: `txn-${Date.now()}-${Math.floor(Math.random() * 1000)}`,
          userId,
          accountId,
          date: date.toISOString(),
          merchant: userId === 'user1' ? 'Members 1st Mortgage' : 'Sunset Apartments',
          category: 'housing',
          icon: 'home',
          amount: userId === 'user1' ? 1456.33 : 1100.00,
          isIncoming: false,
          status: 'completed',
          message: userId === 'user1' ? 'Monthly Mortgage Payment' : 'Rent Payment',
          timestamp: '8:00AM'
        });
      }
    }
    
    return transactions.sort((a, b) => new Date(b.date) - new Date(a.date));
  };
  
  // Group transactions by date (TODAY, YESTERDAY, or formatted date)
  const groupTransactionsByDate = (transactions) => {
    const today = new Date().toLocaleDateString();
    const yesterday = new Date(Date.now() - 86400000).toLocaleDateString();
    
    const grouped = transactions.reduce((groups, transaction) => {
      const txDate = new Date(transaction.date).toLocaleDateString();
      let dateLabel;
      
      if (txDate === today) {
        dateLabel = 'TODAY';
      } else if (txDate === yesterday) {
        dateLabel = 'YESTERDAY';
      } else {
        dateLabel = new Date(transaction.date).toLocaleDateString('en-US', {
          month: 'short',
          day: 'numeric', 
          year: 'numeric'
        }).toUpperCase();
      }
      
      if (!groups[dateLabel]) {
        groups[dateLabel] = [];
      }
      
      groups[dateLabel].push(transaction);
      return groups;
    }, {});
    
    // Format for component
    return Object.keys(grouped).map(date => ({
      date,
      transactions: grouped[date]
    }));
  };
  
  // Create two fake users with complete financial profiles
  const generateFakeUsers = () => {
    // --- USER 1: Young Professional ---
    const user1 = {
      id: 'user1',
      name: 'Jessica Coleman',
      username: 'jcoleman',
      email: 'j.coleman@example.com',
      avatar: '/images/avatar/jess-coleman.png',
      phone: '(717) 555-1234',
      address: '123 Pine Street, Harrisburg, PA 17101',
      ssn: '•••-••-7890',
      dob: '1992-05-15',
      occupation: 'Marketing Manager',
      income: 85000,
      joinDate: '2019-03-22',
      lastLogin: new Date().toISOString()
    };
    
    // --- USER 2: Retired Individual ---
    const user2 = {
      id: 'user2',
      name: 'Robert Thompson',
      username: 'rthompson',
      email: 'r.thompson@example.com',
      avatar: '/images/avatar/robert-thompson.png',
      phone: '(717) 555-8765',
      address: '456 Oak Avenue, Mechanicsburg, PA 17055',
      ssn: '•••-••-4321',
      dob: '1958-09-30',
      occupation: 'Retired (Former Teacher)',
      income: 52000, // Combined retirement income
      joinDate: '2002-07-14',
      lastLogin: new Date().toISOString()
    };
    
    // Banking Products for User 1
    const user1Accounts = [
      {
        id: 'acct-1001',
        userId: 'user1',
        type: 'checking',
        name: 'Members 1st Checking',
        accountNumber: `****${generateAccountNumber().toString().slice(-4)}`,
        routingNumber: '231382241',
        balance: 3427.59,
        availableBalance: 3227.59,
        pendingTransactions: 2,
        interestRate: 0.05,
        openDate: '2019-03-22'
      },
      {
        id: 'acct-1002',
        userId: 'user1',
        type: 'savings',
        name: 'Members 1st Savings',
        accountNumber: `****${generateAccountNumber().toString().slice(-4)}`,
        routingNumber: '231382241',
        balance: 15750.33,
        interestRate: 1.75,
        openDate: '2019-03-22'
      },
      {
        id: 'acct-1003',
        userId: 'user1',
        type: 'moneyMarket',
        name: 'Money Market Account',
        accountNumber: `****${generateAccountNumber().toString().slice(-4)}`,
        routingNumber: '231382241',
        balance: 25000.00,
        interestRate: 2.25,
        openDate: '2020-11-15'
      }
    ];
    
    // Banking Products for User 2
    const user2Accounts = [
      {
        id: 'acct-2001',
        userId: 'user2',
        type: 'checking',
        name: 'Members 1st Checking',
        accountNumber: `****${generateAccountNumber().toString().slice(-4)}`,
        routingNumber: '231382241',
        balance: 4850.26,
        availableBalance: 4850.26,
        pendingTransactions: 0,
        interestRate: 0.05,
        openDate: '2002-07-14'
      },
      {
        id: 'acct-2002',
        userId: 'user2',
        type: 'savings',
        name: 'Members 1st Savings',
        accountNumber: `****${generateAccountNumber().toString().slice(-4)}`,
        routingNumber: '231382241',
        balance: 42365.78,
        interestRate: 1.75,
        openDate: '2002-07-14'
      },
      {
        id: 'acct-2003',
        userId: 'user2',
        type: 'cd',
        name: '11-Month Certificate',
        accountNumber: `****${generateAccountNumber().toString().slice(-4)}`,
        routingNumber: '231382241',
        balance: 10000.00,
        interestRate: 4.00, // APY
        openDate: '2024-09-01',
        maturityDate: '2025-08-01'
      }
    ];
    
    // Credit Cards
    const creditCards = [
      {
        id: 'card-5001',
        userId: 'user1',
        type: 'visa',
        name: 'Visa Signature Rewards',
        cardNumber: '•••• 9891',
        expiry: '05/27',
        cvv: '•••',
        creditLimit: 12000,
        currentBalance: 2427.50,
        availableCredit: 9572.50,
        dueDate: '2025-05-25',
        minimumPayment: 35.00,
        rewardsBalance: 342.89,
        rewardsType: 'cashback',
        rewardsRate: '1.5%',
        applyDate: '2020-04-15',
        color: '#7b2528' // Red color for card design
      },
      {
        id: 'card-5002',
        userId: 'user2', 
        type: 'visa',
        name: 'Visa Platinum Low Rate',
        cardNumber: '•••• 5432',
        expiry: '09/26',
        cvv: '•••',
        creditLimit: 8000,
        currentBalance: 1256.78,
        availableCredit: 6743.22,
        dueDate: '2025-05-15',
        minimumPayment: 25.00,
        rewardsBalance: 0,
        rewardsType: 'none',
        rewardsRate: '0%',
        applyDate: '2015-02-10',
        color: '#333333' // Dark gray for card design
      }
    ];
    
    // Loans
    const loans = [
      {
        id: 'loan-7001',
        userId: 'user1',
        type: 'mortgage',
        name: 'Home Mortgage',
        loanNumber: generateLoanNumber(),
        originalAmount: 320000,
        currentBalance: 287650.50,
        interestRate: 4.25,
        monthlyPayment: 1456.33,
        originationDate: '2020-08-15',
        term: 30, // years
        nextPaymentDate: '2025-06-01',
        paymentsMade: 58,
        paymentsRemaining: 302,
        propertyAddress: '123 Pine Street, Harrisburg, PA 17101'
      },
      {
        id: 'loan-7002',
        userId: 'user1',
        type: 'auto',
        name: 'Auto Loan',
        loanNumber: generateLoanNumber(),
        originalAmount: 32000,
        currentBalance: 18743.21,
        interestRate: 3.25,
        monthlyPayment: 505.86,
        originationDate: '2022-11-10',
        term: 5, // years
        nextPaymentDate: '2025-06-05',
        paymentsMade: 18,
        paymentsRemaining: 42,
        vehicle: '2022 Honda CR-V',
        vin: 'JH4KA7650MC034521'
      },
      {
        id: 'loan-7003',
        userId: 'user2',
        type: 'homeEquity',
        name: 'Home Equity Freedom Line of Credit',
        loanNumber: generateLoanNumber(),
        originalAmount: 50000, // Credit line
        currentBalance: 15000, // Current used amount
        availableCredit: 35000,
        interestRate: 6.25,
        monthlyPayment: 250.00, // Minimum payment
        originationDate: '2022-01-18',
        term: 15, // years
        nextPaymentDate: '2025-06-10',
        paymentsMade: 28,
        paymentsRemaining: 152,
        propertyAddress: '456 Oak Avenue, Mechanicsburg, PA 17055'
      }
    ];
    
    // Generate transactions for each account
    const user1Transactions = {};
    const user2Transactions = {};
    
    user1Accounts.forEach(account => {
      user1Transactions[account.id] = createTransactions('user1', account.id, 3);
    });
    
    user2Accounts.forEach(account => {
      user2Transactions[account.id] = createTransactions('user2', account.id, 3);
    });
    
    // Format transactions for card view
    const user1GroupedTransactions = groupTransactionsByDate(
      user1Transactions[user1Accounts[0].id]
    );
    const user2GroupedTransactions = groupTransactionsByDate(
      user2Transactions[user2Accounts[0].id]
    );
    
    return {
      users: [user1, user2],
      accounts: [...user1Accounts, ...user2Accounts],
      creditCards,
      loans,
      transactions: {
        user1: user1Transactions,
        user2: user2Transactions
      },
      groupedTransactions: {
        user1: user1GroupedTransactions,
        user2: user2GroupedTransactions
      }
    };
  };
  
  // Execute the generator
  const bankingData = generateFakeUsers();
  console.log('Fake banking data generated successfully!');
  
  // Output sample data
  console.log('Sample User:', bankingData.users[0].name);
  console.log('Sample Account:', bankingData.accounts[0].name, 'Balance:', formatCurrency(bankingData.accounts[0].balance));
  console.log('Sample Card:', bankingData.creditCards[0].name);
  console.log('Sample Loan:', bankingData.loans[0].name, 'Balance:', formatCurrency(bankingData.loans[0].currentBalance));
  console.log('Sample Transaction:', bankingData.groupedTransactions.user1[0].transactions[0].merchant, 
    formatCurrency(bankingData.groupedTransactions.user1[0].transactions[0].amount));
  
  // Save data to localStorage (for web apps)
  if (typeof window !== 'undefined' && window.localStorage) {
    localStorage.setItem('members1stBankingData', JSON.stringify(bankingData));
    console.log('Data saved to localStorage. Use localStorage.getItem("members1stBankingData") to retrieve.');
  }
  
  // Export the data and generator functions
  export {
    bankingData,
    generateFakeUsers,
    createTransactions,
    groupTransactionsByDate,
    formatCurrency,
    formatDate
  };



==== File: lib\data\transactions.ts ====
// lib/data/transactions.ts
import { TransactionType, TransactionDateGroup } from '../types';

// Helper to generate transaction IDs
const generateId = () => Math.random().toString(36).substring(2, 11);

// Today's date for reference
const currentDate = new Date();

// Helper to create a date string from days ago
const daysAgo = (days: number) => {
  const date = new Date(currentDate);
  date.setDate(date.getDate() - days);
  
  // For today and yesterday
  if (days === 0) return 'TODAY';
  if (days === 1) return 'YESTERDAY';
  
  // For other days - format as "MMM DD, YYYY"
  return date.toLocaleDateString('en-US', {
    month: 'short',
    day: 'numeric',
    year: 'numeric'
  }).toUpperCase();
};

// DAILY TRANSACTIONS - For "Day" filter view
export const dailyTransactions: TransactionDateGroup[] = [
  {
    date: 'TODAY',
    transactions: [
      {
        id: generateId(),
        merchant: 'Zara',
        location: 'Harrisburg Mall',
        amount: 432.29,
        isIncoming: false,
        timestamp: '1:22PM',
        icon: 'shopping',
        category: 'clothes',
      },
      {
        id: generateId(),
        merchant: 'Mark Coleman',
        message: 'Thanks for the dinner!',
        amount: 128.00,
        isIncoming: true,
        timestamp: '12:32PM',
        icon: 'transfer',
      },
      {
        id: generateId(),
        merchant: 'Starbucks',
        location: 'Business Bay',
        amount: 18.50,
        isIncoming: false,
        timestamp: '10:15AM',
        icon: 'coffee',
        category: 'dining',
      },
    ],
  }
];

// WEEKLY TRANSACTIONS - For "Week" filter view
export const weeklyTransactions: TransactionDateGroup[] = [
  {
    date: 'TODAY',
    transactions: [
      {
        id: generateId(),
        merchant: 'Zara',
        location: 'Harrisburg Mall',
        amount: 432.29,
        isIncoming: false,
        timestamp: '1:22PM',
        icon: 'shopping',
        category: 'clothes',
      },
      {
        id: generateId(),
        merchant: 'Mark Coleman',
        message: 'Thanks for the dinner!',
        amount: 128.00,
        isIncoming: true,
        timestamp: '12:32PM',
        icon: 'transfer',
      }
    ],
  },
  {
    date: 'YESTERDAY',
    transactions: [
      {
        id: generateId(),
        merchant: 'Netflix',
        message: 'Subscription',
        amount: 18.00,
        isIncoming: false,
        timestamp: '12:45PM',
        icon: 'subscription',
        category: 'entertainment',
      },
      {
        id: generateId(),
        merchant: 'Damien Light',
        message: 'You won!',
        amount: 20.00,
        isIncoming: true,
        timestamp: '10:22AM',
        icon: 'entertainment',
      }
    ],
  },
  {
    date: daysAgo(2),
    transactions: [
      {
        id: generateId(),
        merchant: 'Uber',
        location: 'Downtown Harrisburg',
        amount: 35.50,
        isIncoming: false,
        timestamp: '9:10AM',
        icon: 'car',
        category: 'transport',
      },
      {
        id: generateId(),
        merchant: 'Starbucks',
        location: 'Business Bay',
        amount: 12.75,
        isIncoming: false,
        timestamp: '8:30AM',
        icon: 'coffee',
        category: 'dining',
      }
    ],
  },
  {
    date: daysAgo(5),
    transactions: [
      {
        id: generateId(),
        merchant: 'Amazon',
        message: 'Prime Monthly',
        amount: 14.99,
        isIncoming: false,
        timestamp: '3:14PM',
        icon: 'subscription',
        category: 'subscription',
      },
      {
        id: generateId(),
        merchant: 'Chipotle',
        location: 'Market Street',
        amount: 22.45,
        isIncoming: false,
        timestamp: '1:20PM',
        icon: 'food',
        category: 'dining',
      }
    ],
  }
];

// MONTHLY TRANSACTIONS - For "Month" filter view
export const monthlyTransactions: TransactionDateGroup[] = [
  {
    date: 'TODAY',
    transactions: [
      {
        id: generateId(),
        merchant: 'Zara',
        location: 'Harrisburg Mall',
        amount: 432.29,
        isIncoming: false,
        timestamp: '1:22PM',
        icon: 'shopping',
        category: 'clothes',
      },
      {
        id: generateId(),
        merchant: 'Mark Coleman',
        message: 'Thanks for the dinner!',
        amount: 128.00,
        isIncoming: true,
        timestamp: '12:32PM',
        icon: 'transfer',
      },
      {
        id: generateId(),
        merchant: 'Starbucks',
        location: 'Business Bay',
        amount: 18.50,
        isIncoming: false,
        timestamp: '10:15AM',
        icon: 'coffee',
        category: 'dining',
      },
    ],
  },
  {
    date: 'YESTERDAY',
    transactions: [
      {
        id: generateId(),
        merchant: 'Netflix',
        message: 'Subscription',
        amount: 18.00,
        isIncoming: false,
        timestamp: '12:45PM',
        icon: 'subscription',
        category: 'entertainment',
      },
      {
        id: generateId(),
        merchant: 'Damien Light',
        message: 'You won!',
        amount: 20.00,
        isIncoming: true,
        timestamp: '10:22AM',
        icon: 'entertainment',
      },
      {
        id: generateId(),
        merchant: 'Uber',
        location: 'Downtown Harrisburg',
        amount: 35.50,
        isIncoming: false,
        timestamp: '9:10AM',
        icon: 'car',
        category: 'transport',
      },
    ],
  },
  {
    date: 'APR 23, 2025',
    transactions: [
      {
        id: generateId(),
        merchant: 'Spotify',
        message: 'Premium Subscription',
        amount: 9.99,
        isIncoming: false,
        timestamp: '3:20PM',
        icon: 'subscription',
        category: 'entertainment',
      },
      {
        id: generateId(),
        merchant: 'Amazon',
        message: 'Online order',
        amount: 125.45,
        isIncoming: false,
        timestamp: '11:30AM',
        icon: 'shopping',
        category: 'shopping',
      },
      {
        id: generateId(),
        merchant: 'Payroll',
        message: 'Monthly salary',
        amount: 5280.00,
        isIncoming: true,
        timestamp: '9:00AM',
        icon: 'transfer',
        category: 'income',
      },
    ],
  },
  {
    date: 'APR 15, 2025',
    transactions: [
      {
        id: generateId(),
        merchant: 'Target',
        location: 'Downtown',
        amount: 87.32,
        isIncoming: false,
        timestamp: '4:10PM',
        icon: 'shopping',
        category: 'shopping',
      },
      {
        id: generateId(),
        merchant: 'Home Depot',
        location: 'West Side',
        amount: 321.56,
        isIncoming: false,
        timestamp: '11:05AM',
        icon: 'shopping',
        category: 'home',
      }
    ],
  },
  {
    date: 'APR 8, 2025',
    transactions: [
      {
        id: generateId(),
        merchant: 'Health Insurance',
        message: 'Monthly premium',
        amount: 320.00,
        isIncoming: false,
        timestamp: '9:00AM',
        icon: 'health',
        category: 'health',
      },
      {
        id: generateId(),
        merchant: 'Electricity Bill',
        message: 'Monthly utility',
        amount: 142.78,
        isIncoming: false,
        timestamp: '8:45AM',
        icon: 'utilities',
        category: 'utilities',
      }
    ],
  }
];

// YEARLY TRANSACTIONS - For "Year" filter view (summarized by month)
export const yearlyTransactions: TransactionDateGroup[] = [
  {
    date: 'APRIL 2025',
    transactions: [
      {
        id: generateId(),
        merchant: 'Monthly Summary',
        message: '47 transactions',
        amount: 7856.32,
        isIncoming: false,
        timestamp: '',
        icon: 'insights',
        category: 'summary',
      }
    ],
  },
  {
    date: 'MARCH 2025',
    transactions: [
      {
        id: generateId(),
        merchant: 'Monthly Summary',
        message: '52 transactions',
        amount: 8123.45,
        isIncoming: false,
        timestamp: '',
        icon: 'insights',
        category: 'summary',
      }
    ],
  },
  {
    date: 'FEBRUARY 2025',
    transactions: [
      {
        id: generateId(),
        merchant: 'Monthly Summary',
        message: '39 transactions',
        amount: 6387.21,
        isIncoming: false,
        timestamp: '',
        icon: 'insights',
        category: 'summary',
      }
    ],
  },
  {
    date: 'JANUARY 2025',
    transactions: [
      {
        id: generateId(),
        merchant: 'Monthly Summary',
        message: '43 transactions',
        amount: 7123.90,
        isIncoming: false,
        timestamp: '',
        icon: 'insights',
        category: 'summary',
      }
    ],
  },
  {
    date: 'DECEMBER 2024',
    transactions: [
      {
        id: generateId(),
        merchant: 'Monthly Summary',
        message: '58 transactions',
        amount: 9842.76,
        isIncoming: false,
        timestamp: '',
        icon: 'insights',
        category: 'summary',
      }
    ],
  },
  {
    date: 'NOVEMBER 2024',
    transactions: [
      {
        id: generateId(),
        merchant: 'Monthly Summary',
        message: '45 transactions',
        amount: 7432.18,
        isIncoming: false,
        timestamp: '',
        icon: 'insights',
        category: 'summary',
      }
    ],
  }
];

// Default transactions (monthly view)
export const transactions = monthlyTransactions;

// Function to get transactions based on period
export const getTransactionsByPeriod = (period: string): TransactionDateGroup[] => {
  switch (period) {
    case 'day':
      return dailyTransactions;
    case 'week':
      return weeklyTransactions;
    case 'year':
      return yearlyTransactions;
    case 'month':
    default:
      return monthlyTransactions;
  }
};

// Default getter function - returns monthly data
export const getTransactions = (): TransactionDateGroup[] => {
  return monthlyTransactions;
};



==== File: lib\hooks\useBankingData.tsx ====
'use client';

/**
 * NOTE: This hook requires the SWR package to be installed.
 * Before using this hook, install SWR with:
 * 
 * npm install swr
 * 
 * or
 * 
 * yarn add swr
 */

import { useState, useEffect } from 'react';
import useSWR, { SWRConfiguration } from 'swr';
import { useUser } from '@/components/context/UserContext';
import { BankingUser, BankingAccount, BankingCreditCard, BankingLoan, TransactionDateGroup } from '@/lib/types';

// Define the shape of the user-specific banking data
interface UserBankingData {
  user: BankingUser | undefined;
  accounts: BankingAccount[];
  creditCards: BankingCreditCard[];
  loans: BankingLoan[];
  transactions: any;
  groupedTransactions: TransactionDateGroup[];
  categoryTotals?: Record<string, number>;
}

// Define the options for the hook
interface UseBankingDataOptions extends SWRConfiguration {
  shouldFetch?: boolean;
  mockDelay?: number;
}

/**
 * Custom hook for fetching banking data with SWR
 * 
 * This hook provides optimized data fetching with caching, revalidation,
 * error handling, and loading states.
 */
export const useBankingData = (options: UseBankingDataOptions = {}) => {
  const { shouldFetch = true, mockDelay = 0, ...swrOptions } = options;
  
  // Get user context
  const { selectedUserId, isNewUser } = useUser();
  
  // Define the API endpoint based on the selected user
  const apiEndpoint = selectedUserId 
    ? `/api/banking-data/${selectedUserId}` 
    : '/api/banking-data';
  
  // Mock fetcher function (in a real app, this would be a real API call)
  const fetcher = async (url: string) => {
    // Simulate API delay if needed
    if (mockDelay > 0) {
      await new Promise(resolve => setTimeout(resolve, mockDelay));
    }
    
    // In a real app, this would be a fetch call to the API
    // For now, we'll simulate it by getting data from localStorage
    const cachedData = localStorage.getItem('members1stBankingData');
    
    if (!cachedData) {
      throw new Error('No banking data found');
    }
    
    const bankingData = JSON.parse(cachedData);
    
    // If a specific user is selected, filter the data
    if (selectedUserId && selectedUserId !== 'new') {
      const user = bankingData.users.find((u: any) => u.id === selectedUserId);
      const accounts = bankingData.accounts.filter((a: any) => a.userId === selectedUserId);
      const creditCards = bankingData.creditCards.filter((c: any) => c.userId === selectedUserId);
      const loans = bankingData.loans.filter((l: any) => l.userId === selectedUserId);
      const transactions = bankingData.transactions[selectedUserId] || {};
      const groupedTransactions = bankingData.groupedTransactions[selectedUserId] || [];
      const categoryTotals = bankingData.categoryTotals?.[selectedUserId] || {};
      
      return {
        user,
        accounts,
        creditCards,
        loans,
        transactions,
        groupedTransactions,
        categoryTotals
      };
    }
    
    // If no user is selected, return all data
    return bankingData;
  };
  
  // Use SWR for data fetching
  const { 
    data, 
    error, 
    isLoading, 
    isValidating, 
    mutate 
  } = useSWR<any>(
    shouldFetch ? apiEndpoint : null, 
    fetcher,
    {
      revalidateOnFocus: false,
      revalidateOnReconnect: false,
      dedupingInterval: 60000, // 1 minute
      ...swrOptions
    }
  );
  
  // Process data for new user
  const [userData, setUserData] = useState<UserBankingData | null>(null);
  
  useEffect(() => {
    if (isNewUser) {
      // For new user flow, provide empty data structure
      setUserData({
        user: undefined,
        accounts: [],
        creditCards: [],
        loans: [],
        transactions: {},
        groupedTransactions: []
      });
    } else if (data) {
      // If we have data from SWR, use it
      if (selectedUserId) {
        // If a user is selected, the data is already filtered
        setUserData(data as UserBankingData);
      } else {
        // If no user is selected, provide full data
        setUserData({
          user: undefined,
          accounts: data.accounts || [],
          creditCards: data.creditCards || [],
          loans: data.loans || [],
          transactions: data.transactions || {},
          groupedTransactions: []
        });
      }
    } else {
      // If no data yet, set to null
      setUserData(null);
    }
  }, [data, selectedUserId, isNewUser]);
  
  // Function to refresh data
  const refreshData = async () => {
    try {
      await mutate();
    } catch (err) {
      console.error('Error refreshing banking data:', err);
    }
  };
  
  // Function to clear cache
  const clearCache = () => {
    localStorage.removeItem('members1stBankingData');
    mutate();
  };
  
  return {
    // Raw data from SWR
    data,
    
    // Processed user data
    userData,
    
    // Loading and error states
    isLoading,
    isValidating,
    error,
    
    // Functions
    refreshData,
    clearCache,
    mutate
  };
};

export default useBankingData;




==== File: lib\hooks\useContainerPosition.tsx ====
// lib/hooks/useContainerPosition.tsx
'use client';

import { useState, useEffect, useRef, RefObject } from 'react';

interface ContainerPositionOptions {
  referenceRef: RefObject<HTMLElement>; // The element we position relative to
  containerRef: RefObject<HTMLElement>; // The container to position
  bottomOffset?: number; // Space for bottom navigation or other elements
  collapsedRatio?: number; // Ratio of available space for collapsed state
  expandedRatio?: number; // Ratio of available space for expanded state
}

interface ContainerPositionResult {
  collapsedHeight: number;
  expandedHeight: number;
  isCalculated: boolean;
  updatePosition: () => void;
}

export function useContainerPosition({
  referenceRef,
  containerRef,
  bottomOffset = 80,
  collapsedRatio = 0.7,
  expandedRatio = 0.9,
}: ContainerPositionOptions): ContainerPositionResult {
  const [collapsedHeight, setCollapsedHeight] = useState(0);
  const [expandedHeight, setExpandedHeight] = useState(0);
  const [isCalculated, setIsCalculated] = useState(false);

  // Function to calculate positioning
  const calculatePositioning = () => {
    if (!containerRef.current || !referenceRef.current) return;
    
    // Get the bottom position of the reference element (pay buttons)
    const referenceRect = referenceRef.current.getBoundingClientRect();
    const referenceBottom = referenceRect.bottom;
    
    // Set the top of the container to the bottom of the reference element
    if (containerRef.current) {
      containerRef.current.style.top = `${referenceBottom}px`;
    }
    
    // Update the height of the container
    const viewportHeight = window.innerHeight;
    
    const availableHeight = viewportHeight - referenceBottom - bottomOffset;
    const newCollapsedHeight = Math.min(availableHeight * collapsedRatio, availableHeight);
    const newExpandedHeight = Math.min(availableHeight * expandedRatio, availableHeight);
    
    // Update state
    setCollapsedHeight(newCollapsedHeight);
    setExpandedHeight(newExpandedHeight);
    setIsCalculated(true);
  };

  useEffect(() => {
    // Calculate on mount and when window is resized
    calculatePositioning();
    window.addEventListener('resize', calculatePositioning);
    
    // Also observe the reference element for any changes in height/position
    if (referenceRef.current) {
      const observer = new ResizeObserver(calculatePositioning);
      observer.observe(referenceRef.current);
      
      return () => {
        observer.disconnect();
        window.removeEventListener('resize', calculatePositioning);
      };
    }
    
    return () => window.removeEventListener('resize', calculatePositioning);
  }, [referenceRef, containerRef]);

  return {
    collapsedHeight,
    expandedHeight,
    isCalculated,
    updatePosition: calculatePositioning
  };
}

export default useContainerPosition;



==== File: lib\hooks\useTransactionData.tsx ====
'use client';

import { useState, useEffect } from 'react';
import { useBankingData } from '@/components/context/UnifiedBankingDataProvider';
import { getTransactionsByPeriod } from '@/lib/data/transactions';
import { TransactionDateGroup, TransactionType } from '@/lib/types';

interface UseTransactionDataOptions {
  initialPeriod?: string;
  filterByCategory?: string | string[];
  filterByMerchant?: string | string[];
  filterByAmount?: {
    min?: number;
    max?: number;
  };
  sortBy?: 'date' | 'amount' | 'merchant';
  sortDirection?: 'asc' | 'desc';
  limit?: number;
}

interface UseTransactionDataResult {
  transactionGroups: TransactionDateGroup[];
  selectedPeriod: string;
  setSelectedPeriod: (period: string) => void;
  isLoading: boolean;
  error: Error | null;
  totalSpent: number;
  totalIncoming: number;
  netAmount: number;
  filterTransactions: (options: Partial<UseTransactionDataOptions>) => void;
  resetFilters: () => void;
}

/**
 * Custom hook for managing transaction data
 * 
 * This hook encapsulates the logic for fetching, filtering, and sorting transaction data
 */
export const useTransactionData = (options: UseTransactionDataOptions = {}): UseTransactionDataResult => {
  // Default options
  const {
    initialPeriod = 'month',
    filterByCategory = [],
    filterByMerchant = [],
    filterByAmount = {},
    sortBy = 'date',
    sortDirection = 'desc',
    limit
  } = options;

  // State
  const [selectedPeriod, setSelectedPeriod] = useState<string>(initialPeriod);
  const [transactionGroups, setTransactionGroups] = useState<TransactionDateGroup[]>([]);
  const [filteredGroups, setFilteredGroups] = useState<TransactionDateGroup[]>([]);
  const [filterOptions, setFilterOptions] = useState({
    categories: Array.isArray(filterByCategory) ? filterByCategory : [filterByCategory].filter(Boolean),
    merchants: Array.isArray(filterByMerchant) ? filterByMerchant : [filterByMerchant].filter(Boolean),
    amount: filterByAmount,
    sortBy,
    sortDirection,
    limit
  });
  const [totalSpent, setTotalSpent] = useState(0);
  const [totalIncoming, setTotalIncoming] = useState(0);
  const [error, setError] = useState<Error | null>(null);

  // Get banking data
  const { userData, isLoading: isBankingDataLoading } = useBankingData();

  // Update transactions when period changes
  useEffect(() => {
    try {
      // If banking data is available, try to use it first
      if (userData && userData.groupedTransactions && userData.groupedTransactions.length > 0) {
        setTransactionGroups(userData.groupedTransactions);
      } else {
        // Fall back to predefined transactions
        const updatedTransactions = getTransactionsByPeriod(selectedPeriod);
        setTransactionGroups(updatedTransactions);
      }
    } catch (err) {
      console.error('Error loading transaction data:', err);
      setError(err instanceof Error ? err : new Error('Unknown error loading transaction data'));
    }
  }, [selectedPeriod, userData]);

  // Apply filters when transaction groups or filter options change
  useEffect(() => {
    if (transactionGroups.length === 0) return;

    try {
      // Create a deep copy to avoid mutating the original data
      const groupsCopy = JSON.parse(JSON.stringify(transactionGroups)) as TransactionDateGroup[];

      // Apply filters to each group's transactions
      const filtered = groupsCopy.map(group => {
        let transactions = [...group.transactions];

        // Filter by category
        if (filterOptions.categories.length > 0) {
          transactions = transactions.filter(tx => 
            filterOptions.categories.includes(tx.category || '')
          );
        }

        // Filter by merchant
        if (filterOptions.merchants.length > 0) {
          transactions = transactions.filter(tx => 
            filterOptions.merchants.includes(tx.merchant)
          );
        }

        // Filter by amount
        if (filterOptions.amount.min !== undefined || filterOptions.amount.max !== undefined) {
          transactions = transactions.filter(tx => {
            const { min, max } = filterOptions.amount;
            if (min !== undefined && tx.amount < min) return false;
            if (max !== undefined && tx.amount > max) return false;
            return true;
          });
        }

        // Sort transactions
        if (filterOptions.sortBy) {
          transactions.sort((a, b) => {
            let comparison = 0;

            switch (filterOptions.sortBy) {
              case 'date':
                // For date, we use the timestamp
                comparison = a.timestamp.localeCompare(b.timestamp);
                break;
              case 'amount':
                comparison = a.amount - b.amount;
                break;
              case 'merchant':
                comparison = a.merchant.localeCompare(b.merchant);
                break;
            }

            // Apply sort direction
            return filterOptions.sortDirection === 'asc' ? comparison : -comparison;
          });
        }

        // Apply limit if specified
        if (filterOptions.limit && transactions.length > filterOptions.limit) {
          transactions = transactions.slice(0, filterOptions.limit);
        }

        return {
          ...group,
          transactions
        };
      });

      // Remove empty groups
      const nonEmptyGroups = filtered.filter(group => group.transactions.length > 0);

      // Calculate totals
      let spent = 0;
      let incoming = 0;

      nonEmptyGroups.forEach(group => {
        group.transactions.forEach(tx => {
          if (tx.isIncoming) {
            incoming += tx.amount;
          } else {
            spent += tx.amount;
          }
        });
      });

      setTotalSpent(spent);
      setTotalIncoming(incoming);
      setFilteredGroups(nonEmptyGroups);
    } catch (err) {
      console.error('Error filtering transaction data:', err);
      setError(err instanceof Error ? err : new Error('Unknown error filtering transaction data'));
    }
  }, [transactionGroups, filterOptions]);

  // Function to update filter options
  const filterTransactions = (newOptions: Partial<UseTransactionDataOptions>) => {
    setFilterOptions(prev => ({
      ...prev,
      categories: newOptions.filterByCategory 
        ? (Array.isArray(newOptions.filterByCategory) 
            ? newOptions.filterByCategory 
            : [newOptions.filterByCategory].filter(Boolean))
        : prev.categories,
      merchants: newOptions.filterByMerchant
        ? (Array.isArray(newOptions.filterByMerchant)
            ? newOptions.filterByMerchant
            : [newOptions.filterByMerchant].filter(Boolean))
        : prev.merchants,
      amount: newOptions.filterByAmount || prev.amount,
      sortBy: newOptions.sortBy || prev.sortBy,
      sortDirection: newOptions.sortDirection || prev.sortDirection,
      limit: newOptions.limit !== undefined ? newOptions.limit : prev.limit
    }));
  };

  // Function to reset filters
  const resetFilters = () => {
    setFilterOptions({
      categories: [],
      merchants: [],
      amount: {},
      sortBy: 'date',
      sortDirection: 'desc',
      limit: undefined
    });
  };

  return {
    transactionGroups: filteredGroups,
    selectedPeriod,
    setSelectedPeriod,
    isLoading: isBankingDataLoading,
    error,
    totalSpent,
    totalIncoming,
    netAmount: totalIncoming - totalSpent,
    filterTransactions,
    resetFilters
  };
};

export default useTransactionData;




==== File: lib\styles\theme.ts ====
/**
 * Banking App Theme Configuration
 * 
 * This file contains the theme configuration for the banking app.
 * It provides a centralized place for defining colors, spacing, typography, and other design tokens.
 * Using this theme ensures consistency across the application and makes it easier to update the design.
 */

export const theme = {
  /**
   * Color palette
   * 
   * The color system is organized into:
   * - base colors: primary brand colors
   * - semantic colors: colors with specific meanings (success, error, etc.)
   * - neutral colors: grays used for text, backgrounds, etc.
   * - component colors: specific colors for components
   */
  colors: {
    // Base colors
    primary: {
      main: '#7b2528', // Red color used for cards
      light: '#a13236',
      dark: '#5e1d1f',
      contrast: '#ffffff'
    },
    secondary: {
      main: '#333333', // Dark gray used for cards
      light: '#4d4d4d',
      dark: '#262626',
      contrast: '#ffffff'
    },
    
    // Semantic colors
    success: {
      main: '#4ade80', // Green for positive amounts
      light: '#86efac',
      dark: '#22c55e',
      contrast: '#ffffff'
    },
    error: {
      main: '#f87171', // Red for negative amounts
      light: '#fca5a5',
      dark: '#ef4444',
      contrast: '#ffffff'
    },
    warning: {
      main: '#fbbf24', // Yellow for warnings
      light: '#fcd34d',
      dark: '#f59e0b',
      contrast: '#000000'
    },
    info: {
      main: '#60a5fa', // Blue for information
      light: '#93c5fd',
      dark: '#3b82f6',
      contrast: '#ffffff'
    },
    
    // Neutral colors (dark theme)
    background: {
      app: '#121212', // App background (app-black)
      card: '#212121', // Card background
      cardHover: '#333333', // Card hover state
      input: '#1a1a1a', // Input background
      elevated: '#2c2c2c' // Elevated surfaces
    },
    text: {
      primary: '#ffffff', // Primary text
      secondary: '#a0a0a0', // Secondary text
      tertiary: '#6b7280', // Tertiary text
      disabled: '#4b5563' // Disabled text
    },
    border: {
      light: 'rgba(255, 255, 255, 0.1)', // Light border
      medium: 'rgba(255, 255, 255, 0.2)', // Medium border
      dark: 'rgba(255, 255, 255, 0.3)' // Dark border
    },
    
    // Component-specific colors
    components: {
      card: {
        signature: '#7b2528', // Signature card color
        platinum: '#333333' // Platinum card color
      },
      chart: {
        shopping: '#8b5cf6', // Purple
        food: '#f87171', // Red
        entertainment: '#60a5fa', // Blue
        transport: '#fbbf24', // Yellow
        other: '#4ade80' // Green
      },
      iconBackground: '#3b3b3b' // Icon background color
    }
  },
  
  /**
   * Typography
   * 
   * Defines font families, sizes, weights, and line heights
   */
  typography: {
    fontFamily: {
      base: 'Inter, system-ui, sans-serif',
      mono: 'monospace'
    },
    fontSize: {
      xs: '0.75rem', // 12px
      sm: '0.875rem', // 14px
      base: '1rem', // 16px
      lg: '1.125rem', // 18px
      xl: '1.25rem', // 20px
      '2xl': '1.5rem', // 24px
      '3xl': '1.875rem', // 30px
      '4xl': '2.25rem', // 36px
    },
    fontWeight: {
      light: 300,
      normal: 400,
      medium: 500,
      semibold: 600,
      bold: 700
    },
    lineHeight: {
      none: 1,
      tight: 1.25,
      normal: 1.5,
      relaxed: 1.75
    }
  },
  
  /**
   * Spacing
   * 
   * Defines spacing values for margins, paddings, and gaps
   */
  spacing: {
    0: '0',
    0.5: '0.125rem', // 2px
    1: '0.25rem', // 4px
    1.5: '0.375rem', // 6px
    2: '0.5rem', // 8px
    2.5: '0.625rem', // 10px
    3: '0.75rem', // 12px
    3.5: '0.875rem', // 14px
    4: '1rem', // 16px
    5: '1.25rem', // 20px
    6: '1.5rem', // 24px
    7: '1.75rem', // 28px
    8: '2rem', // 32px
    9: '2.25rem', // 36px
    10: '2.5rem', // 40px
    11: '2.75rem', // 44px
    12: '3rem', // 48px
    14: '3.5rem', // 56px
    16: '4rem', // 64px
    20: '5rem', // 80px
    24: '6rem', // 96px
    28: '7rem', // 112px
    32: '8rem', // 128px
    36: '9rem', // 144px
    40: '10rem', // 160px
    44: '11rem', // 176px
    48: '12rem', // 192px
    52: '13rem', // 208px
    56: '14rem', // 224px
    60: '15rem', // 240px
    64: '16rem', // 256px
    72: '18rem', // 288px
    80: '20rem', // 320px
    96: '24rem' // 384px
  },
  
  /**
   * Border radius
   * 
   * Defines border radius values for rounded corners
   */
  borderRadius: {
    none: '0',
    sm: '0.125rem', // 2px
    md: '0.25rem', // 4px
    lg: '0.5rem', // 8px
    xl: '0.75rem', // 12px
    '2xl': '1rem', // 16px
    '3xl': '1.5rem', // 24px
    full: '9999px'
  },
  
  /**
   * Shadows
   * 
   * Defines box shadow values
   */
  shadows: {
    none: 'none',
    sm: '0 1px 2px 0 rgba(0, 0, 0, 0.05)',
    md: '0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)',
    lg: '0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)',
    xl: '0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)',
    '2xl': '0 25px 50px -12px rgba(0, 0, 0, 0.25)',
    inner: 'inset 0 2px 4px 0 rgba(0, 0, 0, 0.06)'
  },
  
  /**
   * Z-index
   * 
   * Defines z-index values for layering
   */
  zIndex: {
    0: 0,
    10: 10,
    20: 20,
    30: 30,
    40: 40,
    50: 50, // Default
    60: 60,
    70: 70,
    80: 80,
    90: 90,
    100: 100, // Dropdowns
    110: 110,
    120: 120,
    130: 130,
    140: 140,
    150: 150, // Modals/dialogs
    160: 160,
    170: 170,
    180: 180,
    190: 190,
    200: 200, // Toasts/notifications
    auto: 'auto'
  },
  
  /**
   * Transitions
   * 
   * Defines transition properties
   */
  transitions: {
    duration: {
      fastest: '50ms',
      faster: '100ms',
      fast: '150ms',
      normal: '200ms',
      slow: '300ms',
      slower: '400ms',
      slowest: '500ms'
    },
    timing: {
      ease: 'ease',
      linear: 'linear',
      easeIn: 'ease-in',
      easeOut: 'ease-out',
      easeInOut: 'ease-in-out'
    }
  },
  
  /**
   * Breakpoints
   * 
   * Defines screen size breakpoints for responsive design
   */
  breakpoints: {
    xs: '0px',
    sm: '640px',
    md: '768px',
    lg: '1024px',
    xl: '1280px',
    '2xl': '1536px'
  }
};

/**
 * Helper function to get a value from the theme
 * 
 * @param path - The path to the value in the theme object
 * @returns The value at the specified path
 * 
 * @example
 * // Get the primary color
 * const primaryColor = getThemeValue('colors.primary.main');
 */
export const getThemeValue = (path: string): any => {
  return path.split('.').reduce((obj, key) => obj && obj[key], theme as any);
};

export default theme;




==== File: lib\types\index.ts ====
// lib/types/index.ts
export type CardType = {
  id: string;
  type: 'VISA' | 'MASTERCARD' | 'AMEX';
  number: string;
  expiry: string;
  cvv: string;
  color: string;
};

export type TransactionType = {
  id: string;
  merchant: string;
  location?: string;
  amount: number;
  isIncoming: boolean;
  timestamp: string;
  message?: string;
  icon: string;
  category?: string;
};

export type TransactionDateGroup = {
  date: 'TODAY' | 'YESTERDAY' | string;
  transactions: TransactionType[];
};

export type NavItemType = {
  name: string;
  icon: string;
  href: string;
};

// Add banking data types
export type BankingUser = {
  id: string;
  name: string;
  username: string;
  email: string;
  avatar: string;
  phone: string;
  address: string;
  ssn: string;
  dob: string;
  occupation: string;
  income: number;
  joinDate: string;
  lastLogin: string;
};

export type BankingAccount = {
  id: string;
  userId: string;
  type: string;
  name: string;
  accountNumber: string;
  routingNumber: string;
  balance: number;
  availableBalance?: number;
  pendingTransactions?: number;
  interestRate: number;
  openDate: string;
  maturityDate?: string;
};

export type BankingCreditCard = {
  id: string;
  userId: string;
  type: string;
  name: string;
  cardNumber: string;
  expiry: string;
  cvv: string;
  creditLimit: number;
  currentBalance: number;
  availableCredit: number;
  dueDate: string;
  minimumPayment: number;
  rewardsBalance: number;
  rewardsType: string;
  rewardsRate: string;
  applyDate: string;
  color: string;
};

export type BankingLoan = {
  id: string;
  userId: string;
  type: string;
  name: string;
  loanNumber: string;
  originalAmount: number;
  currentBalance: number;
  interestRate: number;
  monthlyPayment: number;
  originationDate: string;
  term: number;
  nextPaymentDate: string;
  paymentsMade: number;
  paymentsRemaining: number;
  availableCredit?: number;
  propertyAddress?: string;
  vehicle?: string;
  vin?: string;
};

export type BankingTransaction = {
  id: string;
  userId: string;
  accountId: string;
  date: string;
  merchant: string;
  category: string;
  icon: string;
  amount: number;
  isIncoming: boolean;
  status: string;
  location?: string;
  message?: string;
  timestamp: string;
};

export type BankingDataType = {
  users: BankingUser[];
  accounts: BankingAccount[];
  creditCards: BankingCreditCard[];
  loans: BankingLoan[];
  transactions: {
    [userId: string]: {
      [accountId: string]: BankingTransaction[];
    };
  };
  groupedTransactions: {
    [userId: string]: TransactionDateGroup[];
  };
};




==== File: lib\utils\appInit.ts ====
// lib/utils/appInit.ts
// Import this file in your _app.tsx to initialize app-wide features

import { useEffect } from 'react';

/**
 * Initialize application-wide features
 * Place in _app.tsx component
 */
export const useAppInitialization = () => {
  useEffect(() => {
    // Only run on client-side
    if (typeof window !== 'undefined') {
      console.log('?? Initializing app features...');
      
      // Initialize banking data if not already loaded
      if (!localStorage.getItem('members1stBankingData')) {
        console.log('?? Initializing banking data...');
        // Will be handled by the BankingDataProvider
      }
      
      // Initialize PWA features if in standalone mode
      if (window.matchMedia('(display-mode: standalone)').matches || 
          (window.navigator as any).standalone) {
        console.log('?? Running in PWA mode');
        // Additional PWA-specific initializations
      }
      
      console.log('? App initialization complete!');
    }
  }, []);
  
  // No return value needed for this hook
  return null;
};

export default useAppInitialization;




==== File: lib\utils\iosFullscreen.ts ====
// Add this to a new file: lib/utils/iosFullscreen.ts

export const setupIOSFullscreen = () => {
    // Only run on iOS devices
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !(window as any).MSStream;
    
    if (!isIOS) return;
    
    // Function to handle fullscreen
    const goFullScreen = () => {
      // For iOS, we need to scroll slightly to hide the address bar
      window.scrollTo(0, 1);
    };
    
    // Add scroll event listener to hide address bar when scrolling
    window.addEventListener('scroll', () => {
      if (window.scrollY > 0) {
        document.body.classList.add('ios-scrolled');
      } else {
        document.body.classList.remove('ios-scrolled');
      }
    });
    
    // Try to hide address bar when page loads and after orientation changes
    window.addEventListener('load', goFullScreen);
    window.addEventListener('orientationchange', goFullScreen);
    window.addEventListener('resize', goFullScreen);
    
    // Try immediately and after a short delay
    goFullScreen();
    setTimeout(goFullScreen, 100);
    setTimeout(goFullScreen, 500); // iOS sometimes needs a longer delay
  };



==== File: lib\utils\IOSFullScreenProvider.tsx ====
'use client';

import React, { ReactNode } from 'react';
import IOSFullScreen from '@/components/IOSFullScreen';

interface IOSFullScreenProviderProps {
  children: ReactNode;
}

/**
 * Wrapper component that includes the IOSFullScreen component
 * This helps prevent unnecessary re-renders when IOSFullScreen changes
 */
const IOSFullScreenProvider: React.FC<IOSFullScreenProviderProps> = ({ children }) => {
  return (
    <>
      <IOSFullScreen />
      {children}
    </>
  );
};

export default IOSFullScreenProvider;




==== File: pages\404.tsx ====
import { NextPage } from 'next'
import Head from 'next/head'

const NotFoundPage: NextPage = () => {
  return (
    <>
      <Head>
        <title>404 - Page Not Found</title>
      </Head>
      <div className="flex flex-col items-center justify-center min-h-screen">
        <h1 className="text-4xl font-bold">404</h1>
        <p className="mt-4 text-xl">Page not found</p>
      </div>
    </>
  )
}

export default NotFoundPage




==== File: pages\500.tsx ====
import { NextPage } from 'next'
import Head from 'next/head'

const ServerErrorPage: NextPage = () => {
  return (
    <>
      <Head>
        <title>500 - Server Error</title>
      </Head>
      <div className="flex flex-col items-center justify-center min-h-screen">
        <h1 className="text-4xl font-bold">500</h1>
        <p className="mt-4 text-xl">Server-side error occurred</p>
      </div>
    </>
  )
}

export default ServerErrorPage




==== File: pages\_app.tsx ====
// pages/_app.tsx
import React, { useState, useEffect } from 'react';
import type { AppProps } from 'next/app';
import { BankingDataProvider } from '@/components/preloaders/BankingDataPreloader';
import CompleteBankingPreloader from '@/components/preloaders/CompleteBankingPreloader';
import { useAppInitialization } from '@/lib/utils/appInit';

export default function App({ Component, pageProps }: AppProps) {
  const [isPreloaded, setIsPreloaded] = useState(false);
  
  // Initialize app features
  useAppInitialization();
  
  // Skip preloading in development mode for faster refreshes
  useEffect(() => {
    if (process.env.NODE_ENV === 'development') {
      setIsPreloaded(true);
    }
  }, []);

  return (
    <BankingDataProvider>
      {process.env.NODE_ENV === 'development' || isPreloaded ? (
        <Component {...pageProps} />
      ) : (
        <CompleteBankingPreloader onComplete={() => setIsPreloaded(true)}>
          <Component {...pageProps} />
        </CompleteBankingPreloader>
      )}
    </BankingDataProvider>
  );
}




==== File: pages\_document.tsx ====
import { Html, Head, Main, NextScript } from 'next/document';

export default function Document() {
  return (
    <Html lang="en">
      <Head>
        {/* PWA meta tags */}
        <meta name="application-name" content="Banking App" />
        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
        <meta name="apple-mobile-web-app-title" content="Banking App" />
        <meta name="mobile-web-app-capable" content="yes" />
        <meta name="msapplication-TileColor" content="#121212" />
        <meta name="msapplication-tap-highlight" content="no" />
        <meta name="theme-color" content="#121212" />
        
        {/* iOS splash screens */}
        <link rel="apple-touch-startup-image" href="/icons/apple-splash-2048-2732.jpg" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)" />
        <link rel="apple-touch-startup-image" href="/icons/apple-splash-1668-2388.jpg" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)" />
        <link rel="apple-touch-startup-image" href="/icons/apple-splash-1536-2048.jpg" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)" />
        <link rel="apple-touch-startup-image" href="/icons/apple-splash-1668-2224.jpg" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)" />
        <link rel="apple-touch-startup-image" href="/icons/apple-splash-1620-2160.jpg" media="(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)" />
        <link rel="apple-touch-startup-image" href="/icons/apple-splash-1284-2778.jpg" media="(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)" />
        <link rel="apple-touch-startup-image" href="/icons/apple-splash-1170-2532.jpg" media="(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)" />
        <link rel="apple-touch-startup-image" href="/icons/apple-splash-1125-2436.jpg" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)" />
        <link rel="apple-touch-startup-image" href="/icons/apple-splash-1242-2688.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)" />
        <link rel="apple-touch-startup-image" href="/icons/apple-splash-828-1792.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)" />
        <link rel="apple-touch-startup-image" href="/icons/apple-splash-1242-2208.jpg" media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)" />
        <link rel="apple-touch-startup-image" href="/icons/apple-splash-750-1334.jpg" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)" />
        <link rel="apple-touch-startup-image" href="/icons/apple-splash-640-1136.jpg" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)" />
      </Head>
      <body>
        <Main />
        <NextScript />
      </body>
    </Html>
  );
}



==== File: public\fix-service-worker.js ====
// public/fix-service-worker.js
/**
 * This script helps fix service worker issues by:
 * 1. Unregistering any existing service workers
 * 2. Clearing caches that might contain stale service worker data
 */

async function fixServiceWorker() {
  console.log('🔧 Starting service worker fix...');
  
  // Unregister all service workers
  if ('serviceWorker' in navigator) {
    console.log('Unregistering service workers...');
    const registrations = await navigator.serviceWorker.getRegistrations();
    
    if (registrations.length === 0) {
      console.log('No service workers found to unregister.');
    } else {
      for (const registration of registrations) {
        await registration.unregister();
        console.log(`Service worker at ${registration.scope} unregistered.`);
      }
    }
  } else {
    console.log('Service Worker API not supported in this browser.');
  }
  
  // Clear caches
  if ('caches' in window) {
    console.log('Clearing caches...');
    try {
      const cacheNames = await caches.keys();
      
      if (cacheNames.length === 0) {
        console.log('No caches found to clear.');
      } else {
        await Promise.all(
          cacheNames.map(cacheName => {
            console.log(`Deleting cache: ${cacheName}`);
            return caches.delete(cacheName);
          })
        );
        console.log('All caches cleared successfully.');
      }
    } catch (error) {
      console.error('Error clearing caches:', error);
    }
  } else {
    console.log('Cache API not supported in this browser.');
  }
  
  console.log('✅ Service worker fix completed!');
  console.log('🔄 Forcing service worker update...');
  
  // Force a fresh service worker registration
  if ('serviceWorker' in navigator) {
    const registration = await navigator.serviceWorker.register('/sw.js');
    await registration.update();
    console.log('Service worker forcefully updated');
  }
  
  console.log('🔄 Please manually refresh the page to complete the update');
}

// Run the fix
fixServiceWorker().catch(error => {
  console.error('Error during service worker fix:', error);
});




==== File: public\sw-register.js ====
// This script registers the service worker for PWA functionality
if ('serviceWorker' in navigator) {
  window.addEventListener('load', async function() {
    try {
      // Register the service worker
      const registration = await navigator.serviceWorker.register('/sw.js', {
        scope: '/'
      });
      console.log('✅ Service Worker registered successfully:', registration.scope);
      
      // Check if the service worker is controlling the page
      if (!navigator.serviceWorker.controller) {
        console.log('Loading fresh service worker controller...');
      }
      
      // Handle service worker updates
      registration.addEventListener('updatefound', () => {
        const newWorker = registration.installing;
        console.log('Service Worker update found!');
        
        newWorker.addEventListener('statechange', () => {
          console.log('Service Worker state changed:', newWorker.state);
        });
      });
      
      // Check for updates every hour
      setInterval(() => {
        registration.update();
        console.log('Checking for Service Worker updates...');
      }, 60 * 60 * 1000);
      
    } catch (err) {
      console.error('❌ Service Worker registration failed:', err);
    }
  });
  
  // Listen for controlling service worker changes
  navigator.serviceWorker.addEventListener('controllerchange', () => {
    console.log('Service Worker controller changed!');
  });
  
  // Log when beforeinstallprompt is fired or prevented
  window.addEventListener('beforeinstallprompt', (e) => {
    console.log('beforeinstallprompt event fired');
  });
  
  // Log when the app is installed
  window.addEventListener('appinstalled', (e) => {
    console.log('App was installed', e);
  });
}




==== File: public\sw.js ====
/**
 * Copyright 2018 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// If the loader is already loaded, just stop.
if (!self.define) {
  let registry = {};

  // Used for `eval` and `importScripts` where we can't get script URL by other means.
  // In both cases, it's safe to use a global var because those functions are synchronous.
  let nextDefineUri;

  const singleRequire = (uri, parentUri) => {
    uri = new URL(uri + ".js", parentUri).href;
    return registry[uri] || (
      
        new Promise(resolve => {
          if ("document" in self) {
            const script = document.createElement("script");
            script.src = uri;
            script.onload = resolve;
            document.head.appendChild(script);
          } else {
            nextDefineUri = uri;
            importScripts(uri);
            resolve();
          }
        })
      
      .then(() => {
        let promise = registry[uri];
        if (!promise) {
          throw new Error(`Module ${uri} didn’t register its module`);
        }
        return promise;
      })
    );
  };

  self.define = (depsNames, factory) => {
    const uri = nextDefineUri || ("document" in self ? document.currentScript.src : "") || location.href;
    if (registry[uri]) {
      // Module is already loading or loaded.
      return;
    }
    let exports = {};
    const require = depUri => singleRequire(depUri, uri);
    const specialDeps = {
      module: { uri },
      exports,
      require
    };
    registry[uri] = Promise.all(depsNames.map(
      depName => specialDeps[depName] || require(depName)
    )).then(deps => {
      factory(...deps);
      return exports;
    });
  };
}
define(['./workbox-e43f5367'], (function (workbox) { 'use strict';

  importScripts();
  self.skipWaiting();
  workbox.clientsClaim();
  workbox.registerRoute("/", new workbox.NetworkFirst({
    "cacheName": "start-url",
    plugins: [{
      cacheWillUpdate: async ({
        request,
        response,
        event,
        state
      }) => {
        if (response && response.type === 'opaqueredirect') {
          return new Response(response.body, {
            status: 200,
            statusText: 'OK',
            headers: response.headers
          });
        }
        return response;
      }
    }]
  }), 'GET');
  workbox.registerRoute(/.*/i, new workbox.NetworkOnly({
    "cacheName": "dev",
    plugins: []
  }), 'GET');

}));
//# sourceMappingURL=sw.js.map




==== File: public\test-nav.html ====
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Navigation Test Page</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #121212;
            color: white;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        header {
            background-color: #1e1e1e;
            padding: 1rem;
            text-align: center;
        }
        main {
            flex: 1;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .test-container {
            max-width: 600px;
            width: 100%;
            background-color: #2a2a2a;
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 2rem;
        }
        h1 {
            margin-top: 0;
        }
        button {
            background-color: #0070f3;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            margin: 0.5rem;
        }
        button:hover {
            background-color: #0051a8;
        }
        .cache-info {
            margin-top: 2rem;
            padding: 1rem;
            background-color: #333;
            border-radius: 8px;
        }
        .timestamp {
            font-size: 0.8rem;
            color: #aaa;
            margin-top: 1rem;
        }
        .nav-frame {
            width: 100%;
            max-width: 500px;
            height: 400px;
            border: 2px solid #444;
            border-radius: 8px;
            margin-top: 1rem;
        }
    </style>
</head>
<body>
    <header>
        <h1>Navigation Test Page</h1>
    </header>
    <main>
        <div class="test-container">
            <h2>Test Bottom Navigation</h2>
            <p>This page helps you test the bottom navigation component in isolation and verify that caching is working correctly.</p>
            
            <div>
                <button id="clearCacheBtn">Clear Cache</button>
                <button id="reloadBtn">Reload Page</button>
                <button id="addTimestampBtn">Add Timestamp to URL</button>
            </div>
            
            <div class="cache-info">
                <h3>Cache Status</h3>
                <p>Page loaded at: <span id="loadTime"></span></p>
                <p>Cache-Control header: <span id="cacheControl">Checking...</span></p>
                <p>Service Worker: <span id="serviceWorker">Checking...</span></p>
                <div class="timestamp">
                    URL parameter timestamp: <span id="urlTimestamp">None</span>
                </div>
            </div>
        </div>
        
        <h3>Navigation Component Preview</h3>
        <p>View the app in the frame below to test the navigation:</p>
        <iframe src="/" class="nav-frame" id="navFrame"></iframe>
    </main>

    <script>
        // Set load time
        document.getElementById('loadTime').textContent = new Date().toLocaleTimeString();
        
        // Check URL for timestamp
        const urlParams = new URLSearchParams(window.location.search);
        const timestamp = urlParams.get('t');
        document.getElementById('urlTimestamp').textContent = timestamp || 'None';
        
        // Button handlers
        document.getElementById('clearCacheBtn').addEventListener('click', () => {
            if ('caches' in window) {
                caches.keys().then(cacheNames => {
                    cacheNames.forEach(cacheName => {
                        caches.delete(cacheName);
                    });
                    alert('Browser caches cleared!');
                });
            } else {
                alert('Cache API not supported in this browser');
            }
        });
        
        document.getElementById('reloadBtn').addEventListener('click', () => {
            window.location.reload(true);
        });
        
        document.getElementById('addTimestampBtn').addEventListener('click', () => {
            const newUrl = new URL(window.location.href);
            newUrl.searchParams.set('t', Date.now());
            window.location.href = newUrl.toString();
        });
        
        // Check cache control header
        fetch(window.location.href, { method: 'HEAD' })
            .then(response => {
                const cacheControl = response.headers.get('cache-control');
                document.getElementById('cacheControl').textContent = cacheControl || 'Not set';
            })
            .catch(err => {
                document.getElementById('cacheControl').textContent = 'Error checking: ' + err.message;
            });
            
        // Check service worker
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.getRegistrations()
                .then(registrations => {
                    if (registrations.length > 0) {
                        document.getElementById('serviceWorker').textContent = 'Active (' + registrations.length + ' registered)';
                    } else {
                        document.getElementById('serviceWorker').textContent = 'No active service workers';
                    }
                })
                .catch(err => {
                    document.getElementById('serviceWorker').textContent = 'Error checking: ' + err.message;
                });
        } else {
            document.getElementById('serviceWorker').textContent = 'Not supported in this browser';
        }
        
        // Reload iframe with timestamp to prevent caching
        document.getElementById('navFrame').src = '/?iframe_t=' + Date.now();
    </script>
</body>
</html>




==== File: public\workbox-e43f5367.js ====
define(['exports'], (function (exports) { 'use strict';

    // @ts-ignore
    try {
      self['workbox:core:6.5.4'] && _();
    } catch (e) {}

    /*
      Copyright 2019 Google LLC
      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    const logger = (() => {
      // Don't overwrite this value if it's already set.
      // See https://github.com/GoogleChrome/workbox/pull/2284#issuecomment-560470923
      if (!('__WB_DISABLE_DEV_LOGS' in globalThis)) {
        self.__WB_DISABLE_DEV_LOGS = false;
      }
      let inGroup = false;
      const methodToColorMap = {
        debug: `#7f8c8d`,
        log: `#2ecc71`,
        warn: `#f39c12`,
        error: `#c0392b`,
        groupCollapsed: `#3498db`,
        groupEnd: null // No colored prefix on groupEnd
      };
      const print = function (method, args) {
        if (self.__WB_DISABLE_DEV_LOGS) {
          return;
        }
        if (method === 'groupCollapsed') {
          // Safari doesn't print all console.groupCollapsed() arguments:
          // https://bugs.webkit.org/show_bug.cgi?id=182754
          if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
            console[method](...args);
            return;
          }
        }
        const styles = [`background: ${methodToColorMap[method]}`, `border-radius: 0.5em`, `color: white`, `font-weight: bold`, `padding: 2px 0.5em`];
        // When in a group, the workbox prefix is not displayed.
        const logPrefix = inGroup ? [] : ['%cworkbox', styles.join(';')];
        console[method](...logPrefix, ...args);
        if (method === 'groupCollapsed') {
          inGroup = true;
        }
        if (method === 'groupEnd') {
          inGroup = false;
        }
      };
      // eslint-disable-next-line @typescript-eslint/ban-types
      const api = {};
      const loggerMethods = Object.keys(methodToColorMap);
      for (const key of loggerMethods) {
        const method = key;
        api[method] = (...args) => {
          print(method, args);
        };
      }
      return api;
    })();

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    const messages$1 = {
      'invalid-value': ({
        paramName,
        validValueDescription,
        value
      }) => {
        if (!paramName || !validValueDescription) {
          throw new Error(`Unexpected input to 'invalid-value' error.`);
        }
        return `The '${paramName}' parameter was given a value with an ` + `unexpected value. ${validValueDescription} Received a value of ` + `${JSON.stringify(value)}.`;
      },
      'not-an-array': ({
        moduleName,
        className,
        funcName,
        paramName
      }) => {
        if (!moduleName || !className || !funcName || !paramName) {
          throw new Error(`Unexpected input to 'not-an-array' error.`);
        }
        return `The parameter '${paramName}' passed into ` + `'${moduleName}.${className}.${funcName}()' must be an array.`;
      },
      'incorrect-type': ({
        expectedType,
        paramName,
        moduleName,
        className,
        funcName
      }) => {
        if (!expectedType || !paramName || !moduleName || !funcName) {
          throw new Error(`Unexpected input to 'incorrect-type' error.`);
        }
        const classNameStr = className ? `${className}.` : '';
        return `The parameter '${paramName}' passed into ` + `'${moduleName}.${classNameStr}` + `${funcName}()' must be of type ${expectedType}.`;
      },
      'incorrect-class': ({
        expectedClassName,
        paramName,
        moduleName,
        className,
        funcName,
        isReturnValueProblem
      }) => {
        if (!expectedClassName || !moduleName || !funcName) {
          throw new Error(`Unexpected input to 'incorrect-class' error.`);
        }
        const classNameStr = className ? `${className}.` : '';
        if (isReturnValueProblem) {
          return `The return value from ` + `'${moduleName}.${classNameStr}${funcName}()' ` + `must be an instance of class ${expectedClassName}.`;
        }
        return `The parameter '${paramName}' passed into ` + `'${moduleName}.${classNameStr}${funcName}()' ` + `must be an instance of class ${expectedClassName}.`;
      },
      'missing-a-method': ({
        expectedMethod,
        paramName,
        moduleName,
        className,
        funcName
      }) => {
        if (!expectedMethod || !paramName || !moduleName || !className || !funcName) {
          throw new Error(`Unexpected input to 'missing-a-method' error.`);
        }
        return `${moduleName}.${className}.${funcName}() expected the ` + `'${paramName}' parameter to expose a '${expectedMethod}' method.`;
      },
      'add-to-cache-list-unexpected-type': ({
        entry
      }) => {
        return `An unexpected entry was passed to ` + `'workbox-precaching.PrecacheController.addToCacheList()' The entry ` + `'${JSON.stringify(entry)}' isn't supported. You must supply an array of ` + `strings with one or more characters, objects with a url property or ` + `Request objects.`;
      },
      'add-to-cache-list-conflicting-entries': ({
        firstEntry,
        secondEntry
      }) => {
        if (!firstEntry || !secondEntry) {
          throw new Error(`Unexpected input to ` + `'add-to-cache-list-duplicate-entries' error.`);
        }
        return `Two of the entries passed to ` + `'workbox-precaching.PrecacheController.addToCacheList()' had the URL ` + `${firstEntry} but different revision details. Workbox is ` + `unable to cache and version the asset correctly. Please remove one ` + `of the entries.`;
      },
      'plugin-error-request-will-fetch': ({
        thrownErrorMessage
      }) => {
        if (!thrownErrorMessage) {
          throw new Error(`Unexpected input to ` + `'plugin-error-request-will-fetch', error.`);
        }
        return `An error was thrown by a plugins 'requestWillFetch()' method. ` + `The thrown error message was: '${thrownErrorMessage}'.`;
      },
      'invalid-cache-name': ({
        cacheNameId,
        value
      }) => {
        if (!cacheNameId) {
          throw new Error(`Expected a 'cacheNameId' for error 'invalid-cache-name'`);
        }
        return `You must provide a name containing at least one character for ` + `setCacheDetails({${cacheNameId}: '...'}). Received a value of ` + `'${JSON.stringify(value)}'`;
      },
      'unregister-route-but-not-found-with-method': ({
        method
      }) => {
        if (!method) {
          throw new Error(`Unexpected input to ` + `'unregister-route-but-not-found-with-method' error.`);
        }
        return `The route you're trying to unregister was not  previously ` + `registered for the method type '${method}'.`;
      },
      'unregister-route-route-not-registered': () => {
        return `The route you're trying to unregister was not previously ` + `registered.`;
      },
      'queue-replay-failed': ({
        name
      }) => {
        return `Replaying the background sync queue '${name}' failed.`;
      },
      'duplicate-queue-name': ({
        name
      }) => {
        return `The Queue name '${name}' is already being used. ` + `All instances of backgroundSync.Queue must be given unique names.`;
      },
      'expired-test-without-max-age': ({
        methodName,
        paramName
      }) => {
        return `The '${methodName}()' method can only be used when the ` + `'${paramName}' is used in the constructor.`;
      },
      'unsupported-route-type': ({
        moduleName,
        className,
        funcName,
        paramName
      }) => {
        return `The supplied '${paramName}' parameter was an unsupported type. ` + `Please check the docs for ${moduleName}.${className}.${funcName} for ` + `valid input types.`;
      },
      'not-array-of-class': ({
        value,
        expectedClass,
        moduleName,
        className,
        funcName,
        paramName
      }) => {
        return `The supplied '${paramName}' parameter must be an array of ` + `'${expectedClass}' objects. Received '${JSON.stringify(value)},'. ` + `Please check the call to ${moduleName}.${className}.${funcName}() ` + `to fix the issue.`;
      },
      'max-entries-or-age-required': ({
        moduleName,
        className,
        funcName
      }) => {
        return `You must define either config.maxEntries or config.maxAgeSeconds` + `in ${moduleName}.${className}.${funcName}`;
      },
      'statuses-or-headers-required': ({
        moduleName,
        className,
        funcName
      }) => {
        return `You must define either config.statuses or config.headers` + `in ${moduleName}.${className}.${funcName}`;
      },
      'invalid-string': ({
        moduleName,
        funcName,
        paramName
      }) => {
        if (!paramName || !moduleName || !funcName) {
          throw new Error(`Unexpected input to 'invalid-string' error.`);
        }
        return `When using strings, the '${paramName}' parameter must start with ` + `'http' (for cross-origin matches) or '/' (for same-origin matches). ` + `Please see the docs for ${moduleName}.${funcName}() for ` + `more info.`;
      },
      'channel-name-required': () => {
        return `You must provide a channelName to construct a ` + `BroadcastCacheUpdate instance.`;
      },
      'invalid-responses-are-same-args': () => {
        return `The arguments passed into responsesAreSame() appear to be ` + `invalid. Please ensure valid Responses are used.`;
      },
      'expire-custom-caches-only': () => {
        return `You must provide a 'cacheName' property when using the ` + `expiration plugin with a runtime caching strategy.`;
      },
      'unit-must-be-bytes': ({
        normalizedRangeHeader
      }) => {
        if (!normalizedRangeHeader) {
          throw new Error(`Unexpected input to 'unit-must-be-bytes' error.`);
        }
        return `The 'unit' portion of the Range header must be set to 'bytes'. ` + `The Range header provided was "${normalizedRangeHeader}"`;
      },
      'single-range-only': ({
        normalizedRangeHeader
      }) => {
        if (!normalizedRangeHeader) {
          throw new Error(`Unexpected input to 'single-range-only' error.`);
        }
        return `Multiple ranges are not supported. Please use a  single start ` + `value, and optional end value. The Range header provided was ` + `"${normalizedRangeHeader}"`;
      },
      'invalid-range-values': ({
        normalizedRangeHeader
      }) => {
        if (!normalizedRangeHeader) {
          throw new Error(`Unexpected input to 'invalid-range-values' error.`);
        }
        return `The Range header is missing both start and end values. At least ` + `one of those values is needed. The Range header provided was ` + `"${normalizedRangeHeader}"`;
      },
      'no-range-header': () => {
        return `No Range header was found in the Request provided.`;
      },
      'range-not-satisfiable': ({
        size,
        start,
        end
      }) => {
        return `The start (${start}) and end (${end}) values in the Range are ` + `not satisfiable by the cached response, which is ${size} bytes.`;
      },
      'attempt-to-cache-non-get-request': ({
        url,
        method
      }) => {
        return `Unable to cache '${url}' because it is a '${method}' request and ` + `only 'GET' requests can be cached.`;
      },
      'cache-put-with-no-response': ({
        url
      }) => {
        return `There was an attempt to cache '${url}' but the response was not ` + `defined.`;
      },
      'no-response': ({
        url,
        error
      }) => {
        let message = `The strategy could not generate a response for '${url}'.`;
        if (error) {
          message += ` The underlying error is ${error}.`;
        }
        return message;
      },
      'bad-precaching-response': ({
        url,
        status
      }) => {
        return `The precaching request for '${url}' failed` + (status ? ` with an HTTP status of ${status}.` : `.`);
      },
      'non-precached-url': ({
        url
      }) => {
        return `createHandlerBoundToURL('${url}') was called, but that URL is ` + `not precached. Please pass in a URL that is precached instead.`;
      },
      'add-to-cache-list-conflicting-integrities': ({
        url
      }) => {
        return `Two of the entries passed to ` + `'workbox-precaching.PrecacheController.addToCacheList()' had the URL ` + `${url} with different integrity values. Please remove one of them.`;
      },
      'missing-precache-entry': ({
        cacheName,
        url
      }) => {
        return `Unable to find a precached response in ${cacheName} for ${url}.`;
      },
      'cross-origin-copy-response': ({
        origin
      }) => {
        return `workbox-core.copyResponse() can only be used with same-origin ` + `responses. It was passed a response with origin ${origin}.`;
      },
      'opaque-streams-source': ({
        type
      }) => {
        const message = `One of the workbox-streams sources resulted in an ` + `'${type}' response.`;
        if (type === 'opaqueredirect') {
          return `${message} Please do not use a navigation request that results ` + `in a redirect as a source.`;
        }
        return `${message} Please ensure your sources are CORS-enabled.`;
      }
    };

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    const generatorFunction = (code, details = {}) => {
      const message = messages$1[code];
      if (!message) {
        throw new Error(`Unable to find message for code '${code}'.`);
      }
      return message(details);
    };
    const messageGenerator = generatorFunction;

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * Workbox errors should be thrown with this class.
     * This allows use to ensure the type easily in tests,
     * helps developers identify errors from workbox
     * easily and allows use to optimise error
     * messages correctly.
     *
     * @private
     */
    class WorkboxError extends Error {
      /**
       *
       * @param {string} errorCode The error code that
       * identifies this particular error.
       * @param {Object=} details Any relevant arguments
       * that will help developers identify issues should
       * be added as a key on the context object.
       */
      constructor(errorCode, details) {
        const message = messageGenerator(errorCode, details);
        super(message);
        this.name = errorCode;
        this.details = details;
      }
    }

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /*
     * This method throws if the supplied value is not an array.
     * The destructed values are required to produce a meaningful error for users.
     * The destructed and restructured object is so it's clear what is
     * needed.
     */
    const isArray = (value, details) => {
      if (!Array.isArray(value)) {
        throw new WorkboxError('not-an-array', details);
      }
    };
    const hasMethod = (object, expectedMethod, details) => {
      const type = typeof object[expectedMethod];
      if (type !== 'function') {
        details['expectedMethod'] = expectedMethod;
        throw new WorkboxError('missing-a-method', details);
      }
    };
    const isType = (object, expectedType, details) => {
      if (typeof object !== expectedType) {
        details['expectedType'] = expectedType;
        throw new WorkboxError('incorrect-type', details);
      }
    };
    const isInstance = (object,
    // Need the general type to do the check later.
    // eslint-disable-next-line @typescript-eslint/ban-types
    expectedClass, details) => {
      if (!(object instanceof expectedClass)) {
        details['expectedClassName'] = expectedClass.name;
        throw new WorkboxError('incorrect-class', details);
      }
    };
    const isOneOf = (value, validValues, details) => {
      if (!validValues.includes(value)) {
        details['validValueDescription'] = `Valid values are ${JSON.stringify(validValues)}.`;
        throw new WorkboxError('invalid-value', details);
      }
    };
    const isArrayOfClass = (value,
    // Need general type to do check later.
    expectedClass,
    // eslint-disable-line
    details) => {
      const error = new WorkboxError('not-array-of-class', details);
      if (!Array.isArray(value)) {
        throw error;
      }
      for (const item of value) {
        if (!(item instanceof expectedClass)) {
          throw error;
        }
      }
    };
    const finalAssertExports = {
      hasMethod,
      isArray,
      isInstance,
      isOneOf,
      isType,
      isArrayOfClass
    };

    // @ts-ignore
    try {
      self['workbox:routing:6.5.4'] && _();
    } catch (e) {}

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * The default HTTP method, 'GET', used when there's no specific method
     * configured for a route.
     *
     * @type {string}
     *
     * @private
     */
    const defaultMethod = 'GET';
    /**
     * The list of valid HTTP methods associated with requests that could be routed.
     *
     * @type {Array<string>}
     *
     * @private
     */
    const validMethods = ['DELETE', 'GET', 'HEAD', 'PATCH', 'POST', 'PUT'];

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * @param {function()|Object} handler Either a function, or an object with a
     * 'handle' method.
     * @return {Object} An object with a handle method.
     *
     * @private
     */
    const normalizeHandler = handler => {
      if (handler && typeof handler === 'object') {
        {
          finalAssertExports.hasMethod(handler, 'handle', {
            moduleName: 'workbox-routing',
            className: 'Route',
            funcName: 'constructor',
            paramName: 'handler'
          });
        }
        return handler;
      } else {
        {
          finalAssertExports.isType(handler, 'function', {
            moduleName: 'workbox-routing',
            className: 'Route',
            funcName: 'constructor',
            paramName: 'handler'
          });
        }
        return {
          handle: handler
        };
      }
    };

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * A `Route` consists of a pair of callback functions, "match" and "handler".
     * The "match" callback determine if a route should be used to "handle" a
     * request by returning a non-falsy value if it can. The "handler" callback
     * is called when there is a match and should return a Promise that resolves
     * to a `Response`.
     *
     * @memberof workbox-routing
     */
    class Route {
      /**
       * Constructor for Route class.
       *
       * @param {workbox-routing~matchCallback} match
       * A callback function that determines whether the route matches a given
       * `fetch` event by returning a non-falsy value.
       * @param {workbox-routing~handlerCallback} handler A callback
       * function that returns a Promise resolving to a Response.
       * @param {string} [method='GET'] The HTTP method to match the Route
       * against.
       */
      constructor(match, handler, method = defaultMethod) {
        {
          finalAssertExports.isType(match, 'function', {
            moduleName: 'workbox-routing',
            className: 'Route',
            funcName: 'constructor',
            paramName: 'match'
          });
          if (method) {
            finalAssertExports.isOneOf(method, validMethods, {
              paramName: 'method'
            });
          }
        }
        // These values are referenced directly by Router so cannot be
        // altered by minificaton.
        this.handler = normalizeHandler(handler);
        this.match = match;
        this.method = method;
      }
      /**
       *
       * @param {workbox-routing-handlerCallback} handler A callback
       * function that returns a Promise resolving to a Response
       */
      setCatchHandler(handler) {
        this.catchHandler = normalizeHandler(handler);
      }
    }

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * RegExpRoute makes it easy to create a regular expression based
     * {@link workbox-routing.Route}.
     *
     * For same-origin requests the RegExp only needs to match part of the URL. For
     * requests against third-party servers, you must define a RegExp that matches
     * the start of the URL.
     *
     * @memberof workbox-routing
     * @extends workbox-routing.Route
     */
    class RegExpRoute extends Route {
      /**
       * If the regular expression contains
       * [capture groups]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#grouping-back-references},
       * the captured values will be passed to the
       * {@link workbox-routing~handlerCallback} `params`
       * argument.
       *
       * @param {RegExp} regExp The regular expression to match against URLs.
       * @param {workbox-routing~handlerCallback} handler A callback
       * function that returns a Promise resulting in a Response.
       * @param {string} [method='GET'] The HTTP method to match the Route
       * against.
       */
      constructor(regExp, handler, method) {
        {
          finalAssertExports.isInstance(regExp, RegExp, {
            moduleName: 'workbox-routing',
            className: 'RegExpRoute',
            funcName: 'constructor',
            paramName: 'pattern'
          });
        }
        const match = ({
          url
        }) => {
          const result = regExp.exec(url.href);
          // Return immediately if there's no match.
          if (!result) {
            return;
          }
          // Require that the match start at the first character in the URL string
          // if it's a cross-origin request.
          // See https://github.com/GoogleChrome/workbox/issues/281 for the context
          // behind this behavior.
          if (url.origin !== location.origin && result.index !== 0) {
            {
              logger.debug(`The regular expression '${regExp.toString()}' only partially matched ` + `against the cross-origin URL '${url.toString()}'. RegExpRoute's will only ` + `handle cross-origin requests if they match the entire URL.`);
            }
            return;
          }
          // If the route matches, but there aren't any capture groups defined, then
          // this will return [], which is truthy and therefore sufficient to
          // indicate a match.
          // If there are capture groups, then it will return their values.
          return result.slice(1);
        };
        super(match, handler, method);
      }
    }

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    const getFriendlyURL = url => {
      const urlObj = new URL(String(url), location.href);
      // See https://github.com/GoogleChrome/workbox/issues/2323
      // We want to include everything, except for the origin if it's same-origin.
      return urlObj.href.replace(new RegExp(`^${location.origin}`), '');
    };

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * The Router can be used to process a `FetchEvent` using one or more
     * {@link workbox-routing.Route}, responding with a `Response` if
     * a matching route exists.
     *
     * If no route matches a given a request, the Router will use a "default"
     * handler if one is defined.
     *
     * Should the matching Route throw an error, the Router will use a "catch"
     * handler if one is defined to gracefully deal with issues and respond with a
     * Request.
     *
     * If a request matches multiple routes, the **earliest** registered route will
     * be used to respond to the request.
     *
     * @memberof workbox-routing
     */
    class Router {
      /**
       * Initializes a new Router.
       */
      constructor() {
        this._routes = new Map();
        this._defaultHandlerMap = new Map();
      }
      /**
       * @return {Map<string, Array<workbox-routing.Route>>} routes A `Map` of HTTP
       * method name ('GET', etc.) to an array of all the corresponding `Route`
       * instances that are registered.
       */
      get routes() {
        return this._routes;
      }
      /**
       * Adds a fetch event listener to respond to events when a route matches
       * the event's request.
       */
      addFetchListener() {
        // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705
        self.addEventListener('fetch', event => {
          const {
            request
          } = event;
          const responsePromise = this.handleRequest({
            request,
            event
          });
          if (responsePromise) {
            event.respondWith(responsePromise);
          }
        });
      }
      /**
       * Adds a message event listener for URLs to cache from the window.
       * This is useful to cache resources loaded on the page prior to when the
       * service worker started controlling it.
       *
       * The format of the message data sent from the window should be as follows.
       * Where the `urlsToCache` array may consist of URL strings or an array of
       * URL string + `requestInit` object (the same as you'd pass to `fetch()`).
       *
       * ```
       * {
       *   type: 'CACHE_URLS',
       *   payload: {
       *     urlsToCache: [
       *       './script1.js',
       *       './script2.js',
       *       ['./script3.js', {mode: 'no-cors'}],
       *     ],
       *   },
       * }
       * ```
       */
      addCacheListener() {
        // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705
        self.addEventListener('message', event => {
          // event.data is type 'any'
          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
          if (event.data && event.data.type === 'CACHE_URLS') {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            const {
              payload
            } = event.data;
            {
              logger.debug(`Caching URLs from the window`, payload.urlsToCache);
            }
            const requestPromises = Promise.all(payload.urlsToCache.map(entry => {
              if (typeof entry === 'string') {
                entry = [entry];
              }
              const request = new Request(...entry);
              return this.handleRequest({
                request,
                event
              });
              // TODO(philipwalton): TypeScript errors without this typecast for
              // some reason (probably a bug). The real type here should work but
              // doesn't: `Array<Promise<Response> | undefined>`.
            })); // TypeScript
            event.waitUntil(requestPromises);
            // If a MessageChannel was used, reply to the message on success.
            if (event.ports && event.ports[0]) {
              void requestPromises.then(() => event.ports[0].postMessage(true));
            }
          }
        });
      }
      /**
       * Apply the routing rules to a FetchEvent object to get a Response from an
       * appropriate Route's handler.
       *
       * @param {Object} options
       * @param {Request} options.request The request to handle.
       * @param {ExtendableEvent} options.event The event that triggered the
       *     request.
       * @return {Promise<Response>|undefined} A promise is returned if a
       *     registered route can handle the request. If there is no matching
       *     route and there's no `defaultHandler`, `undefined` is returned.
       */
      handleRequest({
        request,
        event
      }) {
        {
          finalAssertExports.isInstance(request, Request, {
            moduleName: 'workbox-routing',
            className: 'Router',
            funcName: 'handleRequest',
            paramName: 'options.request'
          });
        }
        const url = new URL(request.url, location.href);
        if (!url.protocol.startsWith('http')) {
          {
            logger.debug(`Workbox Router only supports URLs that start with 'http'.`);
          }
          return;
        }
        const sameOrigin = url.origin === location.origin;
        const {
          params,
          route
        } = this.findMatchingRoute({
          event,
          request,
          sameOrigin,
          url
        });
        let handler = route && route.handler;
        const debugMessages = [];
        {
          if (handler) {
            debugMessages.push([`Found a route to handle this request:`, route]);
            if (params) {
              debugMessages.push([`Passing the following params to the route's handler:`, params]);
            }
          }
        }
        // If we don't have a handler because there was no matching route, then
        // fall back to defaultHandler if that's defined.
        const method = request.method;
        if (!handler && this._defaultHandlerMap.has(method)) {
          {
            debugMessages.push(`Failed to find a matching route. Falling ` + `back to the default handler for ${method}.`);
          }
          handler = this._defaultHandlerMap.get(method);
        }
        if (!handler) {
          {
            // No handler so Workbox will do nothing. If logs is set of debug
            // i.e. verbose, we should print out this information.
            logger.debug(`No route found for: ${getFriendlyURL(url)}`);
          }
          return;
        }
        {
          // We have a handler, meaning Workbox is going to handle the route.
          // print the routing details to the console.
          logger.groupCollapsed(`Router is responding to: ${getFriendlyURL(url)}`);
          debugMessages.forEach(msg => {
            if (Array.isArray(msg)) {
              logger.log(...msg);
            } else {
              logger.log(msg);
            }
          });
          logger.groupEnd();
        }
        // Wrap in try and catch in case the handle method throws a synchronous
        // error. It should still callback to the catch handler.
        let responsePromise;
        try {
          responsePromise = handler.handle({
            url,
            request,
            event,
            params
          });
        } catch (err) {
          responsePromise = Promise.reject(err);
        }
        // Get route's catch handler, if it exists
        const catchHandler = route && route.catchHandler;
        if (responsePromise instanceof Promise && (this._catchHandler || catchHandler)) {
          responsePromise = responsePromise.catch(async err => {
            // If there's a route catch handler, process that first
            if (catchHandler) {
              {
                // Still include URL here as it will be async from the console group
                // and may not make sense without the URL
                logger.groupCollapsed(`Error thrown when responding to: ` + ` ${getFriendlyURL(url)}. Falling back to route's Catch Handler.`);
                logger.error(`Error thrown by:`, route);
                logger.error(err);
                logger.groupEnd();
              }
              try {
                return await catchHandler.handle({
                  url,
                  request,
                  event,
                  params
                });
              } catch (catchErr) {
                if (catchErr instanceof Error) {
                  err = catchErr;
                }
              }
            }
            if (this._catchHandler) {
              {
                // Still include URL here as it will be async from the console group
                // and may not make sense without the URL
                logger.groupCollapsed(`Error thrown when responding to: ` + ` ${getFriendlyURL(url)}. Falling back to global Catch Handler.`);
                logger.error(`Error thrown by:`, route);
                logger.error(err);
                logger.groupEnd();
              }
              return this._catchHandler.handle({
                url,
                request,
                event
              });
            }
            throw err;
          });
        }
        return responsePromise;
      }
      /**
       * Checks a request and URL (and optionally an event) against the list of
       * registered routes, and if there's a match, returns the corresponding
       * route along with any params generated by the match.
       *
       * @param {Object} options
       * @param {URL} options.url
       * @param {boolean} options.sameOrigin The result of comparing `url.origin`
       *     against the current origin.
       * @param {Request} options.request The request to match.
       * @param {Event} options.event The corresponding event.
       * @return {Object} An object with `route` and `params` properties.
       *     They are populated if a matching route was found or `undefined`
       *     otherwise.
       */
      findMatchingRoute({
        url,
        sameOrigin,
        request,
        event
      }) {
        const routes = this._routes.get(request.method) || [];
        for (const route of routes) {
          let params;
          // route.match returns type any, not possible to change right now.
          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
          const matchResult = route.match({
            url,
            sameOrigin,
            request,
            event
          });
          if (matchResult) {
            {
              // Warn developers that using an async matchCallback is almost always
              // not the right thing to do.
              if (matchResult instanceof Promise) {
                logger.warn(`While routing ${getFriendlyURL(url)}, an async ` + `matchCallback function was used. Please convert the ` + `following route to use a synchronous matchCallback function:`, route);
              }
            }
            // See https://github.com/GoogleChrome/workbox/issues/2079
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            params = matchResult;
            if (Array.isArray(params) && params.length === 0) {
              // Instead of passing an empty array in as params, use undefined.
              params = undefined;
            } else if (matchResult.constructor === Object &&
            // eslint-disable-line
            Object.keys(matchResult).length === 0) {
              // Instead of passing an empty object in as params, use undefined.
              params = undefined;
            } else if (typeof matchResult === 'boolean') {
              // For the boolean value true (rather than just something truth-y),
              // don't set params.
              // See https://github.com/GoogleChrome/workbox/pull/2134#issuecomment-513924353
              params = undefined;
            }
            // Return early if have a match.
            return {
              route,
              params
            };
          }
        }
        // If no match was found above, return and empty object.
        return {};
      }
      /**
       * Define a default `handler` that's called when no routes explicitly
       * match the incoming request.
       *
       * Each HTTP method ('GET', 'POST', etc.) gets its own default handler.
       *
       * Without a default handler, unmatched requests will go against the
       * network as if there were no service worker present.
       *
       * @param {workbox-routing~handlerCallback} handler A callback
       * function that returns a Promise resulting in a Response.
       * @param {string} [method='GET'] The HTTP method to associate with this
       * default handler. Each method has its own default.
       */
      setDefaultHandler(handler, method = defaultMethod) {
        this._defaultHandlerMap.set(method, normalizeHandler(handler));
      }
      /**
       * If a Route throws an error while handling a request, this `handler`
       * will be called and given a chance to provide a response.
       *
       * @param {workbox-routing~handlerCallback} handler A callback
       * function that returns a Promise resulting in a Response.
       */
      setCatchHandler(handler) {
        this._catchHandler = normalizeHandler(handler);
      }
      /**
       * Registers a route with the router.
       *
       * @param {workbox-routing.Route} route The route to register.
       */
      registerRoute(route) {
        {
          finalAssertExports.isType(route, 'object', {
            moduleName: 'workbox-routing',
            className: 'Router',
            funcName: 'registerRoute',
            paramName: 'route'
          });
          finalAssertExports.hasMethod(route, 'match', {
            moduleName: 'workbox-routing',
            className: 'Router',
            funcName: 'registerRoute',
            paramName: 'route'
          });
          finalAssertExports.isType(route.handler, 'object', {
            moduleName: 'workbox-routing',
            className: 'Router',
            funcName: 'registerRoute',
            paramName: 'route'
          });
          finalAssertExports.hasMethod(route.handler, 'handle', {
            moduleName: 'workbox-routing',
            className: 'Router',
            funcName: 'registerRoute',
            paramName: 'route.handler'
          });
          finalAssertExports.isType(route.method, 'string', {
            moduleName: 'workbox-routing',
            className: 'Router',
            funcName: 'registerRoute',
            paramName: 'route.method'
          });
        }
        if (!this._routes.has(route.method)) {
          this._routes.set(route.method, []);
        }
        // Give precedence to all of the earlier routes by adding this additional
        // route to the end of the array.
        this._routes.get(route.method).push(route);
      }
      /**
       * Unregisters a route with the router.
       *
       * @param {workbox-routing.Route} route The route to unregister.
       */
      unregisterRoute(route) {
        if (!this._routes.has(route.method)) {
          throw new WorkboxError('unregister-route-but-not-found-with-method', {
            method: route.method
          });
        }
        const routeIndex = this._routes.get(route.method).indexOf(route);
        if (routeIndex > -1) {
          this._routes.get(route.method).splice(routeIndex, 1);
        } else {
          throw new WorkboxError('unregister-route-route-not-registered');
        }
      }
    }

    /*
      Copyright 2019 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    let defaultRouter;
    /**
     * Creates a new, singleton Router instance if one does not exist. If one
     * does already exist, that instance is returned.
     *
     * @private
     * @return {Router}
     */
    const getOrCreateDefaultRouter = () => {
      if (!defaultRouter) {
        defaultRouter = new Router();
        // The helpers that use the default Router assume these listeners exist.
        defaultRouter.addFetchListener();
        defaultRouter.addCacheListener();
      }
      return defaultRouter;
    };

    /*
      Copyright 2019 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * Easily register a RegExp, string, or function with a caching
     * strategy to a singleton Router instance.
     *
     * This method will generate a Route for you if needed and
     * call {@link workbox-routing.Router#registerRoute}.
     *
     * @param {RegExp|string|workbox-routing.Route~matchCallback|workbox-routing.Route} capture
     * If the capture param is a `Route`, all other arguments will be ignored.
     * @param {workbox-routing~handlerCallback} [handler] A callback
     * function that returns a Promise resulting in a Response. This parameter
     * is required if `capture` is not a `Route` object.
     * @param {string} [method='GET'] The HTTP method to match the Route
     * against.
     * @return {workbox-routing.Route} The generated `Route`.
     *
     * @memberof workbox-routing
     */
    function registerRoute(capture, handler, method) {
      let route;
      if (typeof capture === 'string') {
        const captureUrl = new URL(capture, location.href);
        {
          if (!(capture.startsWith('/') || capture.startsWith('http'))) {
            throw new WorkboxError('invalid-string', {
              moduleName: 'workbox-routing',
              funcName: 'registerRoute',
              paramName: 'capture'
            });
          }
          // We want to check if Express-style wildcards are in the pathname only.
          // TODO: Remove this log message in v4.
          const valueToCheck = capture.startsWith('http') ? captureUrl.pathname : capture;
          // See https://github.com/pillarjs/path-to-regexp#parameters
          const wildcards = '[*:?+]';
          if (new RegExp(`${wildcards}`).exec(valueToCheck)) {
            logger.debug(`The '$capture' parameter contains an Express-style wildcard ` + `character (${wildcards}). Strings are now always interpreted as ` + `exact matches; use a RegExp for partial or wildcard matches.`);
          }
        }
        const matchCallback = ({
          url
        }) => {
          {
            if (url.pathname === captureUrl.pathname && url.origin !== captureUrl.origin) {
              logger.debug(`${capture} only partially matches the cross-origin URL ` + `${url.toString()}. This route will only handle cross-origin requests ` + `if they match the entire URL.`);
            }
          }
          return url.href === captureUrl.href;
        };
        // If `capture` is a string then `handler` and `method` must be present.
        route = new Route(matchCallback, handler, method);
      } else if (capture instanceof RegExp) {
        // If `capture` is a `RegExp` then `handler` and `method` must be present.
        route = new RegExpRoute(capture, handler, method);
      } else if (typeof capture === 'function') {
        // If `capture` is a function then `handler` and `method` must be present.
        route = new Route(capture, handler, method);
      } else if (capture instanceof Route) {
        route = capture;
      } else {
        throw new WorkboxError('unsupported-route-type', {
          moduleName: 'workbox-routing',
          funcName: 'registerRoute',
          paramName: 'capture'
        });
      }
      const defaultRouter = getOrCreateDefaultRouter();
      defaultRouter.registerRoute(route);
      return route;
    }

    // @ts-ignore
    try {
      self['workbox:strategies:6.5.4'] && _();
    } catch (e) {}

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    const cacheOkAndOpaquePlugin = {
      /**
       * Returns a valid response (to allow caching) if the status is 200 (OK) or
       * 0 (opaque).
       *
       * @param {Object} options
       * @param {Response} options.response
       * @return {Response|null}
       *
       * @private
       */
      cacheWillUpdate: async ({
        response
      }) => {
        if (response.status === 200 || response.status === 0) {
          return response;
        }
        return null;
      }
    };

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    const _cacheNameDetails = {
      googleAnalytics: 'googleAnalytics',
      precache: 'precache-v2',
      prefix: 'workbox',
      runtime: 'runtime',
      suffix: typeof registration !== 'undefined' ? registration.scope : ''
    };
    const _createCacheName = cacheName => {
      return [_cacheNameDetails.prefix, cacheName, _cacheNameDetails.suffix].filter(value => value && value.length > 0).join('-');
    };
    const eachCacheNameDetail = fn => {
      for (const key of Object.keys(_cacheNameDetails)) {
        fn(key);
      }
    };
    const cacheNames = {
      updateDetails: details => {
        eachCacheNameDetail(key => {
          if (typeof details[key] === 'string') {
            _cacheNameDetails[key] = details[key];
          }
        });
      },
      getGoogleAnalyticsName: userCacheName => {
        return userCacheName || _createCacheName(_cacheNameDetails.googleAnalytics);
      },
      getPrecacheName: userCacheName => {
        return userCacheName || _createCacheName(_cacheNameDetails.precache);
      },
      getPrefix: () => {
        return _cacheNameDetails.prefix;
      },
      getRuntimeName: userCacheName => {
        return userCacheName || _createCacheName(_cacheNameDetails.runtime);
      },
      getSuffix: () => {
        return _cacheNameDetails.suffix;
      }
    };

    /*
      Copyright 2020 Google LLC
      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    function stripParams(fullURL, ignoreParams) {
      const strippedURL = new URL(fullURL);
      for (const param of ignoreParams) {
        strippedURL.searchParams.delete(param);
      }
      return strippedURL.href;
    }
    /**
     * Matches an item in the cache, ignoring specific URL params. This is similar
     * to the `ignoreSearch` option, but it allows you to ignore just specific
     * params (while continuing to match on the others).
     *
     * @private
     * @param {Cache} cache
     * @param {Request} request
     * @param {Object} matchOptions
     * @param {Array<string>} ignoreParams
     * @return {Promise<Response|undefined>}
     */
    async function cacheMatchIgnoreParams(cache, request, ignoreParams, matchOptions) {
      const strippedRequestURL = stripParams(request.url, ignoreParams);
      // If the request doesn't include any ignored params, match as normal.
      if (request.url === strippedRequestURL) {
        return cache.match(request, matchOptions);
      }
      // Otherwise, match by comparing keys
      const keysOptions = Object.assign(Object.assign({}, matchOptions), {
        ignoreSearch: true
      });
      const cacheKeys = await cache.keys(request, keysOptions);
      for (const cacheKey of cacheKeys) {
        const strippedCacheKeyURL = stripParams(cacheKey.url, ignoreParams);
        if (strippedRequestURL === strippedCacheKeyURL) {
          return cache.match(cacheKey, matchOptions);
        }
      }
      return;
    }

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * The Deferred class composes Promises in a way that allows for them to be
     * resolved or rejected from outside the constructor. In most cases promises
     * should be used directly, but Deferreds can be necessary when the logic to
     * resolve a promise must be separate.
     *
     * @private
     */
    class Deferred {
      /**
       * Creates a promise and exposes its resolve and reject functions as methods.
       */
      constructor() {
        this.promise = new Promise((resolve, reject) => {
          this.resolve = resolve;
          this.reject = reject;
        });
      }
    }

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    // Callbacks to be executed whenever there's a quota error.
    // Can't change Function type right now.
    // eslint-disable-next-line @typescript-eslint/ban-types
    const quotaErrorCallbacks = new Set();

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * Runs all of the callback functions, one at a time sequentially, in the order
     * in which they were registered.
     *
     * @memberof workbox-core
     * @private
     */
    async function executeQuotaErrorCallbacks() {
      {
        logger.log(`About to run ${quotaErrorCallbacks.size} ` + `callbacks to clean up caches.`);
      }
      for (const callback of quotaErrorCallbacks) {
        await callback();
        {
          logger.log(callback, 'is complete.');
        }
      }
      {
        logger.log('Finished running callbacks.');
      }
    }

    /*
      Copyright 2019 Google LLC
      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * Returns a promise that resolves and the passed number of milliseconds.
     * This utility is an async/await-friendly version of `setTimeout`.
     *
     * @param {number} ms
     * @return {Promise}
     * @private
     */
    function timeout(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    /*
      Copyright 2020 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    function toRequest(input) {
      return typeof input === 'string' ? new Request(input) : input;
    }
    /**
     * A class created every time a Strategy instance instance calls
     * {@link workbox-strategies.Strategy~handle} or
     * {@link workbox-strategies.Strategy~handleAll} that wraps all fetch and
     * cache actions around plugin callbacks and keeps track of when the strategy
     * is "done" (i.e. all added `event.waitUntil()` promises have resolved).
     *
     * @memberof workbox-strategies
     */
    class StrategyHandler {
      /**
       * Creates a new instance associated with the passed strategy and event
       * that's handling the request.
       *
       * The constructor also initializes the state that will be passed to each of
       * the plugins handling this request.
       *
       * @param {workbox-strategies.Strategy} strategy
       * @param {Object} options
       * @param {Request|string} options.request A request to run this strategy for.
       * @param {ExtendableEvent} options.event The event associated with the
       *     request.
       * @param {URL} [options.url]
       * @param {*} [options.params] The return value from the
       *     {@link workbox-routing~matchCallback} (if applicable).
       */
      constructor(strategy, options) {
        this._cacheKeys = {};
        /**
         * The request the strategy is performing (passed to the strategy's
         * `handle()` or `handleAll()` method).
         * @name request
         * @instance
         * @type {Request}
         * @memberof workbox-strategies.StrategyHandler
         */
        /**
         * The event associated with this request.
         * @name event
         * @instance
         * @type {ExtendableEvent}
         * @memberof workbox-strategies.StrategyHandler
         */
        /**
         * A `URL` instance of `request.url` (if passed to the strategy's
         * `handle()` or `handleAll()` method).
         * Note: the `url` param will be present if the strategy was invoked
         * from a workbox `Route` object.
         * @name url
         * @instance
         * @type {URL|undefined}
         * @memberof workbox-strategies.StrategyHandler
         */
        /**
         * A `param` value (if passed to the strategy's
         * `handle()` or `handleAll()` method).
         * Note: the `param` param will be present if the strategy was invoked
         * from a workbox `Route` object and the
         * {@link workbox-routing~matchCallback} returned
         * a truthy value (it will be that value).
         * @name params
         * @instance
         * @type {*|undefined}
         * @memberof workbox-strategies.StrategyHandler
         */
        {
          finalAssertExports.isInstance(options.event, ExtendableEvent, {
            moduleName: 'workbox-strategies',
            className: 'StrategyHandler',
            funcName: 'constructor',
            paramName: 'options.event'
          });
        }
        Object.assign(this, options);
        this.event = options.event;
        this._strategy = strategy;
        this._handlerDeferred = new Deferred();
        this._extendLifetimePromises = [];
        // Copy the plugins list (since it's mutable on the strategy),
        // so any mutations don't affect this handler instance.
        this._plugins = [...strategy.plugins];
        this._pluginStateMap = new Map();
        for (const plugin of this._plugins) {
          this._pluginStateMap.set(plugin, {});
        }
        this.event.waitUntil(this._handlerDeferred.promise);
      }
      /**
       * Fetches a given request (and invokes any applicable plugin callback
       * methods) using the `fetchOptions` (for non-navigation requests) and
       * `plugins` defined on the `Strategy` object.
       *
       * The following plugin lifecycle methods are invoked when using this method:
       * - `requestWillFetch()`
       * - `fetchDidSucceed()`
       * - `fetchDidFail()`
       *
       * @param {Request|string} input The URL or request to fetch.
       * @return {Promise<Response>}
       */
      async fetch(input) {
        const {
          event
        } = this;
        let request = toRequest(input);
        if (request.mode === 'navigate' && event instanceof FetchEvent && event.preloadResponse) {
          const possiblePreloadResponse = await event.preloadResponse;
          if (possiblePreloadResponse) {
            {
              logger.log(`Using a preloaded navigation response for ` + `'${getFriendlyURL(request.url)}'`);
            }
            return possiblePreloadResponse;
          }
        }
        // If there is a fetchDidFail plugin, we need to save a clone of the
        // original request before it's either modified by a requestWillFetch
        // plugin or before the original request's body is consumed via fetch().
        const originalRequest = this.hasCallback('fetchDidFail') ? request.clone() : null;
        try {
          for (const cb of this.iterateCallbacks('requestWillFetch')) {
            request = await cb({
              request: request.clone(),
              event
            });
          }
        } catch (err) {
          if (err instanceof Error) {
            throw new WorkboxError('plugin-error-request-will-fetch', {
              thrownErrorMessage: err.message
            });
          }
        }
        // The request can be altered by plugins with `requestWillFetch` making
        // the original request (most likely from a `fetch` event) different
        // from the Request we make. Pass both to `fetchDidFail` to aid debugging.
        const pluginFilteredRequest = request.clone();
        try {
          let fetchResponse;
          // See https://github.com/GoogleChrome/workbox/issues/1796
          fetchResponse = await fetch(request, request.mode === 'navigate' ? undefined : this._strategy.fetchOptions);
          if ("development" !== 'production') {
            logger.debug(`Network request for ` + `'${getFriendlyURL(request.url)}' returned a response with ` + `status '${fetchResponse.status}'.`);
          }
          for (const callback of this.iterateCallbacks('fetchDidSucceed')) {
            fetchResponse = await callback({
              event,
              request: pluginFilteredRequest,
              response: fetchResponse
            });
          }
          return fetchResponse;
        } catch (error) {
          {
            logger.log(`Network request for ` + `'${getFriendlyURL(request.url)}' threw an error.`, error);
          }
          // `originalRequest` will only exist if a `fetchDidFail` callback
          // is being used (see above).
          if (originalRequest) {
            await this.runCallbacks('fetchDidFail', {
              error: error,
              event,
              originalRequest: originalRequest.clone(),
              request: pluginFilteredRequest.clone()
            });
          }
          throw error;
        }
      }
      /**
       * Calls `this.fetch()` and (in the background) runs `this.cachePut()` on
       * the response generated by `this.fetch()`.
       *
       * The call to `this.cachePut()` automatically invokes `this.waitUntil()`,
       * so you do not have to manually call `waitUntil()` on the event.
       *
       * @param {Request|string} input The request or URL to fetch and cache.
       * @return {Promise<Response>}
       */
      async fetchAndCachePut(input) {
        const response = await this.fetch(input);
        const responseClone = response.clone();
        void this.waitUntil(this.cachePut(input, responseClone));
        return response;
      }
      /**
       * Matches a request from the cache (and invokes any applicable plugin
       * callback methods) using the `cacheName`, `matchOptions`, and `plugins`
       * defined on the strategy object.
       *
       * The following plugin lifecycle methods are invoked when using this method:
       * - cacheKeyWillByUsed()
       * - cachedResponseWillByUsed()
       *
       * @param {Request|string} key The Request or URL to use as the cache key.
       * @return {Promise<Response|undefined>} A matching response, if found.
       */
      async cacheMatch(key) {
        const request = toRequest(key);
        let cachedResponse;
        const {
          cacheName,
          matchOptions
        } = this._strategy;
        const effectiveRequest = await this.getCacheKey(request, 'read');
        const multiMatchOptions = Object.assign(Object.assign({}, matchOptions), {
          cacheName
        });
        cachedResponse = await caches.match(effectiveRequest, multiMatchOptions);
        {
          if (cachedResponse) {
            logger.debug(`Found a cached response in '${cacheName}'.`);
          } else {
            logger.debug(`No cached response found in '${cacheName}'.`);
          }
        }
        for (const callback of this.iterateCallbacks('cachedResponseWillBeUsed')) {
          cachedResponse = (await callback({
            cacheName,
            matchOptions,
            cachedResponse,
            request: effectiveRequest,
            event: this.event
          })) || undefined;
        }
        return cachedResponse;
      }
      /**
       * Puts a request/response pair in the cache (and invokes any applicable
       * plugin callback methods) using the `cacheName` and `plugins` defined on
       * the strategy object.
       *
       * The following plugin lifecycle methods are invoked when using this method:
       * - cacheKeyWillByUsed()
       * - cacheWillUpdate()
       * - cacheDidUpdate()
       *
       * @param {Request|string} key The request or URL to use as the cache key.
       * @param {Response} response The response to cache.
       * @return {Promise<boolean>} `false` if a cacheWillUpdate caused the response
       * not be cached, and `true` otherwise.
       */
      async cachePut(key, response) {
        const request = toRequest(key);
        // Run in the next task to avoid blocking other cache reads.
        // https://github.com/w3c/ServiceWorker/issues/1397
        await timeout(0);
        const effectiveRequest = await this.getCacheKey(request, 'write');
        {
          if (effectiveRequest.method && effectiveRequest.method !== 'GET') {
            throw new WorkboxError('attempt-to-cache-non-get-request', {
              url: getFriendlyURL(effectiveRequest.url),
              method: effectiveRequest.method
            });
          }
          // See https://github.com/GoogleChrome/workbox/issues/2818
          const vary = response.headers.get('Vary');
          if (vary) {
            logger.debug(`The response for ${getFriendlyURL(effectiveRequest.url)} ` + `has a 'Vary: ${vary}' header. ` + `Consider setting the {ignoreVary: true} option on your strategy ` + `to ensure cache matching and deletion works as expected.`);
          }
        }
        if (!response) {
          {
            logger.error(`Cannot cache non-existent response for ` + `'${getFriendlyURL(effectiveRequest.url)}'.`);
          }
          throw new WorkboxError('cache-put-with-no-response', {
            url: getFriendlyURL(effectiveRequest.url)
          });
        }
        const responseToCache = await this._ensureResponseSafeToCache(response);
        if (!responseToCache) {
          {
            logger.debug(`Response '${getFriendlyURL(effectiveRequest.url)}' ` + `will not be cached.`, responseToCache);
          }
          return false;
        }
        const {
          cacheName,
          matchOptions
        } = this._strategy;
        const cache = await self.caches.open(cacheName);
        const hasCacheUpdateCallback = this.hasCallback('cacheDidUpdate');
        const oldResponse = hasCacheUpdateCallback ? await cacheMatchIgnoreParams(
        // TODO(philipwalton): the `__WB_REVISION__` param is a precaching
        // feature. Consider into ways to only add this behavior if using
        // precaching.
        cache, effectiveRequest.clone(), ['__WB_REVISION__'], matchOptions) : null;
        {
          logger.debug(`Updating the '${cacheName}' cache with a new Response ` + `for ${getFriendlyURL(effectiveRequest.url)}.`);
        }
        try {
          await cache.put(effectiveRequest, hasCacheUpdateCallback ? responseToCache.clone() : responseToCache);
        } catch (error) {
          if (error instanceof Error) {
            // See https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-QuotaExceededError
            if (error.name === 'QuotaExceededError') {
              await executeQuotaErrorCallbacks();
            }
            throw error;
          }
        }
        for (const callback of this.iterateCallbacks('cacheDidUpdate')) {
          await callback({
            cacheName,
            oldResponse,
            newResponse: responseToCache.clone(),
            request: effectiveRequest,
            event: this.event
          });
        }
        return true;
      }
      /**
       * Checks the list of plugins for the `cacheKeyWillBeUsed` callback, and
       * executes any of those callbacks found in sequence. The final `Request`
       * object returned by the last plugin is treated as the cache key for cache
       * reads and/or writes. If no `cacheKeyWillBeUsed` plugin callbacks have
       * been registered, the passed request is returned unmodified
       *
       * @param {Request} request
       * @param {string} mode
       * @return {Promise<Request>}
       */
      async getCacheKey(request, mode) {
        const key = `${request.url} | ${mode}`;
        if (!this._cacheKeys[key]) {
          let effectiveRequest = request;
          for (const callback of this.iterateCallbacks('cacheKeyWillBeUsed')) {
            effectiveRequest = toRequest(await callback({
              mode,
              request: effectiveRequest,
              event: this.event,
              // params has a type any can't change right now.
              params: this.params // eslint-disable-line
            }));
          }
          this._cacheKeys[key] = effectiveRequest;
        }
        return this._cacheKeys[key];
      }
      /**
       * Returns true if the strategy has at least one plugin with the given
       * callback.
       *
       * @param {string} name The name of the callback to check for.
       * @return {boolean}
       */
      hasCallback(name) {
        for (const plugin of this._strategy.plugins) {
          if (name in plugin) {
            return true;
          }
        }
        return false;
      }
      /**
       * Runs all plugin callbacks matching the given name, in order, passing the
       * given param object (merged ith the current plugin state) as the only
       * argument.
       *
       * Note: since this method runs all plugins, it's not suitable for cases
       * where the return value of a callback needs to be applied prior to calling
       * the next callback. See
       * {@link workbox-strategies.StrategyHandler#iterateCallbacks}
       * below for how to handle that case.
       *
       * @param {string} name The name of the callback to run within each plugin.
       * @param {Object} param The object to pass as the first (and only) param
       *     when executing each callback. This object will be merged with the
       *     current plugin state prior to callback execution.
       */
      async runCallbacks(name, param) {
        for (const callback of this.iterateCallbacks(name)) {
          // TODO(philipwalton): not sure why `any` is needed. It seems like
          // this should work with `as WorkboxPluginCallbackParam[C]`.
          await callback(param);
        }
      }
      /**
       * Accepts a callback and returns an iterable of matching plugin callbacks,
       * where each callback is wrapped with the current handler state (i.e. when
       * you call each callback, whatever object parameter you pass it will
       * be merged with the plugin's current state).
       *
       * @param {string} name The name fo the callback to run
       * @return {Array<Function>}
       */
      *iterateCallbacks(name) {
        for (const plugin of this._strategy.plugins) {
          if (typeof plugin[name] === 'function') {
            const state = this._pluginStateMap.get(plugin);
            const statefulCallback = param => {
              const statefulParam = Object.assign(Object.assign({}, param), {
                state
              });
              // TODO(philipwalton): not sure why `any` is needed. It seems like
              // this should work with `as WorkboxPluginCallbackParam[C]`.
              return plugin[name](statefulParam);
            };
            yield statefulCallback;
          }
        }
      }
      /**
       * Adds a promise to the
       * [extend lifetime promises]{@link https://w3c.github.io/ServiceWorker/#extendableevent-extend-lifetime-promises}
       * of the event event associated with the request being handled (usually a
       * `FetchEvent`).
       *
       * Note: you can await
       * {@link workbox-strategies.StrategyHandler~doneWaiting}
       * to know when all added promises have settled.
       *
       * @param {Promise} promise A promise to add to the extend lifetime promises
       *     of the event that triggered the request.
       */
      waitUntil(promise) {
        this._extendLifetimePromises.push(promise);
        return promise;
      }
      /**
       * Returns a promise that resolves once all promises passed to
       * {@link workbox-strategies.StrategyHandler~waitUntil}
       * have settled.
       *
       * Note: any work done after `doneWaiting()` settles should be manually
       * passed to an event's `waitUntil()` method (not this handler's
       * `waitUntil()` method), otherwise the service worker thread my be killed
       * prior to your work completing.
       */
      async doneWaiting() {
        let promise;
        while (promise = this._extendLifetimePromises.shift()) {
          await promise;
        }
      }
      /**
       * Stops running the strategy and immediately resolves any pending
       * `waitUntil()` promises.
       */
      destroy() {
        this._handlerDeferred.resolve(null);
      }
      /**
       * This method will call cacheWillUpdate on the available plugins (or use
       * status === 200) to determine if the Response is safe and valid to cache.
       *
       * @param {Request} options.request
       * @param {Response} options.response
       * @return {Promise<Response|undefined>}
       *
       * @private
       */
      async _ensureResponseSafeToCache(response) {
        let responseToCache = response;
        let pluginsUsed = false;
        for (const callback of this.iterateCallbacks('cacheWillUpdate')) {
          responseToCache = (await callback({
            request: this.request,
            response: responseToCache,
            event: this.event
          })) || undefined;
          pluginsUsed = true;
          if (!responseToCache) {
            break;
          }
        }
        if (!pluginsUsed) {
          if (responseToCache && responseToCache.status !== 200) {
            responseToCache = undefined;
          }
          {
            if (responseToCache) {
              if (responseToCache.status !== 200) {
                if (responseToCache.status === 0) {
                  logger.warn(`The response for '${this.request.url}' ` + `is an opaque response. The caching strategy that you're ` + `using will not cache opaque responses by default.`);
                } else {
                  logger.debug(`The response for '${this.request.url}' ` + `returned a status code of '${response.status}' and won't ` + `be cached as a result.`);
                }
              }
            }
          }
        }
        return responseToCache;
      }
    }

    /*
      Copyright 2020 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * An abstract base class that all other strategy classes must extend from:
     *
     * @memberof workbox-strategies
     */
    class Strategy {
      /**
       * Creates a new instance of the strategy and sets all documented option
       * properties as public instance properties.
       *
       * Note: if a custom strategy class extends the base Strategy class and does
       * not need more than these properties, it does not need to define its own
       * constructor.
       *
       * @param {Object} [options]
       * @param {string} [options.cacheName] Cache name to store and retrieve
       * requests. Defaults to the cache names provided by
       * {@link workbox-core.cacheNames}.
       * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}
       * to use in conjunction with this caching strategy.
       * @param {Object} [options.fetchOptions] Values passed along to the
       * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)
       * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)
       * `fetch()` requests made by this strategy.
       * @param {Object} [options.matchOptions] The
       * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}
       * for any `cache.match()` or `cache.put()` calls made by this strategy.
       */
      constructor(options = {}) {
        /**
         * Cache name to store and retrieve
         * requests. Defaults to the cache names provided by
         * {@link workbox-core.cacheNames}.
         *
         * @type {string}
         */
        this.cacheName = cacheNames.getRuntimeName(options.cacheName);
        /**
         * The list
         * [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}
         * used by this strategy.
         *
         * @type {Array<Object>}
         */
        this.plugins = options.plugins || [];
        /**
         * Values passed along to the
         * [`init`]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters}
         * of all fetch() requests made by this strategy.
         *
         * @type {Object}
         */
        this.fetchOptions = options.fetchOptions;
        /**
         * The
         * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}
         * for any `cache.match()` or `cache.put()` calls made by this strategy.
         *
         * @type {Object}
         */
        this.matchOptions = options.matchOptions;
      }
      /**
       * Perform a request strategy and returns a `Promise` that will resolve with
       * a `Response`, invoking all relevant plugin callbacks.
       *
       * When a strategy instance is registered with a Workbox
       * {@link workbox-routing.Route}, this method is automatically
       * called when the route matches.
       *
       * Alternatively, this method can be used in a standalone `FetchEvent`
       * listener by passing it to `event.respondWith()`.
       *
       * @param {FetchEvent|Object} options A `FetchEvent` or an object with the
       *     properties listed below.
       * @param {Request|string} options.request A request to run this strategy for.
       * @param {ExtendableEvent} options.event The event associated with the
       *     request.
       * @param {URL} [options.url]
       * @param {*} [options.params]
       */
      handle(options) {
        const [responseDone] = this.handleAll(options);
        return responseDone;
      }
      /**
       * Similar to {@link workbox-strategies.Strategy~handle}, but
       * instead of just returning a `Promise` that resolves to a `Response` it
       * it will return an tuple of `[response, done]` promises, where the former
       * (`response`) is equivalent to what `handle()` returns, and the latter is a
       * Promise that will resolve once any promises that were added to
       * `event.waitUntil()` as part of performing the strategy have completed.
       *
       * You can await the `done` promise to ensure any extra work performed by
       * the strategy (usually caching responses) completes successfully.
       *
       * @param {FetchEvent|Object} options A `FetchEvent` or an object with the
       *     properties listed below.
       * @param {Request|string} options.request A request to run this strategy for.
       * @param {ExtendableEvent} options.event The event associated with the
       *     request.
       * @param {URL} [options.url]
       * @param {*} [options.params]
       * @return {Array<Promise>} A tuple of [response, done]
       *     promises that can be used to determine when the response resolves as
       *     well as when the handler has completed all its work.
       */
      handleAll(options) {
        // Allow for flexible options to be passed.
        if (options instanceof FetchEvent) {
          options = {
            event: options,
            request: options.request
          };
        }
        const event = options.event;
        const request = typeof options.request === 'string' ? new Request(options.request) : options.request;
        const params = 'params' in options ? options.params : undefined;
        const handler = new StrategyHandler(this, {
          event,
          request,
          params
        });
        const responseDone = this._getResponse(handler, request, event);
        const handlerDone = this._awaitComplete(responseDone, handler, request, event);
        // Return an array of promises, suitable for use with Promise.all().
        return [responseDone, handlerDone];
      }
      async _getResponse(handler, request, event) {
        await handler.runCallbacks('handlerWillStart', {
          event,
          request
        });
        let response = undefined;
        try {
          response = await this._handle(request, handler);
          // The "official" Strategy subclasses all throw this error automatically,
          // but in case a third-party Strategy doesn't, ensure that we have a
          // consistent failure when there's no response or an error response.
          if (!response || response.type === 'error') {
            throw new WorkboxError('no-response', {
              url: request.url
            });
          }
        } catch (error) {
          if (error instanceof Error) {
            for (const callback of handler.iterateCallbacks('handlerDidError')) {
              response = await callback({
                error,
                event,
                request
              });
              if (response) {
                break;
              }
            }
          }
          if (!response) {
            throw error;
          } else {
            logger.log(`While responding to '${getFriendlyURL(request.url)}', ` + `an ${error instanceof Error ? error.toString() : ''} error occurred. Using a fallback response provided by ` + `a handlerDidError plugin.`);
          }
        }
        for (const callback of handler.iterateCallbacks('handlerWillRespond')) {
          response = await callback({
            event,
            request,
            response
          });
        }
        return response;
      }
      async _awaitComplete(responseDone, handler, request, event) {
        let response;
        let error;
        try {
          response = await responseDone;
        } catch (error) {
          // Ignore errors, as response errors should be caught via the `response`
          // promise above. The `done` promise will only throw for errors in
          // promises passed to `handler.waitUntil()`.
        }
        try {
          await handler.runCallbacks('handlerDidRespond', {
            event,
            request,
            response
          });
          await handler.doneWaiting();
        } catch (waitUntilError) {
          if (waitUntilError instanceof Error) {
            error = waitUntilError;
          }
        }
        await handler.runCallbacks('handlerDidComplete', {
          event,
          request,
          response,
          error: error
        });
        handler.destroy();
        if (error) {
          throw error;
        }
      }
    }
    /**
     * Classes extending the `Strategy` based class should implement this method,
     * and leverage the {@link workbox-strategies.StrategyHandler}
     * arg to perform all fetching and cache logic, which will ensure all relevant
     * cache, cache options, fetch options and plugins are used (per the current
     * strategy instance).
     *
     * @name _handle
     * @instance
     * @abstract
     * @function
     * @param {Request} request
     * @param {workbox-strategies.StrategyHandler} handler
     * @return {Promise<Response>}
     *
     * @memberof workbox-strategies.Strategy
     */

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    const messages = {
      strategyStart: (strategyName, request) => `Using ${strategyName} to respond to '${getFriendlyURL(request.url)}'`,
      printFinalResponse: response => {
        if (response) {
          logger.groupCollapsed(`View the final response here.`);
          logger.log(response || '[No response returned]');
          logger.groupEnd();
        }
      }
    };

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * An implementation of a
     * [network first](https://developer.chrome.com/docs/workbox/caching-strategies-overview/#network-first-falling-back-to-cache)
     * request strategy.
     *
     * By default, this strategy will cache responses with a 200 status code as
     * well as [opaque responses](https://developer.chrome.com/docs/workbox/caching-resources-during-runtime/#opaque-responses).
     * Opaque responses are are cross-origin requests where the response doesn't
     * support [CORS](https://enable-cors.org/).
     *
     * If the network request fails, and there is no cache match, this will throw
     * a `WorkboxError` exception.
     *
     * @extends workbox-strategies.Strategy
     * @memberof workbox-strategies
     */
    class NetworkFirst extends Strategy {
      /**
       * @param {Object} [options]
       * @param {string} [options.cacheName] Cache name to store and retrieve
       * requests. Defaults to cache names provided by
       * {@link workbox-core.cacheNames}.
       * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}
       * to use in conjunction with this caching strategy.
       * @param {Object} [options.fetchOptions] Values passed along to the
       * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)
       * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)
       * `fetch()` requests made by this strategy.
       * @param {Object} [options.matchOptions] [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)
       * @param {number} [options.networkTimeoutSeconds] If set, any network requests
       * that fail to respond within the timeout will fallback to the cache.
       *
       * This option can be used to combat
       * "[lie-fi]{@link https://developers.google.com/web/fundamentals/performance/poor-connectivity/#lie-fi}"
       * scenarios.
       */
      constructor(options = {}) {
        super(options);
        // If this instance contains no plugins with a 'cacheWillUpdate' callback,
        // prepend the `cacheOkAndOpaquePlugin` plugin to the plugins list.
        if (!this.plugins.some(p => 'cacheWillUpdate' in p)) {
          this.plugins.unshift(cacheOkAndOpaquePlugin);
        }
        this._networkTimeoutSeconds = options.networkTimeoutSeconds || 0;
        {
          if (this._networkTimeoutSeconds) {
            finalAssertExports.isType(this._networkTimeoutSeconds, 'number', {
              moduleName: 'workbox-strategies',
              className: this.constructor.name,
              funcName: 'constructor',
              paramName: 'networkTimeoutSeconds'
            });
          }
        }
      }
      /**
       * @private
       * @param {Request|string} request A request to run this strategy for.
       * @param {workbox-strategies.StrategyHandler} handler The event that
       *     triggered the request.
       * @return {Promise<Response>}
       */
      async _handle(request, handler) {
        const logs = [];
        {
          finalAssertExports.isInstance(request, Request, {
            moduleName: 'workbox-strategies',
            className: this.constructor.name,
            funcName: 'handle',
            paramName: 'makeRequest'
          });
        }
        const promises = [];
        let timeoutId;
        if (this._networkTimeoutSeconds) {
          const {
            id,
            promise
          } = this._getTimeoutPromise({
            request,
            logs,
            handler
          });
          timeoutId = id;
          promises.push(promise);
        }
        const networkPromise = this._getNetworkPromise({
          timeoutId,
          request,
          logs,
          handler
        });
        promises.push(networkPromise);
        const response = await handler.waitUntil((async () => {
          // Promise.race() will resolve as soon as the first promise resolves.
          return (await handler.waitUntil(Promise.race(promises))) || (
          // If Promise.race() resolved with null, it might be due to a network
          // timeout + a cache miss. If that were to happen, we'd rather wait until
          // the networkPromise resolves instead of returning null.
          // Note that it's fine to await an already-resolved promise, so we don't
          // have to check to see if it's still "in flight".
          await networkPromise);
        })());
        {
          logger.groupCollapsed(messages.strategyStart(this.constructor.name, request));
          for (const log of logs) {
            logger.log(log);
          }
          messages.printFinalResponse(response);
          logger.groupEnd();
        }
        if (!response) {
          throw new WorkboxError('no-response', {
            url: request.url
          });
        }
        return response;
      }
      /**
       * @param {Object} options
       * @param {Request} options.request
       * @param {Array} options.logs A reference to the logs array
       * @param {Event} options.event
       * @return {Promise<Response>}
       *
       * @private
       */
      _getTimeoutPromise({
        request,
        logs,
        handler
      }) {
        let timeoutId;
        const timeoutPromise = new Promise(resolve => {
          const onNetworkTimeout = async () => {
            {
              logs.push(`Timing out the network response at ` + `${this._networkTimeoutSeconds} seconds.`);
            }
            resolve(await handler.cacheMatch(request));
          };
          timeoutId = setTimeout(onNetworkTimeout, this._networkTimeoutSeconds * 1000);
        });
        return {
          promise: timeoutPromise,
          id: timeoutId
        };
      }
      /**
       * @param {Object} options
       * @param {number|undefined} options.timeoutId
       * @param {Request} options.request
       * @param {Array} options.logs A reference to the logs Array.
       * @param {Event} options.event
       * @return {Promise<Response>}
       *
       * @private
       */
      async _getNetworkPromise({
        timeoutId,
        request,
        logs,
        handler
      }) {
        let error;
        let response;
        try {
          response = await handler.fetchAndCachePut(request);
        } catch (fetchError) {
          if (fetchError instanceof Error) {
            error = fetchError;
          }
        }
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        {
          if (response) {
            logs.push(`Got response from network.`);
          } else {
            logs.push(`Unable to get a response from the network. Will respond ` + `with a cached response.`);
          }
        }
        if (error || !response) {
          response = await handler.cacheMatch(request);
          {
            if (response) {
              logs.push(`Found a cached response in the '${this.cacheName}'` + ` cache.`);
            } else {
              logs.push(`No response found in the '${this.cacheName}' cache.`);
            }
          }
        }
        return response;
      }
    }

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * An implementation of a
     * [network-only](https://developer.chrome.com/docs/workbox/caching-strategies-overview/#network-only)
     * request strategy.
     *
     * This class is useful if you want to take advantage of any
     * [Workbox plugins](https://developer.chrome.com/docs/workbox/using-plugins/).
     *
     * If the network request fails, this will throw a `WorkboxError` exception.
     *
     * @extends workbox-strategies.Strategy
     * @memberof workbox-strategies
     */
    class NetworkOnly extends Strategy {
      /**
       * @param {Object} [options]
       * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}
       * to use in conjunction with this caching strategy.
       * @param {Object} [options.fetchOptions] Values passed along to the
       * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)
       * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)
       * `fetch()` requests made by this strategy.
       * @param {number} [options.networkTimeoutSeconds] If set, any network requests
       * that fail to respond within the timeout will result in a network error.
       */
      constructor(options = {}) {
        super(options);
        this._networkTimeoutSeconds = options.networkTimeoutSeconds || 0;
      }
      /**
       * @private
       * @param {Request|string} request A request to run this strategy for.
       * @param {workbox-strategies.StrategyHandler} handler The event that
       *     triggered the request.
       * @return {Promise<Response>}
       */
      async _handle(request, handler) {
        {
          finalAssertExports.isInstance(request, Request, {
            moduleName: 'workbox-strategies',
            className: this.constructor.name,
            funcName: '_handle',
            paramName: 'request'
          });
        }
        let error = undefined;
        let response;
        try {
          const promises = [handler.fetch(request)];
          if (this._networkTimeoutSeconds) {
            const timeoutPromise = timeout(this._networkTimeoutSeconds * 1000);
            promises.push(timeoutPromise);
          }
          response = await Promise.race(promises);
          if (!response) {
            throw new Error(`Timed out the network response after ` + `${this._networkTimeoutSeconds} seconds.`);
          }
        } catch (err) {
          if (err instanceof Error) {
            error = err;
          }
        }
        {
          logger.groupCollapsed(messages.strategyStart(this.constructor.name, request));
          if (response) {
            logger.log(`Got response from network.`);
          } else {
            logger.log(`Unable to get a response from the network.`);
          }
          messages.printFinalResponse(response);
          logger.groupEnd();
        }
        if (!response) {
          throw new WorkboxError('no-response', {
            url: request.url,
            error
          });
        }
        return response;
      }
    }

    /*
      Copyright 2019 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * Claim any currently available clients once the service worker
     * becomes active. This is normally used in conjunction with `skipWaiting()`.
     *
     * @memberof workbox-core
     */
    function clientsClaim() {
      self.addEventListener('activate', () => self.clients.claim());
    }

    exports.NetworkFirst = NetworkFirst;
    exports.NetworkOnly = NetworkOnly;
    exports.clientsClaim = clientsClaim;
    exports.registerRoute = registerRoute;

}));
//# sourceMappingURL=workbox-e43f5367.js.map




// scripts/fix-service-worker.js
/**
 * This script helps fix service worker issues by:
 * 1. Unregistering any existing service workers
 * 2. Clearing caches that might contain stale service worker data
 */

async function fixServiceWorker() {
  console.log('🔧 Starting service worker fix...');
  
  // Unregister all service workers
  if ('serviceWorker' in navigator) {
    console.log('Unregistering service workers...');
    const registrations = await navigator.serviceWorker.getRegistrations();
    
    if (registrations.length === 0) {
      console.log('No service workers found to unregister.');
    } else {
      for (const registration of registrations) {
        await registration.unregister();
        console.log(`Service worker at ${registration.scope} unregistered.`);
      }
    }
  } else {
    console.log('Service Worker API not supported in this browser.');
  }
  
  // Clear caches
  if ('caches' in window) {
    console.log('Clearing caches...');
    try {
      const cacheNames = await caches.keys();
      
      if (cacheNames.length === 0) {
        console.log('No caches found to clear.');
      } else {
        await Promise.all(
          cacheNames.map(cacheName => {
            console.log(`Deleting cache: ${cacheName}`);
            return caches.delete(cacheName);
          })
        );
        console.log('All caches cleared successfully.');
      }
    } catch (error) {
      console.error('Error clearing caches:', error);
    }
  } else {
    console.log('Cache API not supported in this browser.');
  }
  
  console.log('✅ Service worker fix completed!');
  console.log('🔄 Reloading page in 2 seconds...');
  
  // Reload the page after a short delay
  setTimeout(() => {
    window.location.reload(true);
  }, 2000);
}

// Run the fix
fixServiceWorker().catch(error => {
  console.error('Error during service worker fix:', error);
});




==== File: scripts\fix-sw-and-restart.js ====
// scripts/fix-sw-and-restart.js
/**
 * This script fixes service worker issues and restarts the development server
 * It combines the functionality of fix-service-worker.js with server restart
 */

const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

// Paths
const rootDir = path.resolve(__dirname, '..');
const swPath = path.join(rootDir, 'public', 'sw.js');
const swMapPath = path.join(rootDir, 'public', 'sw.js.map');
const workboxPath = path.join(rootDir, 'public', 'workbox-*.js');

// Check if we're on Windows
const isWindows = process.platform === 'win32';

// Colors for console output
const colors = {
  reset: '\x1b[0m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
};

console.log(`${colors.cyan}🔧 Starting service worker fix and server restart...${colors.reset}`);

// Step 1: Stop any running development server
try {
  console.log(`${colors.yellow}Stopping any running development servers...${colors.reset}`);
  if (isWindows) {
    execSync('taskkill /f /im node.exe', { stdio: 'ignore' });
  } else {
    execSync('pkill -f "next dev"', { stdio: 'ignore' });
  }
  console.log(`${colors.green}✅ Development servers stopped${colors.reset}`);
} catch (error) {
  console.log(`${colors.yellow}No running development servers found or could not be stopped${colors.reset}`);
}

// Step 2: Clear the Next.js cache
try {
  console.log(`${colors.yellow}Clearing Next.js cache...${colors.reset}`);
  const nextCacheDir = path.join(rootDir, '.next');
  if (fs.existsSync(nextCacheDir)) {
    if (isWindows) {
      execSync(`rmdir /s /q "${nextCacheDir}"`, { stdio: 'ignore' });
    } else {
      execSync(`rm -rf "${nextCacheDir}"`, { stdio: 'ignore' });
    }
  }
  console.log(`${colors.green}✅ Next.js cache cleared${colors.reset}`);
} catch (error) {
  console.error(`${colors.red}❌ Error clearing Next.js cache: ${error.message}${colors.reset}`);
}

// Step 3: Fix the service worker file if it exists
try {
  if (fs.existsSync(swPath)) {
    console.log(`${colors.yellow}Fixing service worker file...${colors.reset}`);
    
    // Read the service worker file
    let swContent = fs.readFileSync(swPath, 'utf8');
    
    // Fix the empty importScripts() call if it exists
    swContent = swContent.replace('importScripts();', '// No need to import additional scripts here');
    
    // Write the fixed content back
    fs.writeFileSync(swPath, swContent);
    
    console.log(`${colors.green}✅ Service worker file fixed${colors.reset}`);
  } else {
    console.log(`${colors.yellow}Service worker file not found, will be generated during build${colors.reset}`);
  }
} catch (error) {
  console.error(`${colors.red}❌ Error fixing service worker file: ${error.message}${colors.reset}`);
}

// Step 4: Restart the development server
try {
  console.log(`${colors.magenta}🚀 Restarting development server...${colors.reset}`);
  
  // Use npm run dev in a detached process
  const command = isWindows ? 'start cmd /c "npm run dev"' : 'npm run dev &';
  execSync(command, { stdio: 'ignore', shell: true });
  
  console.log(`${colors.green}✅ Development server restarted${colors.reset}`);
  console.log(`${colors.cyan}🌐 Your app should be available at http://localhost:3000 in a few moments${colors.reset}`);
} catch (error) {
  console.error(`${colors.red}❌ Error restarting development server: ${error.message}${colors.reset}`);
}

console.log(`${colors.green}✅ Service worker fix and server restart completed!${colors.reset}`);




==== File: scripts\reset-pwa.js ====
// scripts/reset-pwa.js
// This script helps reset the PWA state by clearing caches and unregistering service workers
// Run this in the browser console when you need to reset the PWA state

(async function resetPWA() {
  console.log('🧹 Starting PWA reset process...');
  
  // 1. Clear localStorage PWA-related items
  console.log('Clearing localStorage PWA flags...');
  localStorage.removeItem('pwaPromptSeen');
  
  // 2. Unregister all service workers
  if ('serviceWorker' in navigator) {
    console.log('Unregistering service workers...');
    const registrations = await navigator.serviceWorker.getRegistrations();
    
    if (registrations.length === 0) {
      console.log('No service workers registered.');
    } else {
      for (const registration of registrations) {
        try {
          await registration.unregister();
          console.log(`Service worker at scope ${registration.scope} unregistered.`);
        } catch (error) {
          console.error(`Failed to unregister service worker at ${registration.scope}:`, error);
        }
      }
    }
  } else {
    console.log('Service workers not supported in this browser.');
  }
  
  // 3. Clear all caches
  if ('caches' in window) {
    console.log('Clearing caches...');
    try {
      const cacheNames = await caches.keys();
      
      if (cacheNames.length === 0) {
        console.log('No caches found.');
      } else {
        for (const cacheName of cacheNames) {
          await caches.delete(cacheName);
          console.log(`Cache "${cacheName}" deleted.`);
        }
      }
    } catch (error) {
      console.error('Failed to clear caches:', error);
    }
  } else {
    console.log('Cache API not supported in this browser.');
  }
  
  // 4. Check for any installed related apps
  if ('getInstalledRelatedApps' in navigator) {
    try {
      const relatedApps = await navigator.getInstalledRelatedApps();
      console.log('Related installed apps:', relatedApps);
    } catch (error) {
      console.error('Error checking installed related apps:', error);
    }
  }
  
  console.log('✅ PWA reset complete! Please refresh the page.');
  console.log('To fully reset, you may also need to:');
  console.log('1. Close all tabs of this site');
  console.log('2. Clear browser cache and cookies for this domain');
  console.log('3. Restart your browser');
})();




