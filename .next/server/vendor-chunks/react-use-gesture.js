"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-use-gesture";
exports.ids = ["vendor-chunks/react-use-gesture"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-use-gesture/dist/react-use-gesture.esm.js":
/*!**********************************************************************!*\
  !*** ./node_modules/react-use-gesture/dist/react-use-gesture.esm.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addV: () => (/* binding */ addV),\n/* harmony export */   rubberbandIfOutOfBounds: () => (/* binding */ rubberbandIfOutOfBounds),\n/* harmony export */   subV: () => (/* binding */ subV),\n/* harmony export */   useDrag: () => (/* binding */ useDrag),\n/* harmony export */   useGesture: () => (/* binding */ useGesture),\n/* harmony export */   useHover: () => (/* binding */ useHover),\n/* harmony export */   useMove: () => (/* binding */ useMove),\n/* harmony export */   usePinch: () => (/* binding */ usePinch),\n/* harmony export */   useScroll: () => (/* binding */ useScroll),\n/* harmony export */   useWheel: () => (/* binding */ useWheel)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n// vector add\nfunction addV(v1, v2) {\n    return v1.map(function(v, i) {\n        return v + v2[i];\n    });\n} // vector substract\nfunction subV(v1, v2) {\n    return v1.map(function(v, i) {\n        return v - v2[i];\n    });\n}\n/**\r\n * Calculates distance\r\n * @param movement the difference between current and initial vectors\r\n * @returns distance\r\n */ function calculateDistance(movement) {\n    return Math.hypot.apply(Math, movement);\n}\nfunction calculateAllGeometry(movement, delta) {\n    if (delta === void 0) {\n        delta = movement;\n    }\n    var dl = calculateDistance(delta);\n    var alpha = dl === 0 ? 0 : 1 / dl;\n    var direction = delta.map(function(v) {\n        return alpha * v;\n    });\n    var distance = calculateDistance(movement);\n    return {\n        distance: distance,\n        direction: direction\n    };\n}\n/**\r\n * Calculates all kinematics\r\n * @template T the expected vector type\r\n * @param movement the difference between current and initial vectors\r\n * @param delta the difference between current and previous vectors\r\n * @param delta_t the time difference between current and previous timestamps\r\n * @returns all kinematics\r\n */ function calculateAllKinematics(movement, delta, dt) {\n    var dl = calculateDistance(delta);\n    var alpha = dl === 0 ? 0 : 1 / dl;\n    var beta = dt === 0 ? 0 : 1 / dt;\n    var velocity = beta * dl;\n    var velocities = delta.map(function(v) {\n        return beta * v;\n    });\n    var direction = delta.map(function(v) {\n        return alpha * v;\n    });\n    var distance = calculateDistance(movement);\n    return {\n        velocities: velocities,\n        velocity: velocity,\n        distance: distance,\n        direction: direction\n    };\n}\n/**\r\n * Because IE doesn't support `Math.sign` function, so we use the polyfill version of the function.\r\n * This polyfill function is suggested by Mozilla:\r\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign#Polyfill\r\n * @param x target number\r\n */ function sign(x) {\n    if (Math.sign) return Math.sign(x);\n    return Number(x > 0) - Number(x < 0) || +x;\n}\nfunction minMax(value, min, max) {\n    return Math.max(min, Math.min(value, max));\n} // Based on @aholachek ;)\n// https://twitter.com/chpwn/status/285540192096497664\n// iOS constant = 0.55\n// https://medium.com/@nathangitter/building-fluid-interfaces-ios-swift-9732bb934bf5\nfunction rubberband2(distance, constant) {\n    // default constant from the article is 0.7\n    return Math.pow(distance, constant * 5);\n}\nfunction rubberband(distance, dimension, constant) {\n    if (dimension === 0 || Math.abs(dimension) === Infinity) return rubberband2(distance, constant);\n    return distance * dimension * constant / (dimension + constant * distance);\n}\nfunction rubberbandIfOutOfBounds(position, min, max, constant) {\n    if (constant === void 0) {\n        constant = 0.15;\n    }\n    if (constant === 0) return minMax(position, min, max);\n    if (position < min) return -rubberband(min - position, max - min, constant) + min;\n    if (position > max) return +rubberband(position - max, max - min, constant) + max;\n    return position;\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\nfunction _extends() {\n    _extends = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    subClass.__proto__ = superClass;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n    var it;\n    if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n            if (it) o = it;\n            var i = 0;\n            return function() {\n                if (i >= o.length) return {\n                    done: true\n                };\n                return {\n                    done: false,\n                    value: o[i++]\n                };\n            };\n        }\n        throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n    it = o[Symbol.iterator]();\n    return it.next.bind(it);\n}\nfunction noop() {}\n/**\r\n * TODO Beware that only optimized cases are covered in tests =)\r\n * TODO Need to cover general case as well\r\n *\r\n * @param fns\r\n */ function chainFns() {\n    for(var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++){\n        fns[_key] = arguments[_key];\n    }\n    if (fns.length === 0) return noop;\n    if (fns.length === 1) return fns[0];\n    return function() {\n        var result;\n        for(var _iterator = _createForOfIteratorHelperLoose(fns), _step; !(_step = _iterator()).done;){\n            var fn = _step.value;\n            result = fn.apply(this, arguments) || result;\n        }\n        return result;\n    };\n}\n/**\r\n * Expects a simple value or 2D vector (an array with 2 elements) and\r\n * always returns 2D vector. If simple value is passed, returns a\r\n * vector with this value as both coordinates.\r\n *\r\n * @param value\r\n */ function ensureVector(value, fallback) {\n    if (value === undefined) {\n        if (fallback === undefined) {\n            throw new Error(\"Must define fallback value if undefined is expected\");\n        }\n        value = fallback;\n    }\n    if (Array.isArray(value)) return value;\n    return [\n        value,\n        value\n    ];\n}\n/**\r\n * Helper for defining a default value\r\n *\r\n * @param value\r\n * @param fallback\r\n */ function assignDefault(value, fallback) {\n    return Object.assign({}, fallback, value || {});\n}\n/**\r\n * Resolves getters (functions) by calling them\r\n * If simple value is given it just passes through\r\n *\r\n * @param v\r\n */ function valueFn(v) {\n    if (typeof v === \"function\") {\n        for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n            args[_key2 - 1] = arguments[_key2];\n        }\n        // @ts-ignore\n        return v.apply(void 0, args);\n    } else {\n        return v;\n    }\n}\nfunction resolveWith(config, resolvers) {\n    if (config === void 0) {\n        config = {};\n    }\n    var result = {};\n    for(var _i = 0, _Object$entries = Object.entries(resolvers); _i < _Object$entries.length; _i++){\n        var _Object$entries$_i = _Object$entries[_i], key = _Object$entries$_i[0], resolver = _Object$entries$_i[1];\n        switch(typeof resolver){\n            case \"function\":\n                result[key] = resolver.call(result, config[key], key, config);\n                break;\n            case \"object\":\n                result[key] = resolveWith(config[key], resolver);\n                break;\n            case \"boolean\":\n                if (resolver) result[key] = config[key];\n                break;\n        }\n    }\n    return result;\n}\nvar DEFAULT_DRAG_DELAY = 180;\nvar DEFAULT_RUBBERBAND = 0.15;\nvar DEFAULT_SWIPE_VELOCITY = 0.5;\nvar DEFAULT_SWIPE_DISTANCE = 60;\nvar InternalGestureOptionsNormalizers = {\n    threshold: function threshold(value) {\n        if (value === void 0) {\n            value = 0;\n        }\n        return ensureVector(value);\n    },\n    rubberband: function rubberband(value) {\n        if (value === void 0) {\n            value = 0;\n        }\n        switch(value){\n            case true:\n                return ensureVector(DEFAULT_RUBBERBAND);\n            case false:\n                return ensureVector(0);\n            default:\n                return ensureVector(value);\n        }\n    },\n    enabled: function enabled(value) {\n        if (value === void 0) {\n            value = true;\n        }\n        return value;\n    },\n    triggerAllEvents: function triggerAllEvents(value) {\n        if (value === void 0) {\n            value = false;\n        }\n        return value;\n    },\n    initial: function initial(value) {\n        if (value === void 0) {\n            value = 0;\n        }\n        if (typeof value === \"function\") return value;\n        return ensureVector(value);\n    }\n};\nvar InternalCoordinatesOptionsNormalizers = /*#__PURE__*/ _extends({}, InternalGestureOptionsNormalizers, {\n    axis: true,\n    lockDirection: function lockDirection(value) {\n        if (value === void 0) {\n            value = false;\n        }\n        return value;\n    },\n    bounds: function bounds(value) {\n        if (value === void 0) {\n            value = {};\n        }\n        if (typeof value === \"function\") return function(state) {\n            return InternalCoordinatesOptionsNormalizers.bounds(value(state));\n        };\n        var _value2 = value, _value2$left = _value2.left, left = _value2$left === void 0 ? -Infinity : _value2$left, _value2$right = _value2.right, right = _value2$right === void 0 ? Infinity : _value2$right, _value2$top = _value2.top, top = _value2$top === void 0 ? -Infinity : _value2$top, _value2$bottom = _value2.bottom, bottom = _value2$bottom === void 0 ? Infinity : _value2$bottom;\n        return [\n            [\n                left,\n                right\n            ],\n            [\n                top,\n                bottom\n            ]\n        ];\n    }\n});\nvar isBrowser =  false && 0;\nvar InternalGenericOptionsNormalizers = {\n    enabled: function enabled(value) {\n        if (value === void 0) {\n            value = true;\n        }\n        return value;\n    },\n    domTarget: true,\n    window: /*#__PURE__*/ function(_window) {\n        function window1(_x) {\n            return _window.apply(this, arguments);\n        }\n        window1.toString = function() {\n            return _window.toString();\n        };\n        return window1;\n    }(function(value) {\n        if (value === void 0) {\n            value = isBrowser ? window : undefined;\n        }\n        return value;\n    }),\n    eventOptions: function eventOptions(_temp) {\n        var _ref = _temp === void 0 ? {} : _temp, _ref$passive = _ref.passive, passive = _ref$passive === void 0 ? true : _ref$passive, _ref$capture = _ref.capture, capture = _ref$capture === void 0 ? false : _ref$capture;\n        return {\n            passive: passive,\n            capture: capture\n        };\n    }\n};\nvar InternalDistanceAngleOptionsNormalizers = /*#__PURE__*/ _extends({}, InternalGestureOptionsNormalizers, {\n    bounds: function bounds(_value, _key, _ref2) {\n        var _ref2$distanceBounds = _ref2.distanceBounds, distanceBounds = _ref2$distanceBounds === void 0 ? {} : _ref2$distanceBounds, _ref2$angleBounds = _ref2.angleBounds, angleBounds = _ref2$angleBounds === void 0 ? {} : _ref2$angleBounds;\n        var _distanceBounds = function _distanceBounds(state) {\n            var D = assignDefault(valueFn(distanceBounds, state), {\n                min: -Infinity,\n                max: Infinity\n            });\n            return [\n                D.min,\n                D.max\n            ];\n        };\n        var _angleBounds = function _angleBounds(state) {\n            var A = assignDefault(valueFn(angleBounds, state), {\n                min: -Infinity,\n                max: Infinity\n            });\n            return [\n                A.min,\n                A.max\n            ];\n        };\n        if (typeof distanceBounds !== \"function\" && typeof angleBounds !== \"function\") return [\n            _distanceBounds(),\n            _angleBounds()\n        ];\n        return function(state) {\n            return [\n                _distanceBounds(state),\n                _angleBounds(state)\n            ];\n        };\n    }\n});\nvar InternalDragOptionsNormalizers = /*#__PURE__*/ _extends({}, InternalCoordinatesOptionsNormalizers, {\n    threshold: function threshold(v, _k, _ref3) {\n        var _ref3$filterTaps = _ref3.filterTaps, filterTaps = _ref3$filterTaps === void 0 ? false : _ref3$filterTaps, _ref3$lockDirection = _ref3.lockDirection, lockDirection = _ref3$lockDirection === void 0 ? false : _ref3$lockDirection, _ref3$axis = _ref3.axis, axis = _ref3$axis === void 0 ? undefined : _ref3$axis;\n        var A = ensureVector(v, filterTaps ? 3 : lockDirection ? 1 : axis ? 1 : 0);\n        this.filterTaps = filterTaps || A[0] + A[1] > 0;\n        return A;\n    },\n    swipeVelocity: function swipeVelocity(v) {\n        if (v === void 0) {\n            v = DEFAULT_SWIPE_VELOCITY;\n        }\n        return ensureVector(v);\n    },\n    swipeDistance: function swipeDistance(v) {\n        if (v === void 0) {\n            v = DEFAULT_SWIPE_DISTANCE;\n        }\n        return ensureVector(v);\n    },\n    delay: function delay(value) {\n        if (value === void 0) {\n            value = 0;\n        }\n        switch(value){\n            case true:\n                return DEFAULT_DRAG_DELAY;\n            case false:\n                return 0;\n            default:\n                return value;\n        }\n    }\n});\nfunction getInternalGenericOptions(config) {\n    if (config === void 0) {\n        config = {};\n    }\n    // TODO warn when passive is set to true and domTarget is undefined\n    return resolveWith(config, InternalGenericOptionsNormalizers);\n}\nfunction getInternalCoordinatesOptions(config) {\n    if (config === void 0) {\n        config = {};\n    }\n    return resolveWith(config, InternalCoordinatesOptionsNormalizers);\n}\nfunction getInternalDistanceAngleOptions(config) {\n    if (config === void 0) {\n        config = {};\n    }\n    return resolveWith(config, InternalDistanceAngleOptionsNormalizers);\n}\nfunction getInternalDragOptions(config) {\n    if (config === void 0) {\n        config = {};\n    }\n    return resolveWith(config, InternalDragOptionsNormalizers);\n}\nfunction _buildMoveConfig(_ref) {\n    var domTarget = _ref.domTarget, eventOptions = _ref.eventOptions, window1 = _ref.window, enabled = _ref.enabled, rest = _objectWithoutPropertiesLoose(_ref, [\n        \"domTarget\",\n        \"eventOptions\",\n        \"window\",\n        \"enabled\"\n    ]);\n    var opts = getInternalGenericOptions({\n        domTarget: domTarget,\n        eventOptions: eventOptions,\n        window: window1,\n        enabled: enabled\n    });\n    opts.move = getInternalCoordinatesOptions(rest);\n    return opts;\n}\nfunction _buildHoverConfig(_ref2) {\n    var domTarget = _ref2.domTarget, eventOptions = _ref2.eventOptions, window1 = _ref2.window, enabled = _ref2.enabled, rest = _objectWithoutPropertiesLoose(_ref2, [\n        \"domTarget\",\n        \"eventOptions\",\n        \"window\",\n        \"enabled\"\n    ]);\n    var opts = getInternalGenericOptions({\n        domTarget: domTarget,\n        eventOptions: eventOptions,\n        window: window1,\n        enabled: enabled\n    });\n    opts.hover = _extends({\n        enabled: true\n    }, rest);\n    return opts;\n}\nfunction _buildDragConfig(_ref3) {\n    var domTarget = _ref3.domTarget, eventOptions = _ref3.eventOptions, window1 = _ref3.window, enabled = _ref3.enabled, rest = _objectWithoutPropertiesLoose(_ref3, [\n        \"domTarget\",\n        \"eventOptions\",\n        \"window\",\n        \"enabled\"\n    ]);\n    var opts = getInternalGenericOptions({\n        domTarget: domTarget,\n        eventOptions: eventOptions,\n        window: window1,\n        enabled: enabled\n    });\n    opts.drag = getInternalDragOptions(rest);\n    return opts;\n}\nfunction _buildPinchConfig(_ref4) {\n    var domTarget = _ref4.domTarget, eventOptions = _ref4.eventOptions, window1 = _ref4.window, enabled = _ref4.enabled, rest = _objectWithoutPropertiesLoose(_ref4, [\n        \"domTarget\",\n        \"eventOptions\",\n        \"window\",\n        \"enabled\"\n    ]);\n    var opts = getInternalGenericOptions({\n        domTarget: domTarget,\n        eventOptions: eventOptions,\n        window: window1,\n        enabled: enabled\n    });\n    opts.pinch = getInternalDistanceAngleOptions(rest);\n    return opts;\n}\nfunction _buildScrollConfig(_ref5) {\n    var domTarget = _ref5.domTarget, eventOptions = _ref5.eventOptions, window1 = _ref5.window, enabled = _ref5.enabled, rest = _objectWithoutPropertiesLoose(_ref5, [\n        \"domTarget\",\n        \"eventOptions\",\n        \"window\",\n        \"enabled\"\n    ]);\n    var opts = getInternalGenericOptions({\n        domTarget: domTarget,\n        eventOptions: eventOptions,\n        window: window1,\n        enabled: enabled\n    });\n    opts.scroll = getInternalCoordinatesOptions(rest);\n    return opts;\n}\nfunction _buildWheelConfig(_ref6) {\n    var domTarget = _ref6.domTarget, eventOptions = _ref6.eventOptions, window1 = _ref6.window, enabled = _ref6.enabled, rest = _objectWithoutPropertiesLoose(_ref6, [\n        \"domTarget\",\n        \"eventOptions\",\n        \"window\",\n        \"enabled\"\n    ]);\n    var opts = getInternalGenericOptions({\n        domTarget: domTarget,\n        eventOptions: eventOptions,\n        window: window1,\n        enabled: enabled\n    });\n    opts.wheel = getInternalCoordinatesOptions(rest);\n    return opts;\n}\nfunction buildComplexConfig(config, actions) {\n    if (config === void 0) {\n        config = {};\n    }\n    if (actions === void 0) {\n        actions = new Set();\n    }\n    var _config = config, drag = _config.drag, wheel = _config.wheel, move = _config.move, scroll = _config.scroll, pinch = _config.pinch, hover = _config.hover, eventOptions = _config.eventOptions, window1 = _config.window, domTarget = _config.domTarget, enabled = _config.enabled;\n    var mergedConfig = getInternalGenericOptions({\n        eventOptions: eventOptions,\n        window: window1,\n        domTarget: domTarget,\n        enabled: enabled\n    });\n    if (actions.has(\"onDrag\")) mergedConfig.drag = getInternalDragOptions(drag);\n    if (actions.has(\"onWheel\")) mergedConfig.wheel = getInternalCoordinatesOptions(wheel);\n    if (actions.has(\"onScroll\")) mergedConfig.scroll = getInternalCoordinatesOptions(scroll);\n    if (actions.has(\"onMove\")) mergedConfig.move = getInternalCoordinatesOptions(move);\n    if (actions.has(\"onPinch\")) mergedConfig.pinch = getInternalDistanceAngleOptions(pinch);\n    if (actions.has(\"onHover\")) mergedConfig.hover = _extends({\n        enabled: true\n    }, hover);\n    return mergedConfig;\n}\nfunction getInitial(mixed) {\n    return _extends({\n        _active: false,\n        _blocked: false,\n        _intentional: [\n            false,\n            false\n        ],\n        _movement: [\n            0,\n            0\n        ],\n        _initial: [\n            0,\n            0\n        ],\n        _bounds: [\n            [\n                -Infinity,\n                Infinity\n            ],\n            [\n                -Infinity,\n                Infinity\n            ]\n        ],\n        _lastEventType: undefined,\n        event: undefined,\n        // currentTarget: undefined,\n        // pointerId: undefined,\n        intentional: false,\n        values: [\n            0,\n            0\n        ],\n        velocities: [\n            0,\n            0\n        ],\n        delta: [\n            0,\n            0\n        ],\n        movement: [\n            0,\n            0\n        ],\n        offset: [\n            0,\n            0\n        ],\n        lastOffset: [\n            0,\n            0\n        ],\n        direction: [\n            0,\n            0\n        ],\n        initial: [\n            0,\n            0\n        ],\n        previous: [\n            0,\n            0\n        ],\n        first: false,\n        last: false,\n        active: false,\n        timeStamp: 0,\n        startTime: 0,\n        elapsedTime: 0,\n        cancel: noop,\n        canceled: false,\n        memo: undefined,\n        args: undefined\n    }, mixed);\n}\nfunction getInitialState() {\n    var shared = {\n        hovering: false,\n        scrolling: false,\n        wheeling: false,\n        dragging: false,\n        moving: false,\n        pinching: false,\n        touches: 0,\n        buttons: 0,\n        down: false,\n        shiftKey: false,\n        altKey: false,\n        metaKey: false,\n        ctrlKey: false\n    };\n    var drag = getInitial({\n        axis: undefined,\n        xy: [\n            0,\n            0\n        ],\n        vxvy: [\n            0,\n            0\n        ],\n        velocity: 0,\n        distance: 0,\n        _isTap: true,\n        _delayedEvent: false,\n        _pointerId: undefined,\n        tap: false,\n        swipe: [\n            0,\n            0\n        ]\n    });\n    var pinch = getInitial({\n        da: [\n            0,\n            0\n        ],\n        vdva: [\n            0,\n            0\n        ],\n        // @ts-ignore origin can never be passed as undefined in userland\n        origin: undefined,\n        turns: 0\n    });\n    var wheel = getInitial({\n        axis: undefined,\n        xy: [\n            0,\n            0\n        ],\n        vxvy: [\n            0,\n            0\n        ],\n        velocity: 0,\n        distance: 0\n    });\n    var move = getInitial({\n        axis: undefined,\n        xy: [\n            0,\n            0\n        ],\n        vxvy: [\n            0,\n            0\n        ],\n        velocity: 0,\n        distance: 0\n    });\n    var scroll = getInitial({\n        axis: undefined,\n        xy: [\n            0,\n            0\n        ],\n        vxvy: [\n            0,\n            0\n        ],\n        velocity: 0,\n        distance: 0\n    });\n    return {\n        shared: shared,\n        drag: drag,\n        pinch: pinch,\n        wheel: wheel,\n        move: move,\n        scroll: scroll\n    };\n}\nvar RecognizersMap = /*#__PURE__*/ new Map();\n/**\r\n * @private\r\n * Recognizer abstract class.\r\n */ var Recognizer = /*#__PURE__*/ function() {\n    /**\r\n   * Creates an instance of a gesture recognizer.\r\n   * @param stateKey drag, move, pinch, etc.\r\n   * @param controller the controller attached to the gesture\r\n   * @param [args] the args that should be passed to the gesture handler\r\n   */ function Recognizer(controller, args) {\n        var _this = this;\n        if (args === void 0) {\n            args = [];\n        }\n        this.controller = controller;\n        this.args = args;\n        this.debounced = true; // Convenience method to set a timeout for a given gesture\n        this.setTimeout = function(callback, ms) {\n            var _window;\n            if (ms === void 0) {\n                ms = 140;\n            }\n            clearTimeout(_this.controller.timeouts[_this.stateKey]);\n            for(var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){\n                args[_key - 2] = arguments[_key];\n            }\n            _this.controller.timeouts[_this.stateKey] = (_window = window).setTimeout.apply(_window, [\n                callback,\n                ms\n            ].concat(args));\n        }; // Convenience method to clear a timeout for a given gesture\n        this.clearTimeout = function() {\n            clearTimeout(_this.controller.timeouts[_this.stateKey]);\n        };\n        /**\r\n     * Fires the gesture handler\r\n     */ this.fireGestureHandler = function(forceFlag) {\n            if (forceFlag === void 0) {\n                forceFlag = false;\n            }\n            /**\r\n       * If the gesture has been blocked (this can happen when the gesture has started in an unwanted direction),\r\n       * clean everything and don't do anything.\r\n       */ if (_this.state._blocked) {\n                // we need debounced gestures to end by themselves\n                if (!_this.debounced) {\n                    _this.state._active = false;\n                    _this.clean();\n                }\n                return null;\n            } // If the gesture has no intentional dimension, don't fire the handler.\n            if (!forceFlag && !_this.state.intentional && !_this.config.triggerAllEvents) return null;\n            if (_this.state.intentional) {\n                var prev_active = _this.state.active;\n                var next_active = _this.state._active;\n                _this.state.active = next_active;\n                _this.state.first = next_active && !prev_active;\n                _this.state.last = prev_active && !next_active;\n                _this.controller.state.shared[_this.ingKey] = next_active; // Sets dragging, pinching, etc. to the gesture active state\n            }\n            var state = _extends({}, _this.controller.state.shared, _this.state, _this.mapStateValues(_this.state)); // @ts-ignore\n            var newMemo = _this.handler(state); // Sets memo to the returned value of the handler (unless it's not undefined)\n            _this.state.memo = newMemo !== void 0 ? newMemo : _this.state.memo; // Cleans the gesture when the gesture is no longer active.\n            if (!_this.state._active) _this.clean();\n            return state;\n        };\n    } // Returns the gesture config\n    var _proto = Recognizer.prototype;\n    // Convenience method to update the shared state\n    _proto.updateSharedState = function updateSharedState(sharedState) {\n        Object.assign(this.controller.state.shared, sharedState);\n    } // Convenience method to update the gesture state\n    ;\n    _proto.updateGestureState = function updateGestureState(gestureState) {\n        Object.assign(this.state, gestureState);\n    } /**\r\n   * Returns state properties depending on the movement and state.\r\n   *\r\n   * Should be overriden for custom behavior, doesn't do anything in the implementation\r\n   * below.\r\n   */ ;\n    _proto.checkIntentionality = function checkIntentionality(_intentional, _movement) {\n        return {\n            _intentional: _intentional,\n            _blocked: false\n        };\n    } /**\r\n   * Returns basic movement properties for the gesture based on the next values and current state.\r\n   */ ;\n    _proto.getMovement = function getMovement(values) {\n        var _this$config = this.config, initial = _this$config.initial, bounds = _this$config.bounds, rubberband = _this$config.rubberband, T = _this$config.threshold;\n        var _this$state = this.state, _bounds = _this$state._bounds, _initial = _this$state._initial, _active = _this$state._active, wasIntentional = _this$state._intentional, lastOffset = _this$state.lastOffset, prevMovement = _this$state.movement;\n        var M = this.getInternalMovement(values, this.state);\n        var i0 = wasIntentional[0] === false ? getIntentionalDisplacement(M[0], T[0]) : wasIntentional[0];\n        var i1 = wasIntentional[1] === false ? getIntentionalDisplacement(M[1], T[1]) : wasIntentional[1]; // Get gesture specific state properties based on intentionality and movement.\n        var intentionalityCheck = this.checkIntentionality([\n            i0,\n            i1\n        ], M);\n        if (intentionalityCheck._blocked) {\n            return _extends({}, intentionalityCheck, {\n                _movement: M,\n                delta: [\n                    0,\n                    0\n                ]\n            });\n        }\n        var _intentional = intentionalityCheck._intentional;\n        var _movement = M;\n        var __cachedBounds;\n        var __cachedInitial;\n        if (_intentional[0] !== false && wasIntentional[0] === false) {\n            __cachedInitial = valueFn(initial, this.state);\n            __cachedBounds = valueFn(bounds, this.state);\n            _initial[0] = __cachedInitial[0];\n            _bounds[0] = __cachedBounds[0];\n        }\n        if (_intentional[1] !== false && wasIntentional[1] === false) {\n            var _cachedInitial, _cachedBounds;\n            __cachedInitial = (_cachedInitial = __cachedInitial) != null ? _cachedInitial : valueFn(initial, this.state);\n            __cachedBounds = (_cachedBounds = __cachedBounds) != null ? _cachedBounds : valueFn(bounds, this.state);\n            _initial[1] = __cachedInitial[1];\n            _bounds[1] = __cachedBounds[1];\n        }\n        /**\r\n     * The movement sent to the handler has 0 in its dimensions when intentionality is false.\r\n     * It is calculated from the actual movement minus the threshold.\r\n     */ var movement = [\n            _intentional[0] !== false ? M[0] - _intentional[0] : _initial[0],\n            _intentional[1] !== false ? M[1] - _intentional[1] : _initial[1]\n        ];\n        var offset = addV(movement, lastOffset);\n        /**\r\n     * Rubberband should be 0 when the gesture is no longer active, so that movement\r\n     * and offset can return within their bounds.\r\n     */ var _rubberband = _active ? rubberband : [\n            0,\n            0\n        ];\n        movement = computeRubberband(_bounds, addV(movement, _initial), _rubberband);\n        return _extends({}, intentionalityCheck, {\n            intentional: _intentional[0] !== false || _intentional[1] !== false,\n            _initial: _initial,\n            _movement: _movement,\n            movement: movement,\n            values: values,\n            offset: computeRubberband(_bounds, offset, _rubberband),\n            delta: subV(movement, prevMovement)\n        });\n    } // Cleans the gesture. Can be overriden by gestures.\n    ;\n    _proto.clean = function clean() {\n        this.clearTimeout();\n    };\n    _createClass(Recognizer, [\n        {\n            key: \"config\",\n            get: function get() {\n                return this.controller.config[this.stateKey];\n            } // Is the gesture enabled\n        },\n        {\n            key: \"enabled\",\n            get: function get() {\n                return this.controller.config.enabled && this.config.enabled;\n            } // Returns the controller state for a given gesture\n        },\n        {\n            key: \"state\",\n            get: function get() {\n                return this.controller.state[this.stateKey];\n            } // Returns the gesture handler\n        },\n        {\n            key: \"handler\",\n            get: function get() {\n                return this.controller.handlers[this.stateKey];\n            }\n        }\n    ]);\n    return Recognizer;\n}(); //--------------------------------------------\nfunction getIntentionalDisplacement(movement, threshold) {\n    if (Math.abs(movement) >= threshold) {\n        return sign(movement) * threshold;\n    } else {\n        return false;\n    }\n}\nfunction computeRubberband(bounds, _ref, _ref2) {\n    var Vx = _ref[0], Vy = _ref[1];\n    var Rx = _ref2[0], Ry = _ref2[1];\n    var _bounds$ = bounds[0], X1 = _bounds$[0], X2 = _bounds$[1], _bounds$2 = bounds[1], Y1 = _bounds$2[0], Y2 = _bounds$2[1];\n    return [\n        rubberbandIfOutOfBounds(Vx, X1, X2, Rx),\n        rubberbandIfOutOfBounds(Vy, Y1, Y2, Ry)\n    ];\n}\n/**\r\n * Returns a generic, common payload for all gestures from an event.\r\n */ function getGenericPayload(_ref3, event, isStartEvent) {\n    var state = _ref3.state, args = _ref3.args;\n    var timeStamp = event.timeStamp, _lastEventType = event.type;\n    var previous = state.values;\n    var elapsedTime = isStartEvent ? 0 : timeStamp - state.startTime;\n    return {\n        _lastEventType: _lastEventType,\n        event: event,\n        timeStamp: timeStamp,\n        elapsedTime: elapsedTime,\n        args: args,\n        previous: previous\n    };\n}\n/**\r\n * Returns the reinitialized start state for the gesture.\r\n * Should be common to all gestures.\r\n */ function getStartGestureState(recognizer, values, event) {\n    var offset = recognizer.state.offset;\n    var startTime = event.timeStamp;\n    return _extends({}, getInitialState()[recognizer.stateKey], {\n        _active: true,\n        values: values,\n        initial: values,\n        offset: offset,\n        lastOffset: offset,\n        startTime: startTime\n    });\n}\nfunction partial(func, state) {\n    return function(event) {\n        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            args[_key - 1] = arguments[_key];\n        }\n        // @ts-ignore\n        return func.call.apply(func, [\n            this,\n            _extends({}, state, {\n                event: event\n            })\n        ].concat(args));\n    };\n}\n/**\r\n * The controller will keep track of the state for all gestures and also keep\r\n * track of timeouts, and window listeners.\r\n */ var Controller = function Controller(classes) {\n    var _this = this;\n    this.classes = classes;\n    this.bind = function() {\n        var bindings = {};\n        for(var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){\n            args[_key2] = arguments[_key2];\n        }\n        for(var _iterator = _createForOfIteratorHelperLoose(_this.classes), _step; !(_step = _iterator()).done;){\n            var RecognizerClass = _step.value;\n            new RecognizerClass(_this, args).addBindings(bindings);\n        } // we also add event bindings for native handlers\n        for(var _i = 0, _Object$entries = Object.entries(_this.nativeRefs); _i < _Object$entries.length; _i++){\n            var _Object$entries$_i = _Object$entries[_i], event = _Object$entries$_i[0], handler = _Object$entries$_i[1];\n            addBindings(bindings, event, partial(handler, _extends({}, _this.state.shared, {\n                args: args\n            })));\n        }\n        if (_this.config.domTarget) {\n            // If config.domTarget is set we add event listeners to it and return the clean function.\n            return updateDomListeners(_this, bindings);\n        } else {\n            // If not, we return an object that contains gesture handlers mapped to react handler event keys.\n            return getPropsListener(_this, bindings);\n        }\n    };\n    this.effect = function() {\n        if (_this.config.domTarget) _this.bind();\n        return _this.clean;\n    };\n    /**\r\n   * Function ran on component unmount: cleans timeouts and removes dom listeners set by the bind function.\r\n   */ this.clean = function() {\n        var domTarget = getDomTargetFromConfig(_this.config);\n        var eventOptions = _this.config.eventOptions;\n        if (domTarget) removeListeners(domTarget, takeAll(_this.domListeners), eventOptions);\n        Object.values(_this.timeouts).forEach(clearTimeout);\n        clearAllWindowListeners(_this);\n    };\n    this.state = getInitialState();\n    this.timeouts = {};\n    this.domListeners = [];\n    this.windowListeners = {};\n};\nfunction clearAllWindowListeners(controller) {\n    var _controller$config = controller.config, el = _controller$config.window, eventOptions = _controller$config.eventOptions, windowListeners = controller.windowListeners;\n    if (!el) return;\n    for(var stateKey in windowListeners){\n        var handlers = windowListeners[stateKey];\n        removeListeners(el, handlers, eventOptions);\n    }\n    controller.windowListeners = {};\n}\nfunction clearWindowListeners(_ref, stateKey) {\n    var config = _ref.config, windowListeners = _ref.windowListeners;\n    if (!config.window) return;\n    removeListeners(config.window, windowListeners[stateKey], config.eventOptions);\n    delete windowListeners[stateKey];\n}\nfunction updateWindowListeners(_ref2, stateKey, listeners) {\n    var config = _ref2.config, windowListeners = _ref2.windowListeners;\n    if (listeners === void 0) {\n        listeners = [];\n    }\n    if (!config.window) return;\n    removeListeners(config.window, windowListeners[stateKey], config.eventOptions);\n    addListeners(config.window, windowListeners[stateKey] = listeners, config.eventOptions);\n}\nfunction updateDomListeners(_ref3, bindings) {\n    var config = _ref3.config, domListeners = _ref3.domListeners;\n    var domTarget = getDomTargetFromConfig(config);\n    if (!domTarget) throw new Error(\"domTarget must be defined\");\n    var eventOptions = config.eventOptions;\n    removeListeners(domTarget, takeAll(domListeners), eventOptions);\n    for(var _i2 = 0, _Object$entries2 = Object.entries(bindings); _i2 < _Object$entries2.length; _i2++){\n        var _Object$entries2$_i = _Object$entries2[_i2], key = _Object$entries2$_i[0], fns = _Object$entries2$_i[1];\n        var name = key.slice(2).toLowerCase();\n        domListeners.push([\n            name,\n            chainFns.apply(void 0, fns)\n        ]);\n    }\n    addListeners(domTarget, domListeners, eventOptions);\n}\nfunction getPropsListener(_ref4, bindings) {\n    var config = _ref4.config;\n    var props = {};\n    var captureString = config.eventOptions.capture ? \"Capture\" : \"\";\n    for(var _i3 = 0, _Object$entries3 = Object.entries(bindings); _i3 < _Object$entries3.length; _i3++){\n        var _Object$entries3$_i = _Object$entries3[_i3], event = _Object$entries3$_i[0], fns = _Object$entries3$_i[1];\n        var fnsArray = Array.isArray(fns) ? fns : [\n            fns\n        ];\n        var key = event + captureString;\n        props[key] = chainFns.apply(void 0, fnsArray);\n    }\n    return props;\n}\nfunction takeAll(array) {\n    if (array === void 0) {\n        array = [];\n    }\n    return array.splice(0, array.length);\n}\nfunction getDomTargetFromConfig(_ref5) {\n    var domTarget = _ref5.domTarget;\n    return domTarget && \"current\" in domTarget ? domTarget.current : domTarget;\n}\n/**\r\n * bindings is an object which keys match ReactEventHandlerKeys.\r\n * Since a recognizer might want to bind a handler function to an event key already used by a previously\r\n * added recognizer, we need to make sure that each event key is an array of all the functions mapped for\r\n * that key.\r\n */ function addBindings(bindings, name, fn) {\n    if (!bindings[name]) bindings[name] = [];\n    bindings[name].push(fn);\n}\nfunction addListeners(el, listeners, options) {\n    if (listeners === void 0) {\n        listeners = [];\n    }\n    if (options === void 0) {\n        options = {};\n    }\n    for(var _iterator2 = _createForOfIteratorHelperLoose(listeners), _step2; !(_step2 = _iterator2()).done;){\n        var _step2$value = _step2.value, eventName = _step2$value[0], eventHandler = _step2$value[1];\n        el.addEventListener(eventName, eventHandler, options);\n    }\n}\nfunction removeListeners(el, listeners, options) {\n    if (listeners === void 0) {\n        listeners = [];\n    }\n    if (options === void 0) {\n        options = {};\n    }\n    for(var _iterator3 = _createForOfIteratorHelperLoose(listeners), _step3; !(_step3 = _iterator3()).done;){\n        var _step3$value = _step3.value, eventName = _step3$value[0], eventHandler = _step3$value[1];\n        el.removeEventListener(eventName, eventHandler, options);\n    }\n}\n/* eslint-disable react-hooks/exhaustive-deps */ /**\r\n * Utility hook called by all gesture hooks and that will be responsible for the internals.\r\n *\r\n * @param handlers\r\n * @param classes\r\n * @param config\r\n * @param nativeHandlers - native handlers such as onClick, onMouseDown, etc.\r\n */ function useRecognizers(handlers, config, nativeHandlers) {\n    if (nativeHandlers === void 0) {\n        nativeHandlers = {};\n    }\n    var classes = resolveClasses(handlers);\n    var controller = react__WEBPACK_IMPORTED_MODULE_0___default().useMemo(function() {\n        return new Controller(classes);\n    }, []);\n    controller.config = config;\n    controller.handlers = handlers;\n    controller.nativeRefs = nativeHandlers;\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(controller.effect, []); // @ts-ignore\n    if (controller.config.domTarget) return deprecationNoticeForDomTarget; // @ts-ignore\n    return controller.bind;\n}\nfunction deprecationNoticeForDomTarget() {\n    if (true) {\n        console.warn(\"Deprecation notice: When the `domTarget` option is specified, you don't need to write `useEffect(bind, [bind])` anymore: event binding is now made handled internally to this lib.\\n\\nNext version won't return anything when `domTarget` is provided, therefore your code will break if you try to call `useEffect`.\");\n    }\n}\nfunction resolveClasses(internalHandlers) {\n    var classes = new Set();\n    if (internalHandlers.drag) classes.add(RecognizersMap.get(\"drag\"));\n    if (internalHandlers.wheel) classes.add(RecognizersMap.get(\"wheel\"));\n    if (internalHandlers.scroll) classes.add(RecognizersMap.get(\"scroll\"));\n    if (internalHandlers.move) classes.add(RecognizersMap.get(\"move\"));\n    if (internalHandlers.pinch) classes.add(RecognizersMap.get(\"pinch\"));\n    if (internalHandlers.hover) classes.add(RecognizersMap.get(\"hover\"));\n    return classes;\n}\n/**\r\n * @private\r\n * Abstract class for coordinates-based gesture recongizers\r\n */ var CoordinatesRecognizer = /*#__PURE__*/ function(_Recognizer) {\n    _inheritsLoose(CoordinatesRecognizer, _Recognizer);\n    function CoordinatesRecognizer() {\n        return _Recognizer.apply(this, arguments) || this;\n    }\n    var _proto = CoordinatesRecognizer.prototype;\n    /**\r\n   * Returns the real movement (without taking intentionality into acount)\r\n   */ _proto.getInternalMovement = function getInternalMovement(values, state) {\n        return subV(values, state.initial);\n    } /**\r\n   * In coordinates-based gesture, this function will detect the first intentional axis,\r\n   * lock the gesture axis if lockDirection is specified in the config, block the gesture\r\n   * if the first intentional axis doesn't match the specified axis in config.\r\n   */ ;\n    _proto.checkIntentionality = function checkIntentionality(_intentional, _movement) {\n        if (_intentional[0] === false && _intentional[1] === false) {\n            return {\n                _intentional: _intentional,\n                axis: this.state.axis\n            };\n        }\n        var _movement$map = _movement.map(Math.abs), absX = _movement$map[0], absY = _movement$map[1];\n        var axis = this.state.axis || (absX > absY ? \"x\" : absX < absY ? \"y\" : undefined);\n        if (!this.config.axis && !this.config.lockDirection) return {\n            _intentional: _intentional,\n            _blocked: false,\n            axis: axis\n        };\n        if (!axis) return {\n            _intentional: [\n                false,\n                false\n            ],\n            _blocked: false,\n            axis: axis\n        };\n        if (!!this.config.axis && axis !== this.config.axis) return {\n            _intentional: _intentional,\n            _blocked: true,\n            axis: axis\n        };\n        _intentional[axis === \"x\" ? 1 : 0] = false;\n        return {\n            _intentional: _intentional,\n            _blocked: false,\n            axis: axis\n        };\n    };\n    _proto.getKinematics = function getKinematics(values, event) {\n        var state = this.getMovement(values);\n        if (!state._blocked) {\n            var dt = event.timeStamp - this.state.timeStamp;\n            Object.assign(state, calculateAllKinematics(state.movement, state.delta, dt));\n        }\n        return state;\n    };\n    _proto.mapStateValues = function mapStateValues(state) {\n        return {\n            xy: state.values,\n            vxvy: state.velocities\n        };\n    };\n    return CoordinatesRecognizer;\n}(Recognizer);\nvar WEBKIT_DISTANCE_SCALE_FACTOR = 260;\n/**\r\n * Whether the browser supports GestureEvent (ie Safari)\r\n * @returns true if the browser supports gesture event\r\n */ function supportsGestureEvents() {\n    try {\n        // TODO [TS] possibly find GestureEvent definitions?\n        // @ts-ignore: no type definitions for webkit GestureEvents\n        return \"constructor\" in GestureEvent;\n    } catch (e) {\n        return false;\n    }\n}\nfunction supportsTouchEvents() {\n    return  false && 0;\n}\nfunction getTouchEvents(event) {\n    if (\"touches\" in event) {\n        var targetTouches = event.targetTouches, changedTouches = event.changedTouches;\n        return targetTouches.length > 0 ? targetTouches : changedTouches;\n    }\n    return null;\n}\nfunction getGenericEventData(event) {\n    var buttons = \"buttons\" in event ? event.buttons : 0;\n    var touchEvents = getTouchEvents(event);\n    var touches = touchEvents && touchEvents.length || 0;\n    var down = touches > 0 || buttons > 0;\n    var shiftKey = event.shiftKey, altKey = event.altKey, metaKey = event.metaKey, ctrlKey = event.ctrlKey; // TODO check if this might create some overrides?\n    return {\n        touches: touches,\n        down: down,\n        buttons: buttons,\n        shiftKey: shiftKey,\n        altKey: altKey,\n        metaKey: metaKey,\n        ctrlKey: ctrlKey\n    };\n}\n/**\r\n * Gets pointer event values.\r\n * @param event\r\n * @returns pointer event values\r\n */ function getPointerEventValues(event) {\n    var touchEvents = getTouchEvents(event);\n    var _ref = touchEvents ? touchEvents[0] : event, clientX = _ref.clientX, clientY = _ref.clientY;\n    return [\n        clientX,\n        clientY\n    ];\n}\n/**\r\n * Gets scroll event values\r\n * @param event\r\n * @returns scroll event values\r\n */ function getScrollEventValues(event) {\n    // If the currentTarget is the window then we return the scrollX/Y position.\n    // If not (ie the currentTarget is a DOM element), then we return scrollLeft/Top\n    var _event$currentTarget = event.currentTarget, scrollX = _event$currentTarget.scrollX, scrollY = _event$currentTarget.scrollY, scrollLeft = _event$currentTarget.scrollLeft, scrollTop = _event$currentTarget.scrollTop;\n    return [\n        scrollX || scrollLeft || 0,\n        scrollY || scrollTop || 0\n    ];\n}\n/**\r\n * Gets wheel event values.\r\n * @param event\r\n * @returns wheel event values\r\n */ function getWheelEventValues(event) {\n    var deltaX = event.deltaX, deltaY = event.deltaY; //TODO implement polyfill ?\n    // https://developer.mozilla.org/en-US/docs/Web/Events/wheel#Polyfill\n    return [\n        deltaX,\n        deltaY\n    ];\n}\n/**\r\n * Gets webkit gesture event values.\r\n * @param event\r\n * @returns webkit gesture event values\r\n */ function getWebkitGestureEventValues(event) {\n    return [\n        event.scale * WEBKIT_DISTANCE_SCALE_FACTOR,\n        event.rotation\n    ];\n}\n/**\r\n * Gets two touches event data\r\n * @param event\r\n * @returns two touches event data\r\n */ function getTwoTouchesEventData(event) {\n    var _e$rotation;\n    var targetTouches = event.targetTouches;\n    var A = targetTouches[0], B = targetTouches[1];\n    var dx = B.clientX - A.clientX;\n    var dy = B.clientY - A.clientY;\n    var cx = (B.clientX + A.clientX) / 2;\n    var cy = (B.clientY + A.clientY) / 2;\n    var e = \"nativeEvent\" in event ? event.nativeEvent : event;\n    var distance = Math.hypot(dx, dy);\n    var angle = (_e$rotation = e.rotation) != null ? _e$rotation : -(Math.atan2(dx, dy) * 180) / Math.PI;\n    var values = [\n        distance,\n        angle\n    ];\n    var origin = [\n        cx,\n        cy\n    ];\n    return {\n        values: values,\n        origin: origin\n    };\n}\nvar TAP_DISTANCE_THRESHOLD = 3;\nvar SWIPE_MAX_ELAPSED_TIME = 220;\nvar DragRecognizer = /*#__PURE__*/ function(_CoordinatesRecognize) {\n    _inheritsLoose(DragRecognizer, _CoordinatesRecognize);\n    function DragRecognizer() {\n        var _this;\n        _this = _CoordinatesRecognize.apply(this, arguments) || this;\n        _this.ingKey = \"dragging\";\n        _this.stateKey = \"drag\";\n        /**\r\n     * TODO add back when setPointerCapture is widely wupported\r\n     * https://caniuse.com/#search=setPointerCapture\r\n     * private setPointers = (event: UseGestureEvent<PointerEvent>) => {\r\n     *   const { currentTarget, pointerId } = event\r\n     *   if (currentTarget) currentTarget.setPointerCapture(pointerId)\r\n     *   this.updateGestureState({ currentTarget, pointerId })\r\n     * }\r\n            * private removePointers = () => {\r\n     *   const { currentTarget, pointerId } = this.state\r\n     *   if (currentTarget && pointerId) currentTarget.releasePointerCapture(pointerId)\r\n     * }\r\n     */ _this.onDragStart = function(event) {\n            if (!_this.enabled || _this.state._active) return;\n            /**\r\n       * TODO add back when setPointerCapture is widely supported\r\n       * this.setPointers(event as PointerEvent)\r\n       */ updateWindowListeners(_this.controller, _this.stateKey, [\n                [\n                    \"pointermove\",\n                    _this.onDragChange\n                ],\n                [\n                    \"pointerup\",\n                    _this.onDragEnd\n                ],\n                [\n                    \"pointercancel\",\n                    _this.onDragEnd\n                ]\n            ]); // We set the state pointerId to the event.pointerId so we can make sure\n            // that we lock the drag to the event initiating the gesture\n            _this.updateGestureState({\n                _pointerId: event.pointerId\n            });\n            if (_this.config.delay > 0) {\n                _this.state._delayedEvent = true; // If it's a React SyntheticEvent we need to persist it so that we can use it async\n                if (\"persist\" in event && typeof event.persist === \"function\") event.persist();\n                _this.setTimeout(_this.startDrag.bind(_assertThisInitialized(_this)), _this.config.delay, event);\n            } else {\n                _this.startDrag(event);\n            }\n        };\n        _this.onDragChange = function(event) {\n            // If the gesture was canceled don't respond to the event.\n            if (_this.state.canceled) return; // If the event pointerId doesn't match the initiating pointerId\n            // don't respond to the event.\n            if (event.pointerId !== _this.state._pointerId) return; // If the gesture isn't active then respond to the event only if\n            // it's been delayed via the `delay` option, in which case start\n            // the gesture immediately.\n            if (!_this.state._active) {\n                if (_this.state._delayedEvent) {\n                    _this.clearTimeout();\n                    _this.startDrag(event);\n                }\n                return;\n            }\n            var genericEventData = getGenericEventData(event); // If the event doesn't have any button / touches left we should cancel\n            // the gesture. This may happen if the drag release happens outside the browser\n            // window.\n            if (!genericEventData.down) {\n                _this.onDragEnd(event);\n                return;\n            }\n            _this.updateSharedState(genericEventData);\n            var values = getPointerEventValues(event);\n            var kinematics = _this.getKinematics(values, event);\n            var genericPayload = getGenericPayload(_assertThisInitialized(_this), event); // This verifies if the drag can be assimilated to a tap by checking\n            // if the real distance of the drag (ie not accounting for the threshold) is\n            // greater than the TAP_DISTANCE_THRESHOLD.\n            var _isTap = _this.state._isTap;\n            var realDistance = calculateDistance(kinematics._movement);\n            if (_isTap && realDistance >= TAP_DISTANCE_THRESHOLD) _isTap = false;\n            _this.updateGestureState(_extends({}, genericPayload, kinematics, {\n                _isTap: _isTap\n            }));\n            _this.fireGestureHandler();\n        };\n        _this.onDragEnd = function(event) {\n            // If the event pointerId doesn't match the initiating pointerId\n            // don't respond to the event.\n            if (event.pointerId !== _this.state._pointerId) return;\n            _this.state._active = false;\n            _this.updateSharedState({\n                down: false,\n                buttons: 0,\n                touches: 0\n            });\n            var tap = _this.state._isTap;\n            var _this$state$velocitie = _this.state.velocities, vx = _this$state$velocitie[0], vy = _this$state$velocitie[1];\n            var _this$state$movement = _this.state.movement, mx = _this$state$movement[0], my = _this$state$movement[1];\n            var _this$state$_intentio = _this.state._intentional, ix = _this$state$_intentio[0], iy = _this$state$_intentio[1];\n            var _this$config$swipeVel = _this.config.swipeVelocity, svx = _this$config$swipeVel[0], svy = _this$config$swipeVel[1];\n            var _this$config$swipeDis = _this.config.swipeDistance, sx = _this$config$swipeDis[0], sy = _this$config$swipeDis[1];\n            var endState = _extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getMovement(_this.state.values));\n            var swipe = [\n                0,\n                0\n            ];\n            if (endState.elapsedTime < SWIPE_MAX_ELAPSED_TIME) {\n                if (ix !== false && Math.abs(vx) > svx && Math.abs(mx) > sx) swipe[0] = sign(vx);\n                if (iy !== false && Math.abs(vy) > svy && Math.abs(my) > sy) swipe[1] = sign(vy);\n            }\n            _this.updateGestureState(_extends({}, endState, {\n                tap: tap,\n                swipe: swipe\n            }));\n            _this.fireGestureHandler(tap === true);\n        };\n        _this.clean = function() {\n            _CoordinatesRecognize.prototype.clean.call(_assertThisInitialized(_this));\n            _this.state._delayedEvent = false; // can't remember if this is useful?\n            clearWindowListeners(_this.controller, _this.stateKey); // TODO add back when setPointerCapture is widely wupported\n        // this.removePointers()\n        };\n        _this.onCancel = function() {\n            if (_this.state.canceled) return;\n            _this.updateGestureState({\n                canceled: true\n            });\n            _this.state._active = false;\n            _this.updateSharedState({\n                down: false,\n                buttons: 0,\n                touches: 0\n            });\n            requestAnimationFrame(function() {\n                return _this.fireGestureHandler();\n            });\n        };\n        _this.onClick = function(event) {\n            if (!_this.state._isTap) event.stopPropagation();\n        };\n        return _this;\n    }\n    var _proto = DragRecognizer.prototype;\n    _proto.startDrag = function startDrag(event) {\n        var values = getPointerEventValues(event);\n        this.updateSharedState(getGenericEventData(event));\n        this.updateGestureState(_extends({}, getStartGestureState(this, values, event), getGenericPayload(this, event, true), {\n            _pointerId: event.pointerId,\n            cancel: this.onCancel\n        }));\n        this.updateGestureState(this.getMovement(values));\n        this.fireGestureHandler();\n    };\n    _proto.addBindings = function addBindings$1(bindings) {\n        addBindings(bindings, \"onPointerDown\", this.onDragStart);\n        if (this.config.filterTaps) {\n            var handler = this.controller.config.eventOptions.capture ? \"onClick\" : \"onClickCapture\";\n            addBindings(bindings, handler, this.onClick);\n        } // TODO add back when setPointerCapture is widely wupported\n    // addBindings(bindings, 'onPointerMove', this.onDragChange)\n    // addBindings(bindings, 'onPointerUp', this.onDragEnd)\n    // addBindings(bindings, 'onPointerCancel', this.onDragEnd)\n    };\n    return DragRecognizer;\n}(CoordinatesRecognizer);\n/**\r\n * Inlined from https://github.com/alexreardon/memoize-one\r\n */ function memoizeOne(resultFn, isEqual) {\n    var lastThis;\n    var lastArgs = [];\n    var lastResult;\n    var calledOnce = false;\n    function memoized() {\n        for(var _len = arguments.length, newArgs = new Array(_len), _key = 0; _key < _len; _key++){\n            newArgs[_key] = arguments[_key];\n        }\n        if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {\n            return lastResult;\n        }\n        lastResult = resultFn.apply(this, newArgs);\n        calledOnce = true;\n        lastThis = this;\n        lastArgs = newArgs;\n        return lastResult;\n    }\n    return memoized;\n}\n/**\r\n * Taken from https://github.com/FormidableLabs/react-fast-compare\r\n *\r\n * Dropped comments and ArrayBuffer handling\r\n */ function equal(a, b) {\n    if (a === b) return true;\n    if (a && b && typeof a == \"object\" && typeof b == \"object\") {\n        if (a.constructor !== b.constructor) return false;\n        var length, i, keys;\n        if (Array.isArray(a)) {\n            length = a.length;\n            if (length !== b.length) return false;\n            for(i = length; i-- !== 0;){\n                if (!equal(a[i], b[i])) return false;\n            }\n            return true;\n        }\n        var it;\n        if (typeof Map === \"function\" && a instanceof Map && b instanceof Map) {\n            if (a.size !== b.size) return false;\n            it = a.entries();\n            while(!(i = it.next()).done){\n                if (!b.has(i.value[0])) return false;\n            }\n            it = a.entries();\n            while(!(i = it.next()).done){\n                if (!equal(i.value[1], b.get(i.value[0]))) return false;\n            }\n            return true;\n        }\n        if (typeof Set === \"function\" && a instanceof Set && b instanceof Set) {\n            if (a.size !== b.size) return false;\n            it = a.entries();\n            while(!(i = it.next()).done){\n                if (!b.has(i.value[0])) return false;\n            }\n            return true;\n        }\n        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n        keys = Object.keys(a);\n        length = keys.length;\n        if (length !== Object.keys(b).length) return false;\n        for(i = length; i-- !== 0;){\n            if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n        }\n        if (typeof Element !== \"undefined\" && a instanceof Element) return false;\n        for(i = length; i-- !== 0;){\n            if (keys[i] === \"_owner\" && a.$$typeof) continue;\n            if (!equal(a[keys[i]], b[keys[i]])) return false;\n        }\n        return true;\n    } // true if both NaN, false otherwise  NaN !== NaN  true\n    // eslint-disable-next-line no-self-compare\n    return a !== a && b !== b;\n}\nfunction isEqual(a, b) {\n    try {\n        return equal(a, b);\n    } catch (error) {\n        if ((error.message || \"\").match(/stack|recursion/i)) {\n            console.warn(\"react-fast-compare cannot handle circular refs\");\n            return false;\n        }\n        throw error;\n    }\n}\n/**\r\n * Drag hook.\r\n *\r\n * @param handler - the function fired every time the drag gesture updates\r\n * @param [config={}] - the config object including generic options and drag options\r\n */ function useDrag(handler, config) {\n    if (config === void 0) {\n        config = {};\n    }\n    RecognizersMap.set(\"drag\", DragRecognizer);\n    var buildDragConfig = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    if (!buildDragConfig.current) {\n        buildDragConfig.current = memoizeOne(_buildDragConfig, isEqual);\n    }\n    return useRecognizers({\n        drag: handler\n    }, buildDragConfig.current(config));\n}\n/**\r\n * @private\r\n * Abstract class for distance/angle-based gesture recongizers\r\n */ var DistanceAngleRecognizer = /*#__PURE__*/ function(_Recognizer) {\n    _inheritsLoose(DistanceAngleRecognizer, _Recognizer);\n    function DistanceAngleRecognizer() {\n        return _Recognizer.apply(this, arguments) || this;\n    }\n    var _proto = DistanceAngleRecognizer.prototype;\n    _proto.getInternalMovement = function getInternalMovement(values, state) {\n        var prev_a = state.values[1]; // not be defined if ctrl+wheel is used for zoom only\n        var d = values[0], _values$ = values[1], a = _values$ === void 0 ? prev_a : _values$;\n        var delta_a = a - prev_a;\n        var next_turns = state.turns;\n        if (Math.abs(delta_a) > 270) next_turns += sign(delta_a);\n        return subV([\n            d,\n            a - 360 * next_turns\n        ], state.initial);\n    };\n    _proto.getKinematics = function getKinematics(values, event) {\n        var state = this.getMovement(values);\n        var turns = (values[1] - state.movement[1] - this.state.initial[1]) / 360;\n        var dt = event.timeStamp - this.state.timeStamp;\n        var kinematics = calculateAllKinematics(state.movement, state.delta, dt);\n        return _extends({\n            turns: turns\n        }, state, kinematics);\n    };\n    _proto.mapStateValues = function mapStateValues(state) {\n        return {\n            da: state.values,\n            vdva: state.velocities\n        };\n    };\n    return DistanceAngleRecognizer;\n}(Recognizer);\nvar PinchRecognizer = /*#__PURE__*/ function(_DistanceAngleRecogni) {\n    _inheritsLoose(PinchRecognizer, _DistanceAngleRecogni);\n    function PinchRecognizer() {\n        var _this;\n        _this = _DistanceAngleRecogni.apply(this, arguments) || this;\n        _this.ingKey = \"pinching\";\n        _this.stateKey = \"pinch\";\n        _this.pinchShouldStart = function(event) {\n            var _getGenericEventData = getGenericEventData(event), touches = _getGenericEventData.touches;\n            return _this.enabled && touches === 2;\n        };\n        _this.onPinchStart = function(event) {\n            if (!_this.pinchShouldStart(event)) return;\n            var _getTwoTouchesEventDa = getTwoTouchesEventData(event), values = _getTwoTouchesEventDa.values, origin = _getTwoTouchesEventDa.origin;\n            _this.updateSharedState(getGenericEventData(event));\n            _this.updateGestureState(_extends({}, getStartGestureState(_assertThisInitialized(_this), values, event), getGenericPayload(_assertThisInitialized(_this), event, true), {\n                cancel: _this.onCancel,\n                origin: origin\n            }));\n            _this.updateGestureState(_this.getMovement(values));\n            _this.fireGestureHandler();\n        };\n        _this.onPinchChange = function(event) {\n            var _this$state = _this.state, canceled = _this$state.canceled, _active = _this$state._active;\n            if (canceled || !_active) return;\n            var genericEventData = getGenericEventData(event);\n            _this.updateSharedState(genericEventData);\n            var _getTwoTouchesEventDa2 = getTwoTouchesEventData(event), values = _getTwoTouchesEventDa2.values, origin = _getTwoTouchesEventDa2.origin; // @ts-ignore\n            var kinematics = _this.getKinematics(values, event);\n            _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), kinematics, {\n                origin: origin\n            }));\n            _this.fireGestureHandler();\n        };\n        _this.onPinchEnd = function(event) {\n            if (!_this.state.active) return;\n            _this.state._active = false;\n            _this.updateSharedState({\n                down: false,\n                touches: 0\n            });\n            _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getMovement(_this.state.values)));\n            _this.fireGestureHandler();\n        };\n        _this.onCancel = function() {\n            if (_this.state.canceled) return;\n            _this.state._active = false;\n            _this.updateGestureState({\n                canceled: true\n            });\n            _this.updateSharedState({\n                down: false,\n                touches: 0\n            });\n            requestAnimationFrame(function() {\n                return _this.fireGestureHandler();\n            });\n        };\n        /**\r\n     * PINCH WITH WEBKIT GESTURES\r\n     */ _this.onGestureStart = function(event) {\n            if (!_this.enabled) return;\n            event.preventDefault(); // useless\n            var values = getWebkitGestureEventValues(event);\n            _this.updateSharedState(getGenericEventData(event));\n            _this.updateGestureState(_extends({}, getStartGestureState(_assertThisInitialized(_this), values, event), getGenericPayload(_assertThisInitialized(_this), event, true), {\n                origin: [\n                    event.clientX,\n                    event.clientY\n                ],\n                cancel: _this.onCancel\n            }));\n            _this.updateGestureState(_this.getMovement(values));\n            _this.fireGestureHandler();\n        };\n        _this.onGestureChange = function(event) {\n            var _this$state2 = _this.state, canceled = _this$state2.canceled, _active = _this$state2._active;\n            if (canceled || !_active) return;\n            event.preventDefault();\n            var genericEventData = getGenericEventData(event);\n            _this.updateSharedState(genericEventData);\n            var values = getWebkitGestureEventValues(event);\n            var kinematics = _this.getKinematics(values, event);\n            _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), kinematics, {\n                origin: [\n                    event.clientX,\n                    event.clientY\n                ]\n            }));\n            _this.fireGestureHandler();\n        };\n        _this.onGestureEnd = function(event) {\n            event.preventDefault();\n            if (!_this.state.active) return;\n            _this.state._active = false;\n            _this.updateSharedState({\n                down: false,\n                touches: 0\n            });\n            _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getMovement(_this.state.values), {\n                origin: [\n                    event.clientX,\n                    event.clientY\n                ]\n            }));\n            _this.fireGestureHandler();\n        };\n        /**\r\n     * PINCH WITH WHEEL\r\n     */ _this.wheelShouldRun = function(event) {\n            return _this.enabled && event.ctrlKey;\n        };\n        _this.getWheelValuesFromEvent = function(event) {\n            var _getWheelEventValues = getWheelEventValues(event), delta_d = _getWheelEventValues[1];\n            var _this$state$values = _this.state.values, prev_d = _this$state$values[0], prev_a = _this$state$values[1];\n            var d = prev_d - delta_d;\n            var a = prev_a !== void 0 ? prev_a : 0;\n            return {\n                values: [\n                    d,\n                    a\n                ],\n                origin: [\n                    event.clientX,\n                    event.clientY\n                ],\n                delta: [\n                    0,\n                    delta_d\n                ]\n            };\n        };\n        _this.onWheel = function(event) {\n            if (!_this.wheelShouldRun(event)) return;\n            _this.setTimeout(_this.onWheelEnd);\n            if (!_this.state._active) _this.onWheelStart(event);\n            else _this.onWheelChange(event);\n        };\n        _this.onWheelStart = function(event) {\n            var _this$getWheelValuesF = _this.getWheelValuesFromEvent(event), values = _this$getWheelValuesF.values, delta = _this$getWheelValuesF.delta, origin = _this$getWheelValuesF.origin;\n            if (event.cancelable) event.preventDefault();\n            else if (true) {\n                console.warn(\"To properly support zoom on trackpads, try using the `domTarget` option and `config.eventOptions.passive` set to `false`. This message will only appear in development mode.\");\n            }\n            _this.updateSharedState(getGenericEventData(event));\n            _this.updateGestureState(_extends({}, getStartGestureState(_assertThisInitialized(_this), values, event), getGenericPayload(_assertThisInitialized(_this), event, true), {\n                initial: _this.state.values,\n                offset: values,\n                delta: delta,\n                origin: origin\n            }));\n            _this.updateGestureState(_this.getMovement(values));\n            _this.fireGestureHandler();\n        };\n        _this.onWheelChange = function(event) {\n            _this.updateSharedState(getGenericEventData(event));\n            var _this$getWheelValuesF2 = _this.getWheelValuesFromEvent(event), values = _this$getWheelValuesF2.values, origin = _this$getWheelValuesF2.origin, delta = _this$getWheelValuesF2.delta;\n            _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getKinematics(values, event), {\n                origin: origin,\n                delta: delta\n            }));\n            _this.fireGestureHandler();\n        };\n        _this.onWheelEnd = function() {\n            _this.state._active = false;\n            _this.updateGestureState(_this.getMovement(_this.state.values));\n            _this.fireGestureHandler();\n        };\n        return _this;\n    }\n    var _proto = PinchRecognizer.prototype;\n    _proto.addBindings = function addBindings$1(bindings) {\n        // Only try to use gesture events when they are supported and domTarget is set\n        // as React doesn't support gesture handlers.\n        if (this.controller.config.domTarget && !supportsTouchEvents() && supportsGestureEvents()) {\n            addBindings(bindings, \"onGestureStart\", this.onGestureStart);\n            addBindings(bindings, \"onGestureChange\", this.onGestureChange);\n            addBindings(bindings, \"onGestureEnd\", this.onGestureEnd);\n        } else {\n            addBindings(bindings, \"onTouchStart\", this.onPinchStart);\n            addBindings(bindings, \"onTouchMove\", this.onPinchChange);\n            addBindings(bindings, \"onTouchEnd\", this.onPinchEnd);\n            addBindings(bindings, \"onTouchCancel\", this.onPinchEnd);\n            addBindings(bindings, \"onWheel\", this.onWheel);\n        }\n    };\n    return PinchRecognizer;\n}(DistanceAngleRecognizer);\n/**\r\n * Pinch hook.\r\n *\r\n * @param handler - the function fired every time the pinch gesture updates\r\n * @param [config={}] - the config object including generic options and pinch options\r\n */ function usePinch(handler, config) {\n    if (config === void 0) {\n        config = {};\n    }\n    RecognizersMap.set(\"pinch\", PinchRecognizer);\n    var buildPinchConfig = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    if (!buildPinchConfig.current) {\n        buildPinchConfig.current = memoizeOne(_buildPinchConfig, isEqual);\n    }\n    return useRecognizers({\n        pinch: handler\n    }, buildPinchConfig.current(config));\n}\nvar WheelRecognizer = /*#__PURE__*/ function(_CoordinatesRecognize) {\n    _inheritsLoose(WheelRecognizer, _CoordinatesRecognize);\n    function WheelRecognizer() {\n        var _this;\n        _this = _CoordinatesRecognize.apply(this, arguments) || this;\n        _this.ingKey = \"wheeling\";\n        _this.stateKey = \"wheel\";\n        _this.debounced = true;\n        _this.handleEvent = function(event) {\n            if (event.ctrlKey && \"pinch\" in _this.controller.handlers) return;\n            if (!_this.enabled) return;\n            _this.setTimeout(_this.onEnd);\n            _this.updateSharedState(getGenericEventData(event));\n            var values = addV(getWheelEventValues(event), _this.state.values);\n            if (!_this.state._active) {\n                _this.updateGestureState(_extends({}, getStartGestureState(_assertThisInitialized(_this), values, event), getGenericPayload(_assertThisInitialized(_this), event, true), {\n                    initial: _this.state.values\n                }));\n                var movement = _this.getMovement(values);\n                var geometry = calculateAllGeometry(movement.delta);\n                _this.updateGestureState(movement);\n                _this.updateGestureState(geometry);\n            } else {\n                _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getKinematics(values, event)));\n            }\n            _this.fireGestureHandler();\n        };\n        _this.onEnd = function() {\n            var movement = _this.getMovement(_this.state.values);\n            _this.updateGestureState(movement);\n            _this.updateGestureState({\n                _active: false,\n                velocities: [\n                    0,\n                    0\n                ],\n                velocity: 0\n            });\n            _this.fireGestureHandler();\n        };\n        return _this;\n    }\n    var _proto = WheelRecognizer.prototype;\n    _proto.addBindings = function addBindings$1(bindings) {\n        addBindings(bindings, \"onWheel\", this.handleEvent);\n    };\n    return WheelRecognizer;\n}(CoordinatesRecognizer);\n/**\r\n * Wheel hook.\r\n *\r\n * @param handler - the function fired every time the wheel gesture updates\r\n * @param the config object including generic options and wheel options\r\n */ function useWheel(handler, config) {\n    if (config === void 0) {\n        config = {};\n    }\n    RecognizersMap.set(\"wheel\", WheelRecognizer);\n    var buildWheelConfig = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    if (!buildWheelConfig.current) {\n        buildWheelConfig.current = memoizeOne(_buildWheelConfig, isEqual);\n    }\n    return useRecognizers({\n        wheel: handler\n    }, buildWheelConfig.current(config));\n}\nvar MoveRecognizer = /*#__PURE__*/ function(_CoordinatesRecognize) {\n    _inheritsLoose(MoveRecognizer, _CoordinatesRecognize);\n    function MoveRecognizer() {\n        var _this;\n        _this = _CoordinatesRecognize.apply(this, arguments) || this;\n        _this.ingKey = \"moving\";\n        _this.stateKey = \"move\";\n        _this.debounced = true;\n        _this.onMove = function(event) {\n            if (!_this.enabled) return;\n            _this.setTimeout(_this.onMoveEnd);\n            if (!_this.state._active) _this.onMoveStart(event);\n            else _this.onMoveChange(event);\n        };\n        _this.onMoveStart = function(event) {\n            _this.updateSharedState(getGenericEventData(event));\n            var values = getPointerEventValues(event);\n            _this.updateGestureState(_extends({}, getStartGestureState(_assertThisInitialized(_this), values, event), getGenericPayload(_assertThisInitialized(_this), event, true)));\n            _this.updateGestureState(_this.getMovement(values));\n            _this.fireGestureHandler();\n        };\n        _this.onMoveChange = function(event) {\n            _this.updateSharedState(getGenericEventData(event));\n            var values = getPointerEventValues(event);\n            _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getKinematics(values, event)));\n            _this.fireGestureHandler();\n        };\n        _this.onMoveEnd = function() {\n            var values = _this.state.values;\n            _this.updateGestureState(_this.getMovement(values));\n            _this.updateGestureState({\n                velocities: [\n                    0,\n                    0\n                ],\n                velocity: 0,\n                _active: false\n            });\n            _this.fireGestureHandler();\n        };\n        _this.onPointerEnter = function(event) {\n            _this.controller.state.shared.hovering = true;\n            if (!_this.controller.config.enabled) return;\n            if (_this.controller.config.hover.enabled) {\n                var values = getPointerEventValues(event);\n                var state = _extends({}, _this.controller.state.shared, _this.state, getGenericPayload(_assertThisInitialized(_this), event, true), {\n                    values: values,\n                    active: true,\n                    hovering: true\n                });\n                _this.controller.handlers.hover(_extends({}, state, _this.mapStateValues(state)));\n            }\n            if (\"move\" in _this.controller.handlers) _this.onMoveStart(event);\n        };\n        _this.onPointerLeave = function(event) {\n            _this.controller.state.shared.hovering = false;\n            if (\"move\" in _this.controller.handlers) _this.onMoveEnd();\n            if (!_this.controller.config.hover.enabled) return;\n            var values = getPointerEventValues(event);\n            var state = _extends({}, _this.controller.state.shared, _this.state, getGenericPayload(_assertThisInitialized(_this), event), {\n                values: values,\n                active: false\n            });\n            _this.controller.handlers.hover(_extends({}, state, _this.mapStateValues(state)));\n        };\n        return _this;\n    }\n    var _proto = MoveRecognizer.prototype;\n    _proto.addBindings = function addBindings$1(bindings) {\n        if (\"move\" in this.controller.handlers) {\n            addBindings(bindings, \"onPointerMove\", this.onMove);\n        }\n        if (\"hover\" in this.controller.handlers) {\n            addBindings(bindings, \"onPointerEnter\", this.onPointerEnter);\n            addBindings(bindings, \"onPointerLeave\", this.onPointerLeave);\n        }\n    };\n    return MoveRecognizer;\n}(CoordinatesRecognizer);\n/**\r\n * Move hook.\r\n *\r\n * @param handler - the function fired every time the move gesture updates\r\n * @param [config={}] - the config object including generic options and move options\r\n */ function useMove(handler, config) {\n    if (config === void 0) {\n        config = {};\n    }\n    RecognizersMap.set(\"move\", MoveRecognizer);\n    var buildMoveConfig = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    if (!buildMoveConfig.current) {\n        buildMoveConfig.current = memoizeOne(_buildMoveConfig, isEqual);\n    }\n    return useRecognizers({\n        move: handler\n    }, buildMoveConfig.current(config));\n}\n/**\r\n * Hover hook.\r\n *\r\n * @param handler - the function fired every time the hover gesture updates\r\n * @param [config={}] - the config object including generic options and hover options\r\n */ function useHover(handler, config) {\n    if (config === void 0) {\n        config = {};\n    }\n    RecognizersMap.set(\"hover\", MoveRecognizer);\n    var buildHoverConfig = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    if (!buildHoverConfig.current) {\n        buildHoverConfig.current = memoizeOne(_buildHoverConfig, isEqual);\n    }\n    return useRecognizers({\n        hover: handler\n    }, buildHoverConfig.current(config));\n}\nvar ScrollRecognizer = /*#__PURE__*/ function(_CoordinatesRecognize) {\n    _inheritsLoose(ScrollRecognizer, _CoordinatesRecognize);\n    function ScrollRecognizer() {\n        var _this;\n        _this = _CoordinatesRecognize.apply(this, arguments) || this;\n        _this.ingKey = \"scrolling\";\n        _this.stateKey = \"scroll\";\n        _this.debounced = true;\n        _this.handleEvent = function(event) {\n            if (!_this.enabled) return;\n            _this.clearTimeout();\n            _this.setTimeout(_this.onEnd);\n            var values = getScrollEventValues(event);\n            _this.updateSharedState(getGenericEventData(event));\n            if (!_this.state._active) {\n                _this.updateGestureState(_extends({}, getStartGestureState(_assertThisInitialized(_this), values, event), getGenericPayload(_assertThisInitialized(_this), event, true), {\n                    initial: _this.state.values\n                }));\n                var movementDetection = _this.getMovement(values);\n                var geometry = calculateAllGeometry(movementDetection.delta);\n                _this.updateGestureState(movementDetection);\n                _this.updateGestureState(geometry);\n            } else {\n                _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getKinematics(values, event)));\n            }\n            _this.fireGestureHandler();\n        };\n        _this.onEnd = function() {\n            _this.state._active = false;\n            _this.updateGestureState(_extends({}, _this.getMovement(_this.state.values), {\n                velocities: [\n                    0,\n                    0\n                ],\n                velocity: 0\n            }));\n            _this.fireGestureHandler();\n        };\n        return _this;\n    }\n    var _proto = ScrollRecognizer.prototype;\n    _proto.addBindings = function addBindings$1(bindings) {\n        addBindings(bindings, \"onScroll\", this.handleEvent);\n    };\n    return ScrollRecognizer;\n}(CoordinatesRecognizer);\n/**\r\n * Scroll hook.\r\n *\r\n * @param handler - the function fired every time the scroll gesture updates\r\n * @param [config={}] - the config object including generic options and scroll options\r\n */ function useScroll(handler, config) {\n    if (config === void 0) {\n        config = {};\n    }\n    RecognizersMap.set(\"scroll\", ScrollRecognizer);\n    var buildScrollConfig = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    if (!buildScrollConfig.current) {\n        buildScrollConfig.current = memoizeOne(_buildScrollConfig, isEqual);\n    }\n    return useRecognizers({\n        scroll: handler\n    }, buildScrollConfig.current(config));\n}\nvar RE_NOT_NATIVE = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;\nfunction sortHandlers(handlers) {\n    var _native = {};\n    var handle = {};\n    var actions = new Set();\n    for(var key in handlers){\n        if (RE_NOT_NATIVE.test(key)) {\n            actions.add(RegExp.lastMatch);\n            handle[key] = handlers[key];\n        } else {\n            _native[key] = handlers[key];\n        }\n    }\n    return [\n        handle,\n        _native,\n        actions\n    ];\n}\n/**\r\n * @public\r\n *\r\n * The most complete gesture hook, allowing support for multiple gestures.\r\n *\r\n * @param {Handlers} handlers - an object with on[Gesture] keys containg gesture handlers\r\n * @param {UseGestureConfig} [config={}] - the full config object\r\n * @returns {(...args: any[]) => HookReturnType<Config>}\r\n */ function useGesture(_handlers, config) {\n    if (config === void 0) {\n        config = {};\n    }\n    var _sortHandlers = sortHandlers(_handlers), handlers = _sortHandlers[0], nativeHandlers = _sortHandlers[1], actions = _sortHandlers[2];\n    RecognizersMap.set(\"drag\", DragRecognizer);\n    RecognizersMap.set(\"hover\", MoveRecognizer);\n    RecognizersMap.set(\"move\", MoveRecognizer);\n    RecognizersMap.set(\"pinch\", PinchRecognizer);\n    RecognizersMap.set(\"scroll\", ScrollRecognizer);\n    RecognizersMap.set(\"wheel\", WheelRecognizer);\n    var mergedConfig = buildComplexConfig(config, actions);\n    var internalHandlers = {};\n    if (actions.has(\"onDrag\")) internalHandlers.drag = includeStartEndHandlers(handlers, \"onDrag\");\n    if (actions.has(\"onWheel\")) internalHandlers.wheel = includeStartEndHandlers(handlers, \"onWheel\");\n    if (actions.has(\"onScroll\")) internalHandlers.scroll = includeStartEndHandlers(handlers, \"onScroll\");\n    if (actions.has(\"onMove\")) internalHandlers.move = includeStartEndHandlers(handlers, \"onMove\");\n    if (actions.has(\"onPinch\")) internalHandlers.pinch = includeStartEndHandlers(handlers, \"onPinch\");\n    if (actions.has(\"onHover\")) internalHandlers.hover = handlers.onHover;\n    return useRecognizers(internalHandlers, mergedConfig, nativeHandlers);\n}\nfunction includeStartEndHandlers(handlers, handlerKey) {\n    var startKey = handlerKey + \"Start\";\n    var endKey = handlerKey + \"End\";\n    var fn = function fn(state) {\n        var memo = undefined;\n        if (state.first && startKey in handlers) handlers[startKey](state);\n        if (handlerKey in handlers) memo = handlers[handlerKey](state);\n        if (state.last && endKey in handlers) handlers[endKey](state);\n        return memo;\n    };\n    return fn;\n}\n //# sourceMappingURL=react-use-gesture.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtdXNlLWdlc3R1cmUvZGlzdC9yZWFjdC11c2UtZ2VzdHVyZS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQXNDO0FBRXRDLGFBQWE7QUFDYixTQUFTRSxLQUFLQyxFQUFFLEVBQUVDLEVBQUU7SUFDbEIsT0FBT0QsR0FBR0UsR0FBRyxDQUFDLFNBQVVDLENBQUMsRUFBRUMsQ0FBQztRQUMxQixPQUFPRCxJQUFJRixFQUFFLENBQUNHLEVBQUU7SUFDbEI7QUFDRixFQUFFLG1CQUFtQjtBQUVyQixTQUFTQyxLQUFLTCxFQUFFLEVBQUVDLEVBQUU7SUFDbEIsT0FBT0QsR0FBR0UsR0FBRyxDQUFDLFNBQVVDLENBQUMsRUFBRUMsQ0FBQztRQUMxQixPQUFPRCxJQUFJRixFQUFFLENBQUNHLEVBQUU7SUFDbEI7QUFDRjtBQUNBOzs7O0NBSUMsR0FFRCxTQUFTRSxrQkFBa0JDLFFBQVE7SUFDakMsT0FBT0MsS0FBS0MsS0FBSyxDQUFDQyxLQUFLLENBQUNGLE1BQU1EO0FBQ2hDO0FBQ0EsU0FBU0kscUJBQXFCSixRQUFRLEVBQUVLLEtBQUs7SUFDM0MsSUFBSUEsVUFBVSxLQUFLLEdBQUc7UUFDcEJBLFFBQVFMO0lBQ1Y7SUFFQSxJQUFJTSxLQUFLUCxrQkFBa0JNO0lBQzNCLElBQUlFLFFBQVFELE9BQU8sSUFBSSxJQUFJLElBQUlBO0lBQy9CLElBQUlFLFlBQVlILE1BQU1WLEdBQUcsQ0FBQyxTQUFVQyxDQUFDO1FBQ25DLE9BQU9XLFFBQVFYO0lBQ2pCO0lBQ0EsSUFBSWEsV0FBV1Ysa0JBQWtCQztJQUNqQyxPQUFPO1FBQ0xTLFVBQVVBO1FBQ1ZELFdBQVdBO0lBQ2I7QUFDRjtBQUNBOzs7Ozs7O0NBT0MsR0FFRCxTQUFTRSx1QkFBdUJWLFFBQVEsRUFBRUssS0FBSyxFQUFFTSxFQUFFO0lBQ2pELElBQUlMLEtBQUtQLGtCQUFrQk07SUFDM0IsSUFBSUUsUUFBUUQsT0FBTyxJQUFJLElBQUksSUFB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aUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMtY3JlZGl0LWNhcmQtYXBwLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXVzZS1nZXN0dXJlL2Rpc3QvcmVhY3QtdXNlLWdlc3R1cmUuZXNtLmpzP2QxZGQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcblxuLy8gdmVjdG9yIGFkZFxuZnVuY3Rpb24gYWRkVih2MSwgdjIpIHtcbiAgcmV0dXJuIHYxLm1hcChmdW5jdGlvbiAodiwgaSkge1xuICAgIHJldHVybiB2ICsgdjJbaV07XG4gIH0pO1xufSAvLyB2ZWN0b3Igc3Vic3RyYWN0XG5cbmZ1bmN0aW9uIHN1YlYodjEsIHYyKSB7XG4gIHJldHVybiB2MS5tYXAoZnVuY3Rpb24gKHYsIGkpIHtcbiAgICByZXR1cm4gdiAtIHYyW2ldO1xuICB9KTtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIGRpc3RhbmNlXHJcbiAqIEBwYXJhbSBtb3ZlbWVudCB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIGN1cnJlbnQgYW5kIGluaXRpYWwgdmVjdG9yc1xyXG4gKiBAcmV0dXJucyBkaXN0YW5jZVxyXG4gKi9cblxuZnVuY3Rpb24gY2FsY3VsYXRlRGlzdGFuY2UobW92ZW1lbnQpIHtcbiAgcmV0dXJuIE1hdGguaHlwb3QuYXBwbHkoTWF0aCwgbW92ZW1lbnQpO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlQWxsR2VvbWV0cnkobW92ZW1lbnQsIGRlbHRhKSB7XG4gIGlmIChkZWx0YSA9PT0gdm9pZCAwKSB7XG4gICAgZGVsdGEgPSBtb3ZlbWVudDtcbiAgfVxuXG4gIHZhciBkbCA9IGNhbGN1bGF0ZURpc3RhbmNlKGRlbHRhKTtcbiAgdmFyIGFscGhhID0gZGwgPT09IDAgPyAwIDogMSAvIGRsO1xuICB2YXIgZGlyZWN0aW9uID0gZGVsdGEubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIGFscGhhICogdjtcbiAgfSk7XG4gIHZhciBkaXN0YW5jZSA9IGNhbGN1bGF0ZURpc3RhbmNlKG1vdmVtZW50KTtcbiAgcmV0dXJuIHtcbiAgICBkaXN0YW5jZTogZGlzdGFuY2UsXG4gICAgZGlyZWN0aW9uOiBkaXJlY3Rpb25cbiAgfTtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIGFsbCBraW5lbWF0aWNzXHJcbiAqIEB0ZW1wbGF0ZSBUIHRoZSBleHBlY3RlZCB2ZWN0b3IgdHlwZVxyXG4gKiBAcGFyYW0gbW92ZW1lbnQgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBjdXJyZW50IGFuZCBpbml0aWFsIHZlY3RvcnNcclxuICogQHBhcmFtIGRlbHRhIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gY3VycmVudCBhbmQgcHJldmlvdXMgdmVjdG9yc1xyXG4gKiBAcGFyYW0gZGVsdGFfdCB0aGUgdGltZSBkaWZmZXJlbmNlIGJldHdlZW4gY3VycmVudCBhbmQgcHJldmlvdXMgdGltZXN0YW1wc1xyXG4gKiBAcmV0dXJucyBhbGwga2luZW1hdGljc1xyXG4gKi9cblxuZnVuY3Rpb24gY2FsY3VsYXRlQWxsS2luZW1hdGljcyhtb3ZlbWVudCwgZGVsdGEsIGR0KSB7XG4gIHZhciBkbCA9IGNhbGN1bGF0ZURpc3RhbmNlKGRlbHRhKTtcbiAgdmFyIGFscGhhID0gZGwgPT09IDAgPyAwIDogMSAvIGRsO1xuICB2YXIgYmV0YSA9IGR0ID09PSAwID8gMCA6IDEgLyBkdDtcbiAgdmFyIHZlbG9jaXR5ID0gYmV0YSAqIGRsO1xuICB2YXIgdmVsb2NpdGllcyA9IGRlbHRhLm1hcChmdW5jdGlvbiAodikge1xuICAgIHJldHVybiBiZXRhICogdjtcbiAgfSk7XG4gIHZhciBkaXJlY3Rpb24gPSBkZWx0YS5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gYWxwaGEgKiB2O1xuICB9KTtcbiAgdmFyIGRpc3RhbmNlID0gY2FsY3VsYXRlRGlzdGFuY2UobW92ZW1lbnQpO1xuICByZXR1cm4ge1xuICAgIHZlbG9jaXRpZXM6IHZlbG9jaXRpZXMsXG4gICAgdmVsb2NpdHk6IHZlbG9jaXR5LFxuICAgIGRpc3RhbmNlOiBkaXN0YW5jZSxcbiAgICBkaXJlY3Rpb246IGRpcmVjdGlvblxuICB9O1xufVxuLyoqXHJcbiAqIEJlY2F1c2UgSUUgZG9lc24ndCBzdXBwb3J0IGBNYXRoLnNpZ25gIGZ1bmN0aW9uLCBzbyB3ZSB1c2UgdGhlIHBvbHlmaWxsIHZlcnNpb24gb2YgdGhlIGZ1bmN0aW9uLlxyXG4gKiBUaGlzIHBvbHlmaWxsIGZ1bmN0aW9uIGlzIHN1Z2dlc3RlZCBieSBNb3ppbGxhOlxyXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL3NpZ24jUG9seWZpbGxcclxuICogQHBhcmFtIHggdGFyZ2V0IG51bWJlclxyXG4gKi9cblxuZnVuY3Rpb24gc2lnbih4KSB7XG4gIGlmIChNYXRoLnNpZ24pIHJldHVybiBNYXRoLnNpZ24oeCk7XG4gIHJldHVybiBOdW1iZXIoeCA+IDApIC0gTnVtYmVyKHggPCAwKSB8fCAreDtcbn1cblxuZnVuY3Rpb24gbWluTWF4KHZhbHVlLCBtaW4sIG1heCkge1xuICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbih2YWx1ZSwgbWF4KSk7XG59IC8vIEJhc2VkIG9uIEBhaG9sYWNoZWsgOylcbi8vIGh0dHBzOi8vdHdpdHRlci5jb20vY2hwd24vc3RhdHVzLzI4NTU0MDE5MjA5NjQ5NzY2NFxuLy8gaU9TIGNvbnN0YW50ID0gMC41NVxuLy8gaHR0cHM6Ly9tZWRpdW0uY29tL0BuYXRoYW5naXR0ZXIvYnVpbGRpbmctZmx1aWQtaW50ZXJmYWNlcy1pb3Mtc3dpZnQtOTczMmJiOTM0YmY1XG5cblxuZnVuY3Rpb24gcnViYmVyYmFuZDIoZGlzdGFuY2UsIGNvbnN0YW50KSB7XG4gIC8vIGRlZmF1bHQgY29uc3RhbnQgZnJvbSB0aGUgYXJ0aWNsZSBpcyAwLjdcbiAgcmV0dXJuIE1hdGgucG93KGRpc3RhbmNlLCBjb25zdGFudCAqIDUpO1xufVxuXG5mdW5jdGlvbiBydWJiZXJiYW5kKGRpc3RhbmNlLCBkaW1lbnNpb24sIGNvbnN0YW50KSB7XG4gIGlmIChkaW1lbnNpb24gPT09IDAgfHwgTWF0aC5hYnMoZGltZW5zaW9uKSA9PT0gSW5maW5pdHkpIHJldHVybiBydWJiZXJiYW5kMihkaXN0YW5jZSwgY29uc3RhbnQpO1xuICByZXR1cm4gZGlzdGFuY2UgKiBkaW1lbnNpb24gKiBjb25zdGFudCAvIChkaW1lbnNpb24gKyBjb25zdGFudCAqIGRpc3RhbmNlKTtcbn1cblxuZnVuY3Rpb24gcnViYmVyYmFuZElmT3V0T2ZCb3VuZHMocG9zaXRpb24sIG1pbiwgbWF4LCBjb25zdGFudCkge1xuICBpZiAoY29uc3RhbnQgPT09IHZvaWQgMCkge1xuICAgIGNvbnN0YW50ID0gMC4xNTtcbiAgfVxuXG4gIGlmIChjb25zdGFudCA9PT0gMCkgcmV0dXJuIG1pbk1heChwb3NpdGlvbiwgbWluLCBtYXgpO1xuICBpZiAocG9zaXRpb24gPCBtaW4pIHJldHVybiAtcnViYmVyYmFuZChtaW4gLSBwb3NpdGlvbiwgbWF4IC0gbWluLCBjb25zdGFudCkgKyBtaW47XG4gIGlmIChwb3NpdGlvbiA+IG1heCkgcmV0dXJuICtydWJiZXJiYW5kKHBvc2l0aW9uIC0gbWF4LCBtYXggLSBtaW4sIGNvbnN0YW50KSArIG1heDtcbiAgcmV0dXJuIHBvc2l0aW9uO1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG5cbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gIHJldHVybiBhcnIyO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKG8sIGFsbG93QXJyYXlMaWtlKSB7XG4gIHZhciBpdDtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvW1N5bWJvbC5pdGVyYXRvcl0gPT0gbnVsbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGlmIChpdCkgbyA9IGl0O1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7XG4gICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgIHZhbHVlOiBvW2krK11cbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xuICB9XG5cbiAgaXQgPSBvW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgcmV0dXJuIGl0Lm5leHQuYmluZChpdCk7XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuLyoqXHJcbiAqIFRPRE8gQmV3YXJlIHRoYXQgb25seSBvcHRpbWl6ZWQgY2FzZXMgYXJlIGNvdmVyZWQgaW4gdGVzdHMgPSlcclxuICogVE9ETyBOZWVkIHRvIGNvdmVyIGdlbmVyYWwgY2FzZSBhcyB3ZWxsXHJcbiAqXHJcbiAqIEBwYXJhbSBmbnNcclxuICovXG5cbmZ1bmN0aW9uIGNoYWluRm5zKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgZm5zID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGZuc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGlmIChmbnMubGVuZ3RoID09PSAwKSByZXR1cm4gbm9vcDtcbiAgaWYgKGZucy5sZW5ndGggPT09IDEpIHJldHVybiBmbnNbMF07XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc3VsdDtcblxuICAgIGZvciAodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UoZm5zKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspIHtcbiAgICAgIHZhciBmbiA9IF9zdGVwLnZhbHVlO1xuICAgICAgcmVzdWx0ID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cbi8qKlxyXG4gKiBFeHBlY3RzIGEgc2ltcGxlIHZhbHVlIG9yIDJEIHZlY3RvciAoYW4gYXJyYXkgd2l0aCAyIGVsZW1lbnRzKSBhbmRcclxuICogYWx3YXlzIHJldHVybnMgMkQgdmVjdG9yLiBJZiBzaW1wbGUgdmFsdWUgaXMgcGFzc2VkLCByZXR1cm5zIGFcclxuICogdmVjdG9yIHdpdGggdGhpcyB2YWx1ZSBhcyBib3RoIGNvb3JkaW5hdGVzLlxyXG4gKlxyXG4gKiBAcGFyYW0gdmFsdWVcclxuICovXG5cbmZ1bmN0aW9uIGVuc3VyZVZlY3Rvcih2YWx1ZSwgZmFsbGJhY2spIHtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoZmFsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IGRlZmluZSBmYWxsYmFjayB2YWx1ZSBpZiB1bmRlZmluZWQgaXMgZXhwZWN0ZWQnKTtcbiAgICB9XG5cbiAgICB2YWx1ZSA9IGZhbGxiYWNrO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gIHJldHVybiBbdmFsdWUsIHZhbHVlXTtcbn1cbi8qKlxyXG4gKiBIZWxwZXIgZm9yIGRlZmluaW5nIGEgZGVmYXVsdCB2YWx1ZVxyXG4gKlxyXG4gKiBAcGFyYW0gdmFsdWVcclxuICogQHBhcmFtIGZhbGxiYWNrXHJcbiAqL1xuXG5mdW5jdGlvbiBhc3NpZ25EZWZhdWx0KHZhbHVlLCBmYWxsYmFjaykge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZmFsbGJhY2ssIHZhbHVlIHx8IHt9KTtcbn1cbi8qKlxyXG4gKiBSZXNvbHZlcyBnZXR0ZXJzIChmdW5jdGlvbnMpIGJ5IGNhbGxpbmcgdGhlbVxyXG4gKiBJZiBzaW1wbGUgdmFsdWUgaXMgZ2l2ZW4gaXQganVzdCBwYXNzZXMgdGhyb3VnaFxyXG4gKlxyXG4gKiBAcGFyYW0gdlxyXG4gKi9cblxuZnVuY3Rpb24gdmFsdWVGbih2KSB7XG4gIGlmICh0eXBlb2YgdiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gdi5hcHBseSh2b2lkIDAsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2O1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVXaXRoKGNvbmZpZywgcmVzb2x2ZXJzKSB7XG4gIGlmIChjb25maWcgPT09IHZvaWQgMCkge1xuICAgIGNvbmZpZyA9IHt9O1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gIGZvciAodmFyIF9pID0gMCwgX09iamVjdCRlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMocmVzb2x2ZXJzKTsgX2kgPCBfT2JqZWN0JGVudHJpZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgdmFyIF9PYmplY3QkZW50cmllcyRfaSA9IF9PYmplY3QkZW50cmllc1tfaV0sXG4gICAgICAgIGtleSA9IF9PYmplY3QkZW50cmllcyRfaVswXSxcbiAgICAgICAgcmVzb2x2ZXIgPSBfT2JqZWN0JGVudHJpZXMkX2lbMV07XG5cbiAgICBzd2l0Y2ggKHR5cGVvZiByZXNvbHZlcikge1xuICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICByZXN1bHRba2V5XSA9IHJlc29sdmVyLmNhbGwocmVzdWx0LCBjb25maWdba2V5XSwga2V5LCBjb25maWcpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgcmVzdWx0W2tleV0gPSByZXNvbHZlV2l0aChjb25maWdba2V5XSwgcmVzb2x2ZXIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIGlmIChyZXNvbHZlcikgcmVzdWx0W2tleV0gPSBjb25maWdba2V5XTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIERFRkFVTFRfRFJBR19ERUxBWSA9IDE4MDtcbnZhciBERUZBVUxUX1JVQkJFUkJBTkQgPSAwLjE1O1xudmFyIERFRkFVTFRfU1dJUEVfVkVMT0NJVFkgPSAwLjU7XG52YXIgREVGQVVMVF9TV0lQRV9ESVNUQU5DRSA9IDYwO1xudmFyIEludGVybmFsR2VzdHVyZU9wdGlvbnNOb3JtYWxpemVycyA9IHtcbiAgdGhyZXNob2xkOiBmdW5jdGlvbiB0aHJlc2hvbGQodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgdmFsdWUgPSAwO1xuICAgIH1cblxuICAgIHJldHVybiBlbnN1cmVWZWN0b3IodmFsdWUpO1xuICB9LFxuICBydWJiZXJiYW5kOiBmdW5jdGlvbiBydWJiZXJiYW5kKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHZhbHVlID0gMDtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICBjYXNlIHRydWU6XG4gICAgICAgIHJldHVybiBlbnN1cmVWZWN0b3IoREVGQVVMVF9SVUJCRVJCQU5EKTtcblxuICAgICAgY2FzZSBmYWxzZTpcbiAgICAgICAgcmV0dXJuIGVuc3VyZVZlY3RvcigwKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGVuc3VyZVZlY3Rvcih2YWx1ZSk7XG4gICAgfVxuICB9LFxuICBlbmFibGVkOiBmdW5jdGlvbiBlbmFibGVkKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG4gIHRyaWdnZXJBbGxFdmVudHM6IGZ1bmN0aW9uIHRyaWdnZXJBbGxFdmVudHModmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG4gIGluaXRpYWw6IGZ1bmN0aW9uIGluaXRpYWwodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgdmFsdWUgPSAwO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHJldHVybiB2YWx1ZTtcbiAgICByZXR1cm4gZW5zdXJlVmVjdG9yKHZhbHVlKTtcbiAgfVxufTtcblxudmFyIEludGVybmFsQ29vcmRpbmF0ZXNPcHRpb25zTm9ybWFsaXplcnMgPSAvKiNfX1BVUkVfXyovX2V4dGVuZHMoe30sIEludGVybmFsR2VzdHVyZU9wdGlvbnNOb3JtYWxpemVycywge1xuICBheGlzOiB0cnVlLFxuICBsb2NrRGlyZWN0aW9uOiBmdW5jdGlvbiBsb2NrRGlyZWN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICBib3VuZHM6IGZ1bmN0aW9uIGJvdW5kcyh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICB2YWx1ZSA9IHt9O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHJldHVybiBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgIHJldHVybiBJbnRlcm5hbENvb3JkaW5hdGVzT3B0aW9uc05vcm1hbGl6ZXJzLmJvdW5kcyh2YWx1ZShzdGF0ZSkpO1xuICAgIH07XG4gICAgdmFyIF92YWx1ZTIgPSB2YWx1ZSxcbiAgICAgICAgX3ZhbHVlMiRsZWZ0ID0gX3ZhbHVlMi5sZWZ0LFxuICAgICAgICBsZWZ0ID0gX3ZhbHVlMiRsZWZ0ID09PSB2b2lkIDAgPyAtSW5maW5pdHkgOiBfdmFsdWUyJGxlZnQsXG4gICAgICAgIF92YWx1ZTIkcmlnaHQgPSBfdmFsdWUyLnJpZ2h0LFxuICAgICAgICByaWdodCA9IF92YWx1ZTIkcmlnaHQgPT09IHZvaWQgMCA/IEluZmluaXR5IDogX3ZhbHVlMiRyaWdodCxcbiAgICAgICAgX3ZhbHVlMiR0b3AgPSBfdmFsdWUyLnRvcCxcbiAgICAgICAgdG9wID0gX3ZhbHVlMiR0b3AgPT09IHZvaWQgMCA/IC1JbmZpbml0eSA6IF92YWx1ZTIkdG9wLFxuICAgICAgICBfdmFsdWUyJGJvdHRvbSA9IF92YWx1ZTIuYm90dG9tLFxuICAgICAgICBib3R0b20gPSBfdmFsdWUyJGJvdHRvbSA9PT0gdm9pZCAwID8gSW5maW5pdHkgOiBfdmFsdWUyJGJvdHRvbTtcbiAgICByZXR1cm4gW1tsZWZ0LCByaWdodF0sIFt0b3AsIGJvdHRvbV1dO1xuICB9XG59KTtcblxudmFyIGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudDtcbnZhciBJbnRlcm5hbEdlbmVyaWNPcHRpb25zTm9ybWFsaXplcnMgPSB7XG4gIGVuYWJsZWQ6IGZ1bmN0aW9uIGVuYWJsZWQodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgdmFsdWUgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfSxcbiAgZG9tVGFyZ2V0OiB0cnVlLFxuICB3aW5kb3c6IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX3dpbmRvdykge1xuICAgIGZ1bmN0aW9uIHdpbmRvdyhfeCkge1xuICAgICAgcmV0dXJuIF93aW5kb3cuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICB3aW5kb3cudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3dpbmRvdy50b1N0cmluZygpO1xuICAgIH07XG5cbiAgICByZXR1cm4gd2luZG93O1xuICB9KGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICB2YWx1ZSA9IGlzQnJvd3NlciA/IHdpbmRvdyA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH0pLFxuICBldmVudE9wdGlvbnM6IGZ1bmN0aW9uIGV2ZW50T3B0aW9ucyhfdGVtcCkge1xuICAgIHZhciBfcmVmID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAsXG4gICAgICAgIF9yZWYkcGFzc2l2ZSA9IF9yZWYucGFzc2l2ZSxcbiAgICAgICAgcGFzc2l2ZSA9IF9yZWYkcGFzc2l2ZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWYkcGFzc2l2ZSxcbiAgICAgICAgX3JlZiRjYXB0dXJlID0gX3JlZi5jYXB0dXJlLFxuICAgICAgICBjYXB0dXJlID0gX3JlZiRjYXB0dXJlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkY2FwdHVyZTtcblxuICAgIHJldHVybiB7XG4gICAgICBwYXNzaXZlOiBwYXNzaXZlLFxuICAgICAgY2FwdHVyZTogY2FwdHVyZVxuICAgIH07XG4gIH1cbn07XG5cbnZhciBJbnRlcm5hbERpc3RhbmNlQW5nbGVPcHRpb25zTm9ybWFsaXplcnMgPSAvKiNfX1BVUkVfXyovX2V4dGVuZHMoe30sIEludGVybmFsR2VzdHVyZU9wdGlvbnNOb3JtYWxpemVycywge1xuICBib3VuZHM6IGZ1bmN0aW9uIGJvdW5kcyhfdmFsdWUsIF9rZXksIF9yZWYyKSB7XG4gICAgdmFyIF9yZWYyJGRpc3RhbmNlQm91bmRzID0gX3JlZjIuZGlzdGFuY2VCb3VuZHMsXG4gICAgICAgIGRpc3RhbmNlQm91bmRzID0gX3JlZjIkZGlzdGFuY2VCb3VuZHMgPT09IHZvaWQgMCA/IHt9IDogX3JlZjIkZGlzdGFuY2VCb3VuZHMsXG4gICAgICAgIF9yZWYyJGFuZ2xlQm91bmRzID0gX3JlZjIuYW5nbGVCb3VuZHMsXG4gICAgICAgIGFuZ2xlQm91bmRzID0gX3JlZjIkYW5nbGVCb3VuZHMgPT09IHZvaWQgMCA/IHt9IDogX3JlZjIkYW5nbGVCb3VuZHM7XG5cbiAgICB2YXIgX2Rpc3RhbmNlQm91bmRzID0gZnVuY3Rpb24gX2Rpc3RhbmNlQm91bmRzKHN0YXRlKSB7XG4gICAgICB2YXIgRCA9IGFzc2lnbkRlZmF1bHQodmFsdWVGbihkaXN0YW5jZUJvdW5kcywgc3RhdGUpLCB7XG4gICAgICAgIG1pbjogLUluZmluaXR5LFxuICAgICAgICBtYXg6IEluZmluaXR5XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBbRC5taW4sIEQubWF4XTtcbiAgICB9O1xuXG4gICAgdmFyIF9hbmdsZUJvdW5kcyA9IGZ1bmN0aW9uIF9hbmdsZUJvdW5kcyhzdGF0ZSkge1xuICAgICAgdmFyIEEgPSBhc3NpZ25EZWZhdWx0KHZhbHVlRm4oYW5nbGVCb3VuZHMsIHN0YXRlKSwge1xuICAgICAgICBtaW46IC1JbmZpbml0eSxcbiAgICAgICAgbWF4OiBJbmZpbml0eVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gW0EubWluLCBBLm1heF07XG4gICAgfTtcblxuICAgIGlmICh0eXBlb2YgZGlzdGFuY2VCb3VuZHMgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGFuZ2xlQm91bmRzICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gW19kaXN0YW5jZUJvdW5kcygpLCBfYW5nbGVCb3VuZHMoKV07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgcmV0dXJuIFtfZGlzdGFuY2VCb3VuZHMoc3RhdGUpLCBfYW5nbGVCb3VuZHMoc3RhdGUpXTtcbiAgICB9O1xuICB9XG59KTtcblxudmFyIEludGVybmFsRHJhZ09wdGlvbnNOb3JtYWxpemVycyA9IC8qI19fUFVSRV9fKi9fZXh0ZW5kcyh7fSwgSW50ZXJuYWxDb29yZGluYXRlc09wdGlvbnNOb3JtYWxpemVycywge1xuICB0aHJlc2hvbGQ6IGZ1bmN0aW9uIHRocmVzaG9sZCh2LCBfaywgX3JlZjMpIHtcbiAgICB2YXIgX3JlZjMkZmlsdGVyVGFwcyA9IF9yZWYzLmZpbHRlclRhcHMsXG4gICAgICAgIGZpbHRlclRhcHMgPSBfcmVmMyRmaWx0ZXJUYXBzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYzJGZpbHRlclRhcHMsXG4gICAgICAgIF9yZWYzJGxvY2tEaXJlY3Rpb24gPSBfcmVmMy5sb2NrRGlyZWN0aW9uLFxuICAgICAgICBsb2NrRGlyZWN0aW9uID0gX3JlZjMkbG9ja0RpcmVjdGlvbiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmMyRsb2NrRGlyZWN0aW9uLFxuICAgICAgICBfcmVmMyRheGlzID0gX3JlZjMuYXhpcyxcbiAgICAgICAgYXhpcyA9IF9yZWYzJGF4aXMgPT09IHZvaWQgMCA/IHVuZGVmaW5lZCA6IF9yZWYzJGF4aXM7XG4gICAgdmFyIEEgPSBlbnN1cmVWZWN0b3IodiwgZmlsdGVyVGFwcyA/IDMgOiBsb2NrRGlyZWN0aW9uID8gMSA6IGF4aXMgPyAxIDogMCk7XG4gICAgdGhpcy5maWx0ZXJUYXBzID0gZmlsdGVyVGFwcyB8fCBBWzBdICsgQVsxXSA+IDA7XG4gICAgcmV0dXJuIEE7XG4gIH0sXG4gIHN3aXBlVmVsb2NpdHk6IGZ1bmN0aW9uIHN3aXBlVmVsb2NpdHkodikge1xuICAgIGlmICh2ID09PSB2b2lkIDApIHtcbiAgICAgIHYgPSBERUZBVUxUX1NXSVBFX1ZFTE9DSVRZO1xuICAgIH1cblxuICAgIHJldHVybiBlbnN1cmVWZWN0b3Iodik7XG4gIH0sXG4gIHN3aXBlRGlzdGFuY2U6IGZ1bmN0aW9uIHN3aXBlRGlzdGFuY2Uodikge1xuICAgIGlmICh2ID09PSB2b2lkIDApIHtcbiAgICAgIHYgPSBERUZBVUxUX1NXSVBFX0RJU1RBTkNFO1xuICAgIH1cblxuICAgIHJldHVybiBlbnN1cmVWZWN0b3Iodik7XG4gIH0sXG4gIGRlbGF5OiBmdW5jdGlvbiBkZWxheSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICB2YWx1ZSA9IDA7XG4gICAgfVxuXG4gICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgY2FzZSB0cnVlOlxuICAgICAgICByZXR1cm4gREVGQVVMVF9EUkFHX0RFTEFZO1xuXG4gICAgICBjYXNlIGZhbHNlOlxuICAgICAgICByZXR1cm4gMDtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGdldEludGVybmFsR2VuZXJpY09wdGlvbnMoY29uZmlnKSB7XG4gIGlmIChjb25maWcgPT09IHZvaWQgMCkge1xuICAgIGNvbmZpZyA9IHt9O1xuICB9XG5cbiAgLy8gVE9ETyB3YXJuIHdoZW4gcGFzc2l2ZSBpcyBzZXQgdG8gdHJ1ZSBhbmQgZG9tVGFyZ2V0IGlzIHVuZGVmaW5lZFxuICByZXR1cm4gcmVzb2x2ZVdpdGgoY29uZmlnLCBJbnRlcm5hbEdlbmVyaWNPcHRpb25zTm9ybWFsaXplcnMpO1xufVxuZnVuY3Rpb24gZ2V0SW50ZXJuYWxDb29yZGluYXRlc09wdGlvbnMoY29uZmlnKSB7XG4gIGlmIChjb25maWcgPT09IHZvaWQgMCkge1xuICAgIGNvbmZpZyA9IHt9O1xuICB9XG5cbiAgcmV0dXJuIHJlc29sdmVXaXRoKGNvbmZpZywgSW50ZXJuYWxDb29yZGluYXRlc09wdGlvbnNOb3JtYWxpemVycyk7XG59XG5mdW5jdGlvbiBnZXRJbnRlcm5hbERpc3RhbmNlQW5nbGVPcHRpb25zKGNvbmZpZykge1xuICBpZiAoY29uZmlnID09PSB2b2lkIDApIHtcbiAgICBjb25maWcgPSB7fTtcbiAgfVxuXG4gIHJldHVybiByZXNvbHZlV2l0aChjb25maWcsIEludGVybmFsRGlzdGFuY2VBbmdsZU9wdGlvbnNOb3JtYWxpemVycyk7XG59XG5mdW5jdGlvbiBnZXRJbnRlcm5hbERyYWdPcHRpb25zKGNvbmZpZykge1xuICBpZiAoY29uZmlnID09PSB2b2lkIDApIHtcbiAgICBjb25maWcgPSB7fTtcbiAgfVxuXG4gIHJldHVybiByZXNvbHZlV2l0aChjb25maWcsIEludGVybmFsRHJhZ09wdGlvbnNOb3JtYWxpemVycyk7XG59XG5cbmZ1bmN0aW9uIF9idWlsZE1vdmVDb25maWcoX3JlZikge1xuICB2YXIgZG9tVGFyZ2V0ID0gX3JlZi5kb21UYXJnZXQsXG4gICAgICBldmVudE9wdGlvbnMgPSBfcmVmLmV2ZW50T3B0aW9ucyxcbiAgICAgIHdpbmRvdyA9IF9yZWYud2luZG93LFxuICAgICAgZW5hYmxlZCA9IF9yZWYuZW5hYmxlZCxcbiAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmLCBbXCJkb21UYXJnZXRcIiwgXCJldmVudE9wdGlvbnNcIiwgXCJ3aW5kb3dcIiwgXCJlbmFibGVkXCJdKTtcblxuICB2YXIgb3B0cyA9IGdldEludGVybmFsR2VuZXJpY09wdGlvbnMoe1xuICAgIGRvbVRhcmdldDogZG9tVGFyZ2V0LFxuICAgIGV2ZW50T3B0aW9uczogZXZlbnRPcHRpb25zLFxuICAgIHdpbmRvdzogd2luZG93LFxuICAgIGVuYWJsZWQ6IGVuYWJsZWRcbiAgfSk7XG4gIG9wdHMubW92ZSA9IGdldEludGVybmFsQ29vcmRpbmF0ZXNPcHRpb25zKHJlc3QpO1xuICByZXR1cm4gb3B0cztcbn1cbmZ1bmN0aW9uIF9idWlsZEhvdmVyQ29uZmlnKF9yZWYyKSB7XG4gIHZhciBkb21UYXJnZXQgPSBfcmVmMi5kb21UYXJnZXQsXG4gICAgICBldmVudE9wdGlvbnMgPSBfcmVmMi5ldmVudE9wdGlvbnMsXG4gICAgICB3aW5kb3cgPSBfcmVmMi53aW5kb3csXG4gICAgICBlbmFibGVkID0gX3JlZjIuZW5hYmxlZCxcbiAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmMiwgW1wiZG9tVGFyZ2V0XCIsIFwiZXZlbnRPcHRpb25zXCIsIFwid2luZG93XCIsIFwiZW5hYmxlZFwiXSk7XG5cbiAgdmFyIG9wdHMgPSBnZXRJbnRlcm5hbEdlbmVyaWNPcHRpb25zKHtcbiAgICBkb21UYXJnZXQ6IGRvbVRhcmdldCxcbiAgICBldmVudE9wdGlvbnM6IGV2ZW50T3B0aW9ucyxcbiAgICB3aW5kb3c6IHdpbmRvdyxcbiAgICBlbmFibGVkOiBlbmFibGVkXG4gIH0pO1xuICBvcHRzLmhvdmVyID0gX2V4dGVuZHMoe1xuICAgIGVuYWJsZWQ6IHRydWVcbiAgfSwgcmVzdCk7XG4gIHJldHVybiBvcHRzO1xufVxuZnVuY3Rpb24gX2J1aWxkRHJhZ0NvbmZpZyhfcmVmMykge1xuICB2YXIgZG9tVGFyZ2V0ID0gX3JlZjMuZG9tVGFyZ2V0LFxuICAgICAgZXZlbnRPcHRpb25zID0gX3JlZjMuZXZlbnRPcHRpb25zLFxuICAgICAgd2luZG93ID0gX3JlZjMud2luZG93LFxuICAgICAgZW5hYmxlZCA9IF9yZWYzLmVuYWJsZWQsXG4gICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZjMsIFtcImRvbVRhcmdldFwiLCBcImV2ZW50T3B0aW9uc1wiLCBcIndpbmRvd1wiLCBcImVuYWJsZWRcIl0pO1xuXG4gIHZhciBvcHRzID0gZ2V0SW50ZXJuYWxHZW5lcmljT3B0aW9ucyh7XG4gICAgZG9tVGFyZ2V0OiBkb21UYXJnZXQsXG4gICAgZXZlbnRPcHRpb25zOiBldmVudE9wdGlvbnMsXG4gICAgd2luZG93OiB3aW5kb3csXG4gICAgZW5hYmxlZDogZW5hYmxlZFxuICB9KTtcbiAgb3B0cy5kcmFnID0gZ2V0SW50ZXJuYWxEcmFnT3B0aW9ucyhyZXN0KTtcbiAgcmV0dXJuIG9wdHM7XG59XG5mdW5jdGlvbiBfYnVpbGRQaW5jaENvbmZpZyhfcmVmNCkge1xuICB2YXIgZG9tVGFyZ2V0ID0gX3JlZjQuZG9tVGFyZ2V0LFxuICAgICAgZXZlbnRPcHRpb25zID0gX3JlZjQuZXZlbnRPcHRpb25zLFxuICAgICAgd2luZG93ID0gX3JlZjQud2luZG93LFxuICAgICAgZW5hYmxlZCA9IF9yZWY0LmVuYWJsZWQsXG4gICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZjQsIFtcImRvbVRhcmdldFwiLCBcImV2ZW50T3B0aW9uc1wiLCBcIndpbmRvd1wiLCBcImVuYWJsZWRcIl0pO1xuXG4gIHZhciBvcHRzID0gZ2V0SW50ZXJuYWxHZW5lcmljT3B0aW9ucyh7XG4gICAgZG9tVGFyZ2V0OiBkb21UYXJnZXQsXG4gICAgZXZlbnRPcHRpb25zOiBldmVudE9wdGlvbnMsXG4gICAgd2luZG93OiB3aW5kb3csXG4gICAgZW5hYmxlZDogZW5hYmxlZFxuICB9KTtcbiAgb3B0cy5waW5jaCA9IGdldEludGVybmFsRGlzdGFuY2VBbmdsZU9wdGlvbnMocmVzdCk7XG4gIHJldHVybiBvcHRzO1xufVxuZnVuY3Rpb24gX2J1aWxkU2Nyb2xsQ29uZmlnKF9yZWY1KSB7XG4gIHZhciBkb21UYXJnZXQgPSBfcmVmNS5kb21UYXJnZXQsXG4gICAgICBldmVudE9wdGlvbnMgPSBfcmVmNS5ldmVudE9wdGlvbnMsXG4gICAgICB3aW5kb3cgPSBfcmVmNS53aW5kb3csXG4gICAgICBlbmFibGVkID0gX3JlZjUuZW5hYmxlZCxcbiAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmNSwgW1wiZG9tVGFyZ2V0XCIsIFwiZXZlbnRPcHRpb25zXCIsIFwid2luZG93XCIsIFwiZW5hYmxlZFwiXSk7XG5cbiAgdmFyIG9wdHMgPSBnZXRJbnRlcm5hbEdlbmVyaWNPcHRpb25zKHtcbiAgICBkb21UYXJnZXQ6IGRvbVRhcmdldCxcbiAgICBldmVudE9wdGlvbnM6IGV2ZW50T3B0aW9ucyxcbiAgICB3aW5kb3c6IHdpbmRvdyxcbiAgICBlbmFibGVkOiBlbmFibGVkXG4gIH0pO1xuICBvcHRzLnNjcm9sbCA9IGdldEludGVybmFsQ29vcmRpbmF0ZXNPcHRpb25zKHJlc3QpO1xuICByZXR1cm4gb3B0cztcbn1cbmZ1bmN0aW9uIF9idWlsZFdoZWVsQ29uZmlnKF9yZWY2KSB7XG4gIHZhciBkb21UYXJnZXQgPSBfcmVmNi5kb21UYXJnZXQsXG4gICAgICBldmVudE9wdGlvbnMgPSBfcmVmNi5ldmVudE9wdGlvbnMsXG4gICAgICB3aW5kb3cgPSBfcmVmNi53aW5kb3csXG4gICAgICBlbmFibGVkID0gX3JlZjYuZW5hYmxlZCxcbiAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmNiwgW1wiZG9tVGFyZ2V0XCIsIFwiZXZlbnRPcHRpb25zXCIsIFwid2luZG93XCIsIFwiZW5hYmxlZFwiXSk7XG5cbiAgdmFyIG9wdHMgPSBnZXRJbnRlcm5hbEdlbmVyaWNPcHRpb25zKHtcbiAgICBkb21UYXJnZXQ6IGRvbVRhcmdldCxcbiAgICBldmVudE9wdGlvbnM6IGV2ZW50T3B0aW9ucyxcbiAgICB3aW5kb3c6IHdpbmRvdyxcbiAgICBlbmFibGVkOiBlbmFibGVkXG4gIH0pO1xuICBvcHRzLndoZWVsID0gZ2V0SW50ZXJuYWxDb29yZGluYXRlc09wdGlvbnMocmVzdCk7XG4gIHJldHVybiBvcHRzO1xufVxuZnVuY3Rpb24gYnVpbGRDb21wbGV4Q29uZmlnKGNvbmZpZywgYWN0aW9ucykge1xuICBpZiAoY29uZmlnID09PSB2b2lkIDApIHtcbiAgICBjb25maWcgPSB7fTtcbiAgfVxuXG4gIGlmIChhY3Rpb25zID09PSB2b2lkIDApIHtcbiAgICBhY3Rpb25zID0gbmV3IFNldCgpO1xuICB9XG5cbiAgdmFyIF9jb25maWcgPSBjb25maWcsXG4gICAgICBkcmFnID0gX2NvbmZpZy5kcmFnLFxuICAgICAgd2hlZWwgPSBfY29uZmlnLndoZWVsLFxuICAgICAgbW92ZSA9IF9jb25maWcubW92ZSxcbiAgICAgIHNjcm9sbCA9IF9jb25maWcuc2Nyb2xsLFxuICAgICAgcGluY2ggPSBfY29uZmlnLnBpbmNoLFxuICAgICAgaG92ZXIgPSBfY29uZmlnLmhvdmVyLFxuICAgICAgZXZlbnRPcHRpb25zID0gX2NvbmZpZy5ldmVudE9wdGlvbnMsXG4gICAgICB3aW5kb3cgPSBfY29uZmlnLndpbmRvdyxcbiAgICAgIGRvbVRhcmdldCA9IF9jb25maWcuZG9tVGFyZ2V0LFxuICAgICAgZW5hYmxlZCA9IF9jb25maWcuZW5hYmxlZDtcbiAgdmFyIG1lcmdlZENvbmZpZyA9IGdldEludGVybmFsR2VuZXJpY09wdGlvbnMoe1xuICAgIGV2ZW50T3B0aW9uczogZXZlbnRPcHRpb25zLFxuICAgIHdpbmRvdzogd2luZG93LFxuICAgIGRvbVRhcmdldDogZG9tVGFyZ2V0LFxuICAgIGVuYWJsZWQ6IGVuYWJsZWRcbiAgfSk7XG4gIGlmIChhY3Rpb25zLmhhcygnb25EcmFnJykpIG1lcmdlZENvbmZpZy5kcmFnID0gZ2V0SW50ZXJuYWxEcmFnT3B0aW9ucyhkcmFnKTtcbiAgaWYgKGFjdGlvbnMuaGFzKCdvbldoZWVsJykpIG1lcmdlZENvbmZpZy53aGVlbCA9IGdldEludGVybmFsQ29vcmRpbmF0ZXNPcHRpb25zKHdoZWVsKTtcbiAgaWYgKGFjdGlvbnMuaGFzKCdvblNjcm9sbCcpKSBtZXJnZWRDb25maWcuc2Nyb2xsID0gZ2V0SW50ZXJuYWxDb29yZGluYXRlc09wdGlvbnMoc2Nyb2xsKTtcbiAgaWYgKGFjdGlvbnMuaGFzKCdvbk1vdmUnKSkgbWVyZ2VkQ29uZmlnLm1vdmUgPSBnZXRJbnRlcm5hbENvb3JkaW5hdGVzT3B0aW9ucyhtb3ZlKTtcbiAgaWYgKGFjdGlvbnMuaGFzKCdvblBpbmNoJykpIG1lcmdlZENvbmZpZy5waW5jaCA9IGdldEludGVybmFsRGlzdGFuY2VBbmdsZU9wdGlvbnMocGluY2gpO1xuICBpZiAoYWN0aW9ucy5oYXMoJ29uSG92ZXInKSkgbWVyZ2VkQ29uZmlnLmhvdmVyID0gX2V4dGVuZHMoe1xuICAgIGVuYWJsZWQ6IHRydWVcbiAgfSwgaG92ZXIpO1xuICByZXR1cm4gbWVyZ2VkQ29uZmlnO1xufVxuXG5mdW5jdGlvbiBnZXRJbml0aWFsKG1peGVkKSB7XG4gIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgX2FjdGl2ZTogZmFsc2UsXG4gICAgX2Jsb2NrZWQ6IGZhbHNlLFxuICAgIF9pbnRlbnRpb25hbDogW2ZhbHNlLCBmYWxzZV0sXG4gICAgX21vdmVtZW50OiBbMCwgMF0sXG4gICAgX2luaXRpYWw6IFswLCAwXSxcbiAgICBfYm91bmRzOiBbWy1JbmZpbml0eSwgSW5maW5pdHldLCBbLUluZmluaXR5LCBJbmZpbml0eV1dLFxuICAgIF9sYXN0RXZlbnRUeXBlOiB1bmRlZmluZWQsXG4gICAgZXZlbnQ6IHVuZGVmaW5lZCxcbiAgICAvLyBjdXJyZW50VGFyZ2V0OiB1bmRlZmluZWQsXG4gICAgLy8gcG9pbnRlcklkOiB1bmRlZmluZWQsXG4gICAgaW50ZW50aW9uYWw6IGZhbHNlLFxuICAgIHZhbHVlczogWzAsIDBdLFxuICAgIHZlbG9jaXRpZXM6IFswLCAwXSxcbiAgICBkZWx0YTogWzAsIDBdLFxuICAgIG1vdmVtZW50OiBbMCwgMF0sXG4gICAgb2Zmc2V0OiBbMCwgMF0sXG4gICAgbGFzdE9mZnNldDogWzAsIDBdLFxuICAgIGRpcmVjdGlvbjogWzAsIDBdLFxuICAgIGluaXRpYWw6IFswLCAwXSxcbiAgICBwcmV2aW91czogWzAsIDBdLFxuICAgIGZpcnN0OiBmYWxzZSxcbiAgICBsYXN0OiBmYWxzZSxcbiAgICBhY3RpdmU6IGZhbHNlLFxuICAgIHRpbWVTdGFtcDogMCxcbiAgICBzdGFydFRpbWU6IDAsXG4gICAgZWxhcHNlZFRpbWU6IDAsXG4gICAgY2FuY2VsOiBub29wLFxuICAgIGNhbmNlbGVkOiBmYWxzZSxcbiAgICBtZW1vOiB1bmRlZmluZWQsXG4gICAgYXJnczogdW5kZWZpbmVkXG4gIH0sIG1peGVkKTtcbn1cblxuZnVuY3Rpb24gZ2V0SW5pdGlhbFN0YXRlKCkge1xuICB2YXIgc2hhcmVkID0ge1xuICAgIGhvdmVyaW5nOiBmYWxzZSxcbiAgICBzY3JvbGxpbmc6IGZhbHNlLFxuICAgIHdoZWVsaW5nOiBmYWxzZSxcbiAgICBkcmFnZ2luZzogZmFsc2UsXG4gICAgbW92aW5nOiBmYWxzZSxcbiAgICBwaW5jaGluZzogZmFsc2UsXG4gICAgdG91Y2hlczogMCxcbiAgICBidXR0b25zOiAwLFxuICAgIGRvd246IGZhbHNlLFxuICAgIHNoaWZ0S2V5OiBmYWxzZSxcbiAgICBhbHRLZXk6IGZhbHNlLFxuICAgIG1ldGFLZXk6IGZhbHNlLFxuICAgIGN0cmxLZXk6IGZhbHNlXG4gIH07XG4gIHZhciBkcmFnID0gZ2V0SW5pdGlhbCh7XG4gICAgYXhpczogdW5kZWZpbmVkLFxuICAgIHh5OiBbMCwgMF0sXG4gICAgdnh2eTogWzAsIDBdLFxuICAgIHZlbG9jaXR5OiAwLFxuICAgIGRpc3RhbmNlOiAwLFxuICAgIF9pc1RhcDogdHJ1ZSxcbiAgICBfZGVsYXllZEV2ZW50OiBmYWxzZSxcbiAgICBfcG9pbnRlcklkOiB1bmRlZmluZWQsXG4gICAgdGFwOiBmYWxzZSxcbiAgICBzd2lwZTogWzAsIDBdXG4gIH0pO1xuICB2YXIgcGluY2ggPSBnZXRJbml0aWFsKHtcbiAgICBkYTogWzAsIDBdLFxuICAgIHZkdmE6IFswLCAwXSxcbiAgICAvLyBAdHMtaWdub3JlIG9yaWdpbiBjYW4gbmV2ZXIgYmUgcGFzc2VkIGFzIHVuZGVmaW5lZCBpbiB1c2VybGFuZFxuICAgIG9yaWdpbjogdW5kZWZpbmVkLFxuICAgIHR1cm5zOiAwXG4gIH0pO1xuICB2YXIgd2hlZWwgPSBnZXRJbml0aWFsKHtcbiAgICBheGlzOiB1bmRlZmluZWQsXG4gICAgeHk6IFswLCAwXSxcbiAgICB2eHZ5OiBbMCwgMF0sXG4gICAgdmVsb2NpdHk6IDAsXG4gICAgZGlzdGFuY2U6IDBcbiAgfSk7XG4gIHZhciBtb3ZlID0gZ2V0SW5pdGlhbCh7XG4gICAgYXhpczogdW5kZWZpbmVkLFxuICAgIHh5OiBbMCwgMF0sXG4gICAgdnh2eTogWzAsIDBdLFxuICAgIHZlbG9jaXR5OiAwLFxuICAgIGRpc3RhbmNlOiAwXG4gIH0pO1xuICB2YXIgc2Nyb2xsID0gZ2V0SW5pdGlhbCh7XG4gICAgYXhpczogdW5kZWZpbmVkLFxuICAgIHh5OiBbMCwgMF0sXG4gICAgdnh2eTogWzAsIDBdLFxuICAgIHZlbG9jaXR5OiAwLFxuICAgIGRpc3RhbmNlOiAwXG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHNoYXJlZDogc2hhcmVkLFxuICAgIGRyYWc6IGRyYWcsXG4gICAgcGluY2g6IHBpbmNoLFxuICAgIHdoZWVsOiB3aGVlbCxcbiAgICBtb3ZlOiBtb3ZlLFxuICAgIHNjcm9sbDogc2Nyb2xsXG4gIH07XG59XG5cbnZhciBSZWNvZ25pemVyc01hcCA9IC8qI19fUFVSRV9fKi9uZXcgTWFwKCk7XG4vKipcclxuICogQHByaXZhdGVcclxuICogUmVjb2duaXplciBhYnN0cmFjdCBjbGFzcy5cclxuICovXG5cbnZhciBSZWNvZ25pemVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBhIGdlc3R1cmUgcmVjb2duaXplci5cclxuICAgKiBAcGFyYW0gc3RhdGVLZXkgZHJhZywgbW92ZSwgcGluY2gsIGV0Yy5cclxuICAgKiBAcGFyYW0gY29udHJvbGxlciB0aGUgY29udHJvbGxlciBhdHRhY2hlZCB0byB0aGUgZ2VzdHVyZVxyXG4gICAqIEBwYXJhbSBbYXJnc10gdGhlIGFyZ3MgdGhhdCBzaG91bGQgYmUgcGFzc2VkIHRvIHRoZSBnZXN0dXJlIGhhbmRsZXJcclxuICAgKi9cbiAgZnVuY3Rpb24gUmVjb2duaXplcihjb250cm9sbGVyLCBhcmdzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGlmIChhcmdzID09PSB2b2lkIDApIHtcbiAgICAgIGFyZ3MgPSBbXTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgdGhpcy5kZWJvdW5jZWQgPSB0cnVlOyAvLyBDb252ZW5pZW5jZSBtZXRob2QgdG8gc2V0IGEgdGltZW91dCBmb3IgYSBnaXZlbiBnZXN0dXJlXG5cbiAgICB0aGlzLnNldFRpbWVvdXQgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIG1zKSB7XG4gICAgICB2YXIgX3dpbmRvdztcblxuICAgICAgaWYgKG1zID09PSB2b2lkIDApIHtcbiAgICAgICAgbXMgPSAxNDA7XG4gICAgICB9XG5cbiAgICAgIGNsZWFyVGltZW91dChfdGhpcy5jb250cm9sbGVyLnRpbWVvdXRzW190aGlzLnN0YXRlS2V5XSk7XG5cbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAyID8gX2xlbiAtIDIgOiAwKSwgX2tleSA9IDI7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5IC0gMl0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIF90aGlzLmNvbnRyb2xsZXIudGltZW91dHNbX3RoaXMuc3RhdGVLZXldID0gKF93aW5kb3cgPSB3aW5kb3cpLnNldFRpbWVvdXQuYXBwbHkoX3dpbmRvdywgW2NhbGxiYWNrLCBtc10uY29uY2F0KGFyZ3MpKTtcbiAgICB9OyAvLyBDb252ZW5pZW5jZSBtZXRob2QgdG8gY2xlYXIgYSB0aW1lb3V0IGZvciBhIGdpdmVuIGdlc3R1cmVcblxuXG4gICAgdGhpcy5jbGVhclRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjbGVhclRpbWVvdXQoX3RoaXMuY29udHJvbGxlci50aW1lb3V0c1tfdGhpcy5zdGF0ZUtleV0pO1xuICAgIH07XG4gICAgLyoqXHJcbiAgICAgKiBGaXJlcyB0aGUgZ2VzdHVyZSBoYW5kbGVyXHJcbiAgICAgKi9cblxuXG4gICAgdGhpcy5maXJlR2VzdHVyZUhhbmRsZXIgPSBmdW5jdGlvbiAoZm9yY2VGbGFnKSB7XG4gICAgICBpZiAoZm9yY2VGbGFnID09PSB2b2lkIDApIHtcbiAgICAgICAgZm9yY2VGbGFnID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8qKlxyXG4gICAgICAgKiBJZiB0aGUgZ2VzdHVyZSBoYXMgYmVlbiBibG9ja2VkICh0aGlzIGNhbiBoYXBwZW4gd2hlbiB0aGUgZ2VzdHVyZSBoYXMgc3RhcnRlZCBpbiBhbiB1bndhbnRlZCBkaXJlY3Rpb24pLFxyXG4gICAgICAgKiBjbGVhbiBldmVyeXRoaW5nIGFuZCBkb24ndCBkbyBhbnl0aGluZy5cclxuICAgICAgICovXG4gICAgICBpZiAoX3RoaXMuc3RhdGUuX2Jsb2NrZWQpIHtcbiAgICAgICAgLy8gd2UgbmVlZCBkZWJvdW5jZWQgZ2VzdHVyZXMgdG8gZW5kIGJ5IHRoZW1zZWx2ZXNcbiAgICAgICAgaWYgKCFfdGhpcy5kZWJvdW5jZWQpIHtcbiAgICAgICAgICBfdGhpcy5zdGF0ZS5fYWN0aXZlID0gZmFsc2U7XG5cbiAgICAgICAgICBfdGhpcy5jbGVhbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IC8vIElmIHRoZSBnZXN0dXJlIGhhcyBubyBpbnRlbnRpb25hbCBkaW1lbnNpb24sIGRvbid0IGZpcmUgdGhlIGhhbmRsZXIuXG5cblxuICAgICAgaWYgKCFmb3JjZUZsYWcgJiYgIV90aGlzLnN0YXRlLmludGVudGlvbmFsICYmICFfdGhpcy5jb25maWcudHJpZ2dlckFsbEV2ZW50cykgcmV0dXJuIG51bGw7XG5cbiAgICAgIGlmIChfdGhpcy5zdGF0ZS5pbnRlbnRpb25hbCkge1xuICAgICAgICB2YXIgcHJldl9hY3RpdmUgPSBfdGhpcy5zdGF0ZS5hY3RpdmU7XG4gICAgICAgIHZhciBuZXh0X2FjdGl2ZSA9IF90aGlzLnN0YXRlLl9hY3RpdmU7XG4gICAgICAgIF90aGlzLnN0YXRlLmFjdGl2ZSA9IG5leHRfYWN0aXZlO1xuICAgICAgICBfdGhpcy5zdGF0ZS5maXJzdCA9IG5leHRfYWN0aXZlICYmICFwcmV2X2FjdGl2ZTtcbiAgICAgICAgX3RoaXMuc3RhdGUubGFzdCA9IHByZXZfYWN0aXZlICYmICFuZXh0X2FjdGl2ZTtcbiAgICAgICAgX3RoaXMuY29udHJvbGxlci5zdGF0ZS5zaGFyZWRbX3RoaXMuaW5nS2V5XSA9IG5leHRfYWN0aXZlOyAvLyBTZXRzIGRyYWdnaW5nLCBwaW5jaGluZywgZXRjLiB0byB0aGUgZ2VzdHVyZSBhY3RpdmUgc3RhdGVcbiAgICAgIH1cblxuICAgICAgdmFyIHN0YXRlID0gX2V4dGVuZHMoe30sIF90aGlzLmNvbnRyb2xsZXIuc3RhdGUuc2hhcmVkLCBfdGhpcy5zdGF0ZSwgX3RoaXMubWFwU3RhdGVWYWx1ZXMoX3RoaXMuc3RhdGUpKTsgLy8gQHRzLWlnbm9yZVxuXG5cbiAgICAgIHZhciBuZXdNZW1vID0gX3RoaXMuaGFuZGxlcihzdGF0ZSk7IC8vIFNldHMgbWVtbyB0byB0aGUgcmV0dXJuZWQgdmFsdWUgb2YgdGhlIGhhbmRsZXIgKHVubGVzcyBpdCdzIG5vdCB1bmRlZmluZWQpXG5cblxuICAgICAgX3RoaXMuc3RhdGUubWVtbyA9IG5ld01lbW8gIT09IHZvaWQgMCA/IG5ld01lbW8gOiBfdGhpcy5zdGF0ZS5tZW1vOyAvLyBDbGVhbnMgdGhlIGdlc3R1cmUgd2hlbiB0aGUgZ2VzdHVyZSBpcyBubyBsb25nZXIgYWN0aXZlLlxuXG4gICAgICBpZiAoIV90aGlzLnN0YXRlLl9hY3RpdmUpIF90aGlzLmNsZWFuKCk7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfTtcbiAgfSAvLyBSZXR1cm5zIHRoZSBnZXN0dXJlIGNvbmZpZ1xuXG5cbiAgdmFyIF9wcm90byA9IFJlY29nbml6ZXIucHJvdG90eXBlO1xuXG4gIC8vIENvbnZlbmllbmNlIG1ldGhvZCB0byB1cGRhdGUgdGhlIHNoYXJlZCBzdGF0ZVxuICBfcHJvdG8udXBkYXRlU2hhcmVkU3RhdGUgPSBmdW5jdGlvbiB1cGRhdGVTaGFyZWRTdGF0ZShzaGFyZWRTdGF0ZSkge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcy5jb250cm9sbGVyLnN0YXRlLnNoYXJlZCwgc2hhcmVkU3RhdGUpO1xuICB9IC8vIENvbnZlbmllbmNlIG1ldGhvZCB0byB1cGRhdGUgdGhlIGdlc3R1cmUgc3RhdGVcbiAgO1xuXG4gIF9wcm90by51cGRhdGVHZXN0dXJlU3RhdGUgPSBmdW5jdGlvbiB1cGRhdGVHZXN0dXJlU3RhdGUoZ2VzdHVyZVN0YXRlKSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLnN0YXRlLCBnZXN0dXJlU3RhdGUpO1xuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgc3RhdGUgcHJvcGVydGllcyBkZXBlbmRpbmcgb24gdGhlIG1vdmVtZW50IGFuZCBzdGF0ZS5cclxuICAgKlxyXG4gICAqIFNob3VsZCBiZSBvdmVycmlkZW4gZm9yIGN1c3RvbSBiZWhhdmlvciwgZG9lc24ndCBkbyBhbnl0aGluZyBpbiB0aGUgaW1wbGVtZW50YXRpb25cclxuICAgKiBiZWxvdy5cclxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5jaGVja0ludGVudGlvbmFsaXR5ID0gZnVuY3Rpb24gY2hlY2tJbnRlbnRpb25hbGl0eShfaW50ZW50aW9uYWwsIF9tb3ZlbWVudCkge1xuICAgIHJldHVybiB7XG4gICAgICBfaW50ZW50aW9uYWw6IF9pbnRlbnRpb25hbCxcbiAgICAgIF9ibG9ja2VkOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyBiYXNpYyBtb3ZlbWVudCBwcm9wZXJ0aWVzIGZvciB0aGUgZ2VzdHVyZSBiYXNlZCBvbiB0aGUgbmV4dCB2YWx1ZXMgYW5kIGN1cnJlbnQgc3RhdGUuXHJcbiAgICovXG4gIDtcblxuICBfcHJvdG8uZ2V0TW92ZW1lbnQgPSBmdW5jdGlvbiBnZXRNb3ZlbWVudCh2YWx1ZXMpIHtcbiAgICB2YXIgX3RoaXMkY29uZmlnID0gdGhpcy5jb25maWcsXG4gICAgICAgIGluaXRpYWwgPSBfdGhpcyRjb25maWcuaW5pdGlhbCxcbiAgICAgICAgYm91bmRzID0gX3RoaXMkY29uZmlnLmJvdW5kcyxcbiAgICAgICAgcnViYmVyYmFuZCA9IF90aGlzJGNvbmZpZy5ydWJiZXJiYW5kLFxuICAgICAgICBUID0gX3RoaXMkY29uZmlnLnRocmVzaG9sZDtcbiAgICB2YXIgX3RoaXMkc3RhdGUgPSB0aGlzLnN0YXRlLFxuICAgICAgICBfYm91bmRzID0gX3RoaXMkc3RhdGUuX2JvdW5kcyxcbiAgICAgICAgX2luaXRpYWwgPSBfdGhpcyRzdGF0ZS5faW5pdGlhbCxcbiAgICAgICAgX2FjdGl2ZSA9IF90aGlzJHN0YXRlLl9hY3RpdmUsXG4gICAgICAgIHdhc0ludGVudGlvbmFsID0gX3RoaXMkc3RhdGUuX2ludGVudGlvbmFsLFxuICAgICAgICBsYXN0T2Zmc2V0ID0gX3RoaXMkc3RhdGUubGFzdE9mZnNldCxcbiAgICAgICAgcHJldk1vdmVtZW50ID0gX3RoaXMkc3RhdGUubW92ZW1lbnQ7XG4gICAgdmFyIE0gPSB0aGlzLmdldEludGVybmFsTW92ZW1lbnQodmFsdWVzLCB0aGlzLnN0YXRlKTtcbiAgICB2YXIgaTAgPSB3YXNJbnRlbnRpb25hbFswXSA9PT0gZmFsc2UgPyBnZXRJbnRlbnRpb25hbERpc3BsYWNlbWVudChNWzBdLCBUWzBdKSA6IHdhc0ludGVudGlvbmFsWzBdO1xuICAgIHZhciBpMSA9IHdhc0ludGVudGlvbmFsWzFdID09PSBmYWxzZSA/IGdldEludGVudGlvbmFsRGlzcGxhY2VtZW50KE1bMV0sIFRbMV0pIDogd2FzSW50ZW50aW9uYWxbMV07IC8vIEdldCBnZXN0dXJlIHNwZWNpZmljIHN0YXRlIHByb3BlcnRpZXMgYmFzZWQgb24gaW50ZW50aW9uYWxpdHkgYW5kIG1vdmVtZW50LlxuXG4gICAgdmFyIGludGVudGlvbmFsaXR5Q2hlY2sgPSB0aGlzLmNoZWNrSW50ZW50aW9uYWxpdHkoW2kwLCBpMV0sIE0pO1xuXG4gICAgaWYgKGludGVudGlvbmFsaXR5Q2hlY2suX2Jsb2NrZWQpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgaW50ZW50aW9uYWxpdHlDaGVjaywge1xuICAgICAgICBfbW92ZW1lbnQ6IE0sXG4gICAgICAgIGRlbHRhOiBbMCwgMF1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBfaW50ZW50aW9uYWwgPSBpbnRlbnRpb25hbGl0eUNoZWNrLl9pbnRlbnRpb25hbDtcbiAgICB2YXIgX21vdmVtZW50ID0gTTtcblxuICAgIHZhciBfX2NhY2hlZEJvdW5kcztcblxuICAgIHZhciBfX2NhY2hlZEluaXRpYWw7XG5cbiAgICBpZiAoX2ludGVudGlvbmFsWzBdICE9PSBmYWxzZSAmJiB3YXNJbnRlbnRpb25hbFswXSA9PT0gZmFsc2UpIHtcbiAgICAgIF9fY2FjaGVkSW5pdGlhbCA9IHZhbHVlRm4oaW5pdGlhbCwgdGhpcy5zdGF0ZSk7XG4gICAgICBfX2NhY2hlZEJvdW5kcyA9IHZhbHVlRm4oYm91bmRzLCB0aGlzLnN0YXRlKTtcbiAgICAgIF9pbml0aWFsWzBdID0gX19jYWNoZWRJbml0aWFsWzBdO1xuICAgICAgX2JvdW5kc1swXSA9IF9fY2FjaGVkQm91bmRzWzBdO1xuICAgIH1cblxuICAgIGlmIChfaW50ZW50aW9uYWxbMV0gIT09IGZhbHNlICYmIHdhc0ludGVudGlvbmFsWzFdID09PSBmYWxzZSkge1xuICAgICAgdmFyIF9jYWNoZWRJbml0aWFsLCBfY2FjaGVkQm91bmRzO1xuXG4gICAgICBfX2NhY2hlZEluaXRpYWwgPSAoX2NhY2hlZEluaXRpYWwgPSBfX2NhY2hlZEluaXRpYWwpICE9IG51bGwgPyBfY2FjaGVkSW5pdGlhbCA6IHZhbHVlRm4oaW5pdGlhbCwgdGhpcy5zdGF0ZSk7XG4gICAgICBfX2NhY2hlZEJvdW5kcyA9IChfY2FjaGVkQm91bmRzID0gX19jYWNoZWRCb3VuZHMpICE9IG51bGwgPyBfY2FjaGVkQm91bmRzIDogdmFsdWVGbihib3VuZHMsIHRoaXMuc3RhdGUpO1xuICAgICAgX2luaXRpYWxbMV0gPSBfX2NhY2hlZEluaXRpYWxbMV07XG4gICAgICBfYm91bmRzWzFdID0gX19jYWNoZWRCb3VuZHNbMV07XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogVGhlIG1vdmVtZW50IHNlbnQgdG8gdGhlIGhhbmRsZXIgaGFzIDAgaW4gaXRzIGRpbWVuc2lvbnMgd2hlbiBpbnRlbnRpb25hbGl0eSBpcyBmYWxzZS5cclxuICAgICAqIEl0IGlzIGNhbGN1bGF0ZWQgZnJvbSB0aGUgYWN0dWFsIG1vdmVtZW50IG1pbnVzIHRoZSB0aHJlc2hvbGQuXHJcbiAgICAgKi9cblxuXG4gICAgdmFyIG1vdmVtZW50ID0gW19pbnRlbnRpb25hbFswXSAhPT0gZmFsc2UgPyBNWzBdIC0gX2ludGVudGlvbmFsWzBdIDogX2luaXRpYWxbMF0sIF9pbnRlbnRpb25hbFsxXSAhPT0gZmFsc2UgPyBNWzFdIC0gX2ludGVudGlvbmFsWzFdIDogX2luaXRpYWxbMV1dO1xuICAgIHZhciBvZmZzZXQgPSBhZGRWKG1vdmVtZW50LCBsYXN0T2Zmc2V0KTtcbiAgICAvKipcclxuICAgICAqIFJ1YmJlcmJhbmQgc2hvdWxkIGJlIDAgd2hlbiB0aGUgZ2VzdHVyZSBpcyBubyBsb25nZXIgYWN0aXZlLCBzbyB0aGF0IG1vdmVtZW50XHJcbiAgICAgKiBhbmQgb2Zmc2V0IGNhbiByZXR1cm4gd2l0aGluIHRoZWlyIGJvdW5kcy5cclxuICAgICAqL1xuXG4gICAgdmFyIF9ydWJiZXJiYW5kID0gX2FjdGl2ZSA/IHJ1YmJlcmJhbmQgOiBbMCwgMF07XG5cbiAgICBtb3ZlbWVudCA9IGNvbXB1dGVSdWJiZXJiYW5kKF9ib3VuZHMsIGFkZFYobW92ZW1lbnQsIF9pbml0aWFsKSwgX3J1YmJlcmJhbmQpO1xuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgaW50ZW50aW9uYWxpdHlDaGVjaywge1xuICAgICAgaW50ZW50aW9uYWw6IF9pbnRlbnRpb25hbFswXSAhPT0gZmFsc2UgfHwgX2ludGVudGlvbmFsWzFdICE9PSBmYWxzZSxcbiAgICAgIF9pbml0aWFsOiBfaW5pdGlhbCxcbiAgICAgIF9tb3ZlbWVudDogX21vdmVtZW50LFxuICAgICAgbW92ZW1lbnQ6IG1vdmVtZW50LFxuICAgICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgICBvZmZzZXQ6IGNvbXB1dGVSdWJiZXJiYW5kKF9ib3VuZHMsIG9mZnNldCwgX3J1YmJlcmJhbmQpLFxuICAgICAgZGVsdGE6IHN1YlYobW92ZW1lbnQsIHByZXZNb3ZlbWVudClcbiAgICB9KTtcbiAgfSAvLyBDbGVhbnMgdGhlIGdlc3R1cmUuIENhbiBiZSBvdmVycmlkZW4gYnkgZ2VzdHVyZXMuXG4gIDtcblxuICBfcHJvdG8uY2xlYW4gPSBmdW5jdGlvbiBjbGVhbigpIHtcbiAgICB0aGlzLmNsZWFyVGltZW91dCgpO1xuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhSZWNvZ25pemVyLCBbe1xuICAgIGtleTogXCJjb25maWdcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xsZXIuY29uZmlnW3RoaXMuc3RhdGVLZXldO1xuICAgIH0gLy8gSXMgdGhlIGdlc3R1cmUgZW5hYmxlZFxuXG4gIH0sIHtcbiAgICBrZXk6IFwiZW5hYmxlZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udHJvbGxlci5jb25maWcuZW5hYmxlZCAmJiB0aGlzLmNvbmZpZy5lbmFibGVkO1xuICAgIH0gLy8gUmV0dXJucyB0aGUgY29udHJvbGxlciBzdGF0ZSBmb3IgYSBnaXZlbiBnZXN0dXJlXG5cbiAgfSwge1xuICAgIGtleTogXCJzdGF0ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udHJvbGxlci5zdGF0ZVt0aGlzLnN0YXRlS2V5XTtcbiAgICB9IC8vIFJldHVybnMgdGhlIGdlc3R1cmUgaGFuZGxlclxuXG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udHJvbGxlci5oYW5kbGVyc1t0aGlzLnN0YXRlS2V5XTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmVjb2duaXplcjtcbn0oKTsgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiBnZXRJbnRlbnRpb25hbERpc3BsYWNlbWVudChtb3ZlbWVudCwgdGhyZXNob2xkKSB7XG4gIGlmIChNYXRoLmFicyhtb3ZlbWVudCkgPj0gdGhyZXNob2xkKSB7XG4gICAgcmV0dXJuIHNpZ24obW92ZW1lbnQpICogdGhyZXNob2xkO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21wdXRlUnViYmVyYmFuZChib3VuZHMsIF9yZWYsIF9yZWYyKSB7XG4gIHZhciBWeCA9IF9yZWZbMF0sXG4gICAgICBWeSA9IF9yZWZbMV07XG4gIHZhciBSeCA9IF9yZWYyWzBdLFxuICAgICAgUnkgPSBfcmVmMlsxXTtcbiAgdmFyIF9ib3VuZHMkID0gYm91bmRzWzBdLFxuICAgICAgWDEgPSBfYm91bmRzJFswXSxcbiAgICAgIFgyID0gX2JvdW5kcyRbMV0sXG4gICAgICBfYm91bmRzJDIgPSBib3VuZHNbMV0sXG4gICAgICBZMSA9IF9ib3VuZHMkMlswXSxcbiAgICAgIFkyID0gX2JvdW5kcyQyWzFdO1xuICByZXR1cm4gW3J1YmJlcmJhbmRJZk91dE9mQm91bmRzKFZ4LCBYMSwgWDIsIFJ4KSwgcnViYmVyYmFuZElmT3V0T2ZCb3VuZHMoVnksIFkxLCBZMiwgUnkpXTtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIGEgZ2VuZXJpYywgY29tbW9uIHBheWxvYWQgZm9yIGFsbCBnZXN0dXJlcyBmcm9tIGFuIGV2ZW50LlxyXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRHZW5lcmljUGF5bG9hZChfcmVmMywgZXZlbnQsIGlzU3RhcnRFdmVudCkge1xuICB2YXIgc3RhdGUgPSBfcmVmMy5zdGF0ZSxcbiAgICAgIGFyZ3MgPSBfcmVmMy5hcmdzO1xuICB2YXIgdGltZVN0YW1wID0gZXZlbnQudGltZVN0YW1wLFxuICAgICAgX2xhc3RFdmVudFR5cGUgPSBldmVudC50eXBlO1xuICB2YXIgcHJldmlvdXMgPSBzdGF0ZS52YWx1ZXM7XG4gIHZhciBlbGFwc2VkVGltZSA9IGlzU3RhcnRFdmVudCA/IDAgOiB0aW1lU3RhbXAgLSBzdGF0ZS5zdGFydFRpbWU7XG4gIHJldHVybiB7XG4gICAgX2xhc3RFdmVudFR5cGU6IF9sYXN0RXZlbnRUeXBlLFxuICAgIGV2ZW50OiBldmVudCxcbiAgICB0aW1lU3RhbXA6IHRpbWVTdGFtcCxcbiAgICBlbGFwc2VkVGltZTogZWxhcHNlZFRpbWUsXG4gICAgYXJnczogYXJncyxcbiAgICBwcmV2aW91czogcHJldmlvdXNcbiAgfTtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSByZWluaXRpYWxpemVkIHN0YXJ0IHN0YXRlIGZvciB0aGUgZ2VzdHVyZS5cclxuICogU2hvdWxkIGJlIGNvbW1vbiB0byBhbGwgZ2VzdHVyZXMuXHJcbiAqL1xuXG5mdW5jdGlvbiBnZXRTdGFydEdlc3R1cmVTdGF0ZShyZWNvZ25pemVyLCB2YWx1ZXMsIGV2ZW50KSB7XG4gIHZhciBvZmZzZXQgPSByZWNvZ25pemVyLnN0YXRlLm9mZnNldDtcbiAgdmFyIHN0YXJ0VGltZSA9IGV2ZW50LnRpbWVTdGFtcDtcbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBnZXRJbml0aWFsU3RhdGUoKVtyZWNvZ25pemVyLnN0YXRlS2V5XSwge1xuICAgIF9hY3RpdmU6IHRydWUsXG4gICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgaW5pdGlhbDogdmFsdWVzLFxuICAgIG9mZnNldDogb2Zmc2V0LFxuICAgIGxhc3RPZmZzZXQ6IG9mZnNldCxcbiAgICBzdGFydFRpbWU6IHN0YXJ0VGltZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gcGFydGlhbChmdW5jLCBzdGF0ZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJldHVybiBmdW5jLmNhbGwuYXBwbHkoZnVuYywgW3RoaXMsIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgZXZlbnQ6IGV2ZW50XG4gICAgfSldLmNvbmNhdChhcmdzKSk7XG4gIH07XG59XG4vKipcclxuICogVGhlIGNvbnRyb2xsZXIgd2lsbCBrZWVwIHRyYWNrIG9mIHRoZSBzdGF0ZSBmb3IgYWxsIGdlc3R1cmVzIGFuZCBhbHNvIGtlZXBcclxuICogdHJhY2sgb2YgdGltZW91dHMsIGFuZCB3aW5kb3cgbGlzdGVuZXJzLlxyXG4gKi9cblxuXG52YXIgQ29udHJvbGxlciA9IGZ1bmN0aW9uIENvbnRyb2xsZXIoY2xhc3Nlcykge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHRoaXMuY2xhc3NlcyA9IGNsYXNzZXM7XG5cbiAgdGhpcy5iaW5kID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBiaW5kaW5ncyA9IHt9O1xuXG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShfdGhpcy5jbGFzc2VzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspIHtcbiAgICAgIHZhciBSZWNvZ25pemVyQ2xhc3MgPSBfc3RlcC52YWx1ZTtcbiAgICAgIG5ldyBSZWNvZ25pemVyQ2xhc3MoX3RoaXMsIGFyZ3MpLmFkZEJpbmRpbmdzKGJpbmRpbmdzKTtcbiAgICB9IC8vIHdlIGFsc28gYWRkIGV2ZW50IGJpbmRpbmdzIGZvciBuYXRpdmUgaGFuZGxlcnNcblxuXG4gICAgZm9yICh2YXIgX2kgPSAwLCBfT2JqZWN0JGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhfdGhpcy5uYXRpdmVSZWZzKTsgX2kgPCBfT2JqZWN0JGVudHJpZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX09iamVjdCRlbnRyaWVzJF9pID0gX09iamVjdCRlbnRyaWVzW19pXSxcbiAgICAgICAgICBldmVudCA9IF9PYmplY3QkZW50cmllcyRfaVswXSxcbiAgICAgICAgICBoYW5kbGVyID0gX09iamVjdCRlbnRyaWVzJF9pWzFdO1xuICAgICAgYWRkQmluZGluZ3MoYmluZGluZ3MsIGV2ZW50LCBwYXJ0aWFsKGhhbmRsZXIsIF9leHRlbmRzKHt9LCBfdGhpcy5zdGF0ZS5zaGFyZWQsIHtcbiAgICAgICAgYXJnczogYXJnc1xuICAgICAgfSkpKTtcbiAgICB9XG5cbiAgICBpZiAoX3RoaXMuY29uZmlnLmRvbVRhcmdldCkge1xuICAgICAgLy8gSWYgY29uZmlnLmRvbVRhcmdldCBpcyBzZXQgd2UgYWRkIGV2ZW50IGxpc3RlbmVycyB0byBpdCBhbmQgcmV0dXJuIHRoZSBjbGVhbiBmdW5jdGlvbi5cbiAgICAgIHJldHVybiB1cGRhdGVEb21MaXN0ZW5lcnMoX3RoaXMsIGJpbmRpbmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgbm90LCB3ZSByZXR1cm4gYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgZ2VzdHVyZSBoYW5kbGVycyBtYXBwZWQgdG8gcmVhY3QgaGFuZGxlciBldmVudCBrZXlzLlxuICAgICAgcmV0dXJuIGdldFByb3BzTGlzdGVuZXIoX3RoaXMsIGJpbmRpbmdzKTtcbiAgICB9XG4gIH07XG5cbiAgdGhpcy5lZmZlY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKF90aGlzLmNvbmZpZy5kb21UYXJnZXQpIF90aGlzLmJpbmQoKTtcbiAgICByZXR1cm4gX3RoaXMuY2xlYW47XG4gIH07XG4gIC8qKlxyXG4gICAqIEZ1bmN0aW9uIHJhbiBvbiBjb21wb25lbnQgdW5tb3VudDogY2xlYW5zIHRpbWVvdXRzIGFuZCByZW1vdmVzIGRvbSBsaXN0ZW5lcnMgc2V0IGJ5IHRoZSBiaW5kIGZ1bmN0aW9uLlxyXG4gICAqL1xuXG5cbiAgdGhpcy5jbGVhbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZG9tVGFyZ2V0ID0gZ2V0RG9tVGFyZ2V0RnJvbUNvbmZpZyhfdGhpcy5jb25maWcpO1xuICAgIHZhciBldmVudE9wdGlvbnMgPSBfdGhpcy5jb25maWcuZXZlbnRPcHRpb25zO1xuICAgIGlmIChkb21UYXJnZXQpIHJlbW92ZUxpc3RlbmVycyhkb21UYXJnZXQsIHRha2VBbGwoX3RoaXMuZG9tTGlzdGVuZXJzKSwgZXZlbnRPcHRpb25zKTtcbiAgICBPYmplY3QudmFsdWVzKF90aGlzLnRpbWVvdXRzKS5mb3JFYWNoKGNsZWFyVGltZW91dCk7XG4gICAgY2xlYXJBbGxXaW5kb3dMaXN0ZW5lcnMoX3RoaXMpO1xuICB9O1xuXG4gIHRoaXMuc3RhdGUgPSBnZXRJbml0aWFsU3RhdGUoKTtcbiAgdGhpcy50aW1lb3V0cyA9IHt9O1xuICB0aGlzLmRvbUxpc3RlbmVycyA9IFtdO1xuICB0aGlzLndpbmRvd0xpc3RlbmVycyA9IHt9O1xufTtcbmZ1bmN0aW9uIGNsZWFyQWxsV2luZG93TGlzdGVuZXJzKGNvbnRyb2xsZXIpIHtcbiAgdmFyIF9jb250cm9sbGVyJGNvbmZpZyA9IGNvbnRyb2xsZXIuY29uZmlnLFxuICAgICAgZWwgPSBfY29udHJvbGxlciRjb25maWcud2luZG93LFxuICAgICAgZXZlbnRPcHRpb25zID0gX2NvbnRyb2xsZXIkY29uZmlnLmV2ZW50T3B0aW9ucyxcbiAgICAgIHdpbmRvd0xpc3RlbmVycyA9IGNvbnRyb2xsZXIud2luZG93TGlzdGVuZXJzO1xuICBpZiAoIWVsKSByZXR1cm47XG5cbiAgZm9yICh2YXIgc3RhdGVLZXkgaW4gd2luZG93TGlzdGVuZXJzKSB7XG4gICAgdmFyIGhhbmRsZXJzID0gd2luZG93TGlzdGVuZXJzW3N0YXRlS2V5XTtcbiAgICByZW1vdmVMaXN0ZW5lcnMoZWwsIGhhbmRsZXJzLCBldmVudE9wdGlvbnMpO1xuICB9XG5cbiAgY29udHJvbGxlci53aW5kb3dMaXN0ZW5lcnMgPSB7fTtcbn1cbmZ1bmN0aW9uIGNsZWFyV2luZG93TGlzdGVuZXJzKF9yZWYsIHN0YXRlS2V5KSB7XG4gIHZhciBjb25maWcgPSBfcmVmLmNvbmZpZyxcbiAgICAgIHdpbmRvd0xpc3RlbmVycyA9IF9yZWYud2luZG93TGlzdGVuZXJzO1xuICBpZiAoIWNvbmZpZy53aW5kb3cpIHJldHVybjtcbiAgcmVtb3ZlTGlzdGVuZXJzKGNvbmZpZy53aW5kb3csIHdpbmRvd0xpc3RlbmVyc1tzdGF0ZUtleV0sIGNvbmZpZy5ldmVudE9wdGlvbnMpO1xuICBkZWxldGUgd2luZG93TGlzdGVuZXJzW3N0YXRlS2V5XTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVdpbmRvd0xpc3RlbmVycyhfcmVmMiwgc3RhdGVLZXksIGxpc3RlbmVycykge1xuICB2YXIgY29uZmlnID0gX3JlZjIuY29uZmlnLFxuICAgICAgd2luZG93TGlzdGVuZXJzID0gX3JlZjIud2luZG93TGlzdGVuZXJzO1xuXG4gIGlmIChsaXN0ZW5lcnMgPT09IHZvaWQgMCkge1xuICAgIGxpc3RlbmVycyA9IFtdO1xuICB9XG5cbiAgaWYgKCFjb25maWcud2luZG93KSByZXR1cm47XG4gIHJlbW92ZUxpc3RlbmVycyhjb25maWcud2luZG93LCB3aW5kb3dMaXN0ZW5lcnNbc3RhdGVLZXldLCBjb25maWcuZXZlbnRPcHRpb25zKTtcbiAgYWRkTGlzdGVuZXJzKGNvbmZpZy53aW5kb3csIHdpbmRvd0xpc3RlbmVyc1tzdGF0ZUtleV0gPSBsaXN0ZW5lcnMsIGNvbmZpZy5ldmVudE9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVEb21MaXN0ZW5lcnMoX3JlZjMsIGJpbmRpbmdzKSB7XG4gIHZhciBjb25maWcgPSBfcmVmMy5jb25maWcsXG4gICAgICBkb21MaXN0ZW5lcnMgPSBfcmVmMy5kb21MaXN0ZW5lcnM7XG4gIHZhciBkb21UYXJnZXQgPSBnZXREb21UYXJnZXRGcm9tQ29uZmlnKGNvbmZpZyk7XG4gIGlmICghZG9tVGFyZ2V0KSB0aHJvdyBuZXcgRXJyb3IoJ2RvbVRhcmdldCBtdXN0IGJlIGRlZmluZWQnKTtcbiAgdmFyIGV2ZW50T3B0aW9ucyA9IGNvbmZpZy5ldmVudE9wdGlvbnM7XG4gIHJlbW92ZUxpc3RlbmVycyhkb21UYXJnZXQsIHRha2VBbGwoZG9tTGlzdGVuZXJzKSwgZXZlbnRPcHRpb25zKTtcblxuICBmb3IgKHZhciBfaTIgPSAwLCBfT2JqZWN0JGVudHJpZXMyID0gT2JqZWN0LmVudHJpZXMoYmluZGluZ3MpOyBfaTIgPCBfT2JqZWN0JGVudHJpZXMyLmxlbmd0aDsgX2kyKyspIHtcbiAgICB2YXIgX09iamVjdCRlbnRyaWVzMiRfaSA9IF9PYmplY3QkZW50cmllczJbX2kyXSxcbiAgICAgICAga2V5ID0gX09iamVjdCRlbnRyaWVzMiRfaVswXSxcbiAgICAgICAgZm5zID0gX09iamVjdCRlbnRyaWVzMiRfaVsxXTtcbiAgICB2YXIgbmFtZSA9IGtleS5zbGljZSgyKS50b0xvd2VyQ2FzZSgpO1xuICAgIGRvbUxpc3RlbmVycy5wdXNoKFtuYW1lLCBjaGFpbkZucy5hcHBseSh2b2lkIDAsIGZucyldKTtcbiAgfVxuXG4gIGFkZExpc3RlbmVycyhkb21UYXJnZXQsIGRvbUxpc3RlbmVycywgZXZlbnRPcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gZ2V0UHJvcHNMaXN0ZW5lcihfcmVmNCwgYmluZGluZ3MpIHtcbiAgdmFyIGNvbmZpZyA9IF9yZWY0LmNvbmZpZztcbiAgdmFyIHByb3BzID0ge307XG4gIHZhciBjYXB0dXJlU3RyaW5nID0gY29uZmlnLmV2ZW50T3B0aW9ucy5jYXB0dXJlID8gJ0NhcHR1cmUnIDogJyc7XG5cbiAgZm9yICh2YXIgX2kzID0gMCwgX09iamVjdCRlbnRyaWVzMyA9IE9iamVjdC5lbnRyaWVzKGJpbmRpbmdzKTsgX2kzIDwgX09iamVjdCRlbnRyaWVzMy5sZW5ndGg7IF9pMysrKSB7XG4gICAgdmFyIF9PYmplY3QkZW50cmllczMkX2kgPSBfT2JqZWN0JGVudHJpZXMzW19pM10sXG4gICAgICAgIGV2ZW50ID0gX09iamVjdCRlbnRyaWVzMyRfaVswXSxcbiAgICAgICAgZm5zID0gX09iamVjdCRlbnRyaWVzMyRfaVsxXTtcbiAgICB2YXIgZm5zQXJyYXkgPSBBcnJheS5pc0FycmF5KGZucykgPyBmbnMgOiBbZm5zXTtcbiAgICB2YXIga2V5ID0gZXZlbnQgKyBjYXB0dXJlU3RyaW5nO1xuICAgIHByb3BzW2tleV0gPSBjaGFpbkZucy5hcHBseSh2b2lkIDAsIGZuc0FycmF5KTtcbiAgfVxuXG4gIHJldHVybiBwcm9wcztcbn1cblxuZnVuY3Rpb24gdGFrZUFsbChhcnJheSkge1xuICBpZiAoYXJyYXkgPT09IHZvaWQgMCkge1xuICAgIGFycmF5ID0gW107XG4gIH1cblxuICByZXR1cm4gYXJyYXkuc3BsaWNlKDAsIGFycmF5Lmxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIGdldERvbVRhcmdldEZyb21Db25maWcoX3JlZjUpIHtcbiAgdmFyIGRvbVRhcmdldCA9IF9yZWY1LmRvbVRhcmdldDtcbiAgcmV0dXJuIGRvbVRhcmdldCAmJiAnY3VycmVudCcgaW4gZG9tVGFyZ2V0ID8gZG9tVGFyZ2V0LmN1cnJlbnQgOiBkb21UYXJnZXQ7XG59XG4vKipcclxuICogYmluZGluZ3MgaXMgYW4gb2JqZWN0IHdoaWNoIGtleXMgbWF0Y2ggUmVhY3RFdmVudEhhbmRsZXJLZXlzLlxyXG4gKiBTaW5jZSBhIHJlY29nbml6ZXIgbWlnaHQgd2FudCB0byBiaW5kIGEgaGFuZGxlciBmdW5jdGlvbiB0byBhbiBldmVudCBrZXkgYWxyZWFkeSB1c2VkIGJ5IGEgcHJldmlvdXNseVxyXG4gKiBhZGRlZCByZWNvZ25pemVyLCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGVhY2ggZXZlbnQga2V5IGlzIGFuIGFycmF5IG9mIGFsbCB0aGUgZnVuY3Rpb25zIG1hcHBlZCBmb3JcclxuICogdGhhdCBrZXkuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGFkZEJpbmRpbmdzKGJpbmRpbmdzLCBuYW1lLCBmbikge1xuICBpZiAoIWJpbmRpbmdzW25hbWVdKSBiaW5kaW5nc1tuYW1lXSA9IFtdO1xuICBiaW5kaW5nc1tuYW1lXS5wdXNoKGZuKTtcbn1cblxuZnVuY3Rpb24gYWRkTGlzdGVuZXJzKGVsLCBsaXN0ZW5lcnMsIG9wdGlvbnMpIHtcbiAgaWYgKGxpc3RlbmVycyA9PT0gdm9pZCAwKSB7XG4gICAgbGlzdGVuZXJzID0gW107XG4gIH1cblxuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UobGlzdGVuZXJzKSwgX3N0ZXAyOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIoKSkuZG9uZTspIHtcbiAgICB2YXIgX3N0ZXAyJHZhbHVlID0gX3N0ZXAyLnZhbHVlLFxuICAgICAgICBldmVudE5hbWUgPSBfc3RlcDIkdmFsdWVbMF0sXG4gICAgICAgIGV2ZW50SGFuZGxlciA9IF9zdGVwMiR2YWx1ZVsxXTtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyLCBvcHRpb25zKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVMaXN0ZW5lcnMoZWwsIGxpc3RlbmVycywgb3B0aW9ucykge1xuICBpZiAobGlzdGVuZXJzID09PSB2b2lkIDApIHtcbiAgICBsaXN0ZW5lcnMgPSBbXTtcbiAgfVxuXG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBmb3IgKHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShsaXN0ZW5lcnMpLCBfc3RlcDM7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMygpKS5kb25lOykge1xuICAgIHZhciBfc3RlcDMkdmFsdWUgPSBfc3RlcDMudmFsdWUsXG4gICAgICAgIGV2ZW50TmFtZSA9IF9zdGVwMyR2YWx1ZVswXSxcbiAgICAgICAgZXZlbnRIYW5kbGVyID0gX3N0ZXAzJHZhbHVlWzFdO1xuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBldmVudEhhbmRsZXIsIG9wdGlvbnMpO1xuICB9XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwcyAqL1xuLyoqXHJcbiAqIFV0aWxpdHkgaG9vayBjYWxsZWQgYnkgYWxsIGdlc3R1cmUgaG9va3MgYW5kIHRoYXQgd2lsbCBiZSByZXNwb25zaWJsZSBmb3IgdGhlIGludGVybmFscy5cclxuICpcclxuICogQHBhcmFtIGhhbmRsZXJzXHJcbiAqIEBwYXJhbSBjbGFzc2VzXHJcbiAqIEBwYXJhbSBjb25maWdcclxuICogQHBhcmFtIG5hdGl2ZUhhbmRsZXJzIC0gbmF0aXZlIGhhbmRsZXJzIHN1Y2ggYXMgb25DbGljaywgb25Nb3VzZURvd24sIGV0Yy5cclxuICovXG5cbmZ1bmN0aW9uIHVzZVJlY29nbml6ZXJzKGhhbmRsZXJzLCBjb25maWcsIG5hdGl2ZUhhbmRsZXJzKSB7XG4gIGlmIChuYXRpdmVIYW5kbGVycyA9PT0gdm9pZCAwKSB7XG4gICAgbmF0aXZlSGFuZGxlcnMgPSB7fTtcbiAgfVxuXG4gIHZhciBjbGFzc2VzID0gcmVzb2x2ZUNsYXNzZXMoaGFuZGxlcnMpO1xuICB2YXIgY29udHJvbGxlciA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgQ29udHJvbGxlcihjbGFzc2VzKTtcbiAgfSwgW10pO1xuICBjb250cm9sbGVyLmNvbmZpZyA9IGNvbmZpZztcbiAgY29udHJvbGxlci5oYW5kbGVycyA9IGhhbmRsZXJzO1xuICBjb250cm9sbGVyLm5hdGl2ZVJlZnMgPSBuYXRpdmVIYW5kbGVycztcbiAgUmVhY3QudXNlRWZmZWN0KGNvbnRyb2xsZXIuZWZmZWN0LCBbXSk7IC8vIEB0cy1pZ25vcmVcblxuICBpZiAoY29udHJvbGxlci5jb25maWcuZG9tVGFyZ2V0KSByZXR1cm4gZGVwcmVjYXRpb25Ob3RpY2VGb3JEb21UYXJnZXQ7IC8vIEB0cy1pZ25vcmVcblxuICByZXR1cm4gY29udHJvbGxlci5iaW5kO1xufVxuXG5mdW5jdGlvbiBkZXByZWNhdGlvbk5vdGljZUZvckRvbVRhcmdldCgpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgY29uc29sZS53YXJuKFwiRGVwcmVjYXRpb24gbm90aWNlOiBXaGVuIHRoZSBgZG9tVGFyZ2V0YCBvcHRpb24gaXMgc3BlY2lmaWVkLCB5b3UgZG9uJ3QgbmVlZCB0byB3cml0ZSBgdXNlRWZmZWN0KGJpbmQsIFtiaW5kXSlgIGFueW1vcmU6IGV2ZW50IGJpbmRpbmcgaXMgbm93IG1hZGUgaGFuZGxlZCBpbnRlcm5hbGx5IHRvIHRoaXMgbGliLlxcblxcbk5leHQgdmVyc2lvbiB3b24ndCByZXR1cm4gYW55dGhpbmcgd2hlbiBgZG9tVGFyZ2V0YCBpcyBwcm92aWRlZCwgdGhlcmVmb3JlIHlvdXIgY29kZSB3aWxsIGJyZWFrIGlmIHlvdSB0cnkgdG8gY2FsbCBgdXNlRWZmZWN0YC5cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUNsYXNzZXMoaW50ZXJuYWxIYW5kbGVycykge1xuICB2YXIgY2xhc3NlcyA9IG5ldyBTZXQoKTtcbiAgaWYgKGludGVybmFsSGFuZGxlcnMuZHJhZykgY2xhc3Nlcy5hZGQoUmVjb2duaXplcnNNYXAuZ2V0KCdkcmFnJykpO1xuICBpZiAoaW50ZXJuYWxIYW5kbGVycy53aGVlbCkgY2xhc3Nlcy5hZGQoUmVjb2duaXplcnNNYXAuZ2V0KCd3aGVlbCcpKTtcbiAgaWYgKGludGVybmFsSGFuZGxlcnMuc2Nyb2xsKSBjbGFzc2VzLmFkZChSZWNvZ25pemVyc01hcC5nZXQoJ3Njcm9sbCcpKTtcbiAgaWYgKGludGVybmFsSGFuZGxlcnMubW92ZSkgY2xhc3Nlcy5hZGQoUmVjb2duaXplcnNNYXAuZ2V0KCdtb3ZlJykpO1xuICBpZiAoaW50ZXJuYWxIYW5kbGVycy5waW5jaCkgY2xhc3Nlcy5hZGQoUmVjb2duaXplcnNNYXAuZ2V0KCdwaW5jaCcpKTtcbiAgaWYgKGludGVybmFsSGFuZGxlcnMuaG92ZXIpIGNsYXNzZXMuYWRkKFJlY29nbml6ZXJzTWFwLmdldCgnaG92ZXInKSk7XG4gIHJldHVybiBjbGFzc2VzO1xufVxuXG4vKipcclxuICogQHByaXZhdGVcclxuICogQWJzdHJhY3QgY2xhc3MgZm9yIGNvb3JkaW5hdGVzLWJhc2VkIGdlc3R1cmUgcmVjb25naXplcnNcclxuICovXG5cbnZhciBDb29yZGluYXRlc1JlY29nbml6ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWNvZ25pemVyKSB7XG4gIF9pbmhlcml0c0xvb3NlKENvb3JkaW5hdGVzUmVjb2duaXplciwgX1JlY29nbml6ZXIpO1xuXG4gIGZ1bmN0aW9uIENvb3JkaW5hdGVzUmVjb2duaXplcigpIHtcbiAgICByZXR1cm4gX1JlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IENvb3JkaW5hdGVzUmVjb2duaXplci5wcm90b3R5cGU7XG5cbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgcmVhbCBtb3ZlbWVudCAod2l0aG91dCB0YWtpbmcgaW50ZW50aW9uYWxpdHkgaW50byBhY291bnQpXHJcbiAgICovXG4gIF9wcm90by5nZXRJbnRlcm5hbE1vdmVtZW50ID0gZnVuY3Rpb24gZ2V0SW50ZXJuYWxNb3ZlbWVudCh2YWx1ZXMsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHN1YlYodmFsdWVzLCBzdGF0ZS5pbml0aWFsKTtcbiAgfVxuICAvKipcclxuICAgKiBJbiBjb29yZGluYXRlcy1iYXNlZCBnZXN0dXJlLCB0aGlzIGZ1bmN0aW9uIHdpbGwgZGV0ZWN0IHRoZSBmaXJzdCBpbnRlbnRpb25hbCBheGlzLFxyXG4gICAqIGxvY2sgdGhlIGdlc3R1cmUgYXhpcyBpZiBsb2NrRGlyZWN0aW9uIGlzIHNwZWNpZmllZCBpbiB0aGUgY29uZmlnLCBibG9jayB0aGUgZ2VzdHVyZVxyXG4gICAqIGlmIHRoZSBmaXJzdCBpbnRlbnRpb25hbCBheGlzIGRvZXNuJ3QgbWF0Y2ggdGhlIHNwZWNpZmllZCBheGlzIGluIGNvbmZpZy5cclxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5jaGVja0ludGVudGlvbmFsaXR5ID0gZnVuY3Rpb24gY2hlY2tJbnRlbnRpb25hbGl0eShfaW50ZW50aW9uYWwsIF9tb3ZlbWVudCkge1xuICAgIGlmIChfaW50ZW50aW9uYWxbMF0gPT09IGZhbHNlICYmIF9pbnRlbnRpb25hbFsxXSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIF9pbnRlbnRpb25hbDogX2ludGVudGlvbmFsLFxuICAgICAgICBheGlzOiB0aGlzLnN0YXRlLmF4aXNcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIF9tb3ZlbWVudCRtYXAgPSBfbW92ZW1lbnQubWFwKE1hdGguYWJzKSxcbiAgICAgICAgYWJzWCA9IF9tb3ZlbWVudCRtYXBbMF0sXG4gICAgICAgIGFic1kgPSBfbW92ZW1lbnQkbWFwWzFdO1xuXG4gICAgdmFyIGF4aXMgPSB0aGlzLnN0YXRlLmF4aXMgfHwgKGFic1ggPiBhYnNZID8gJ3gnIDogYWJzWCA8IGFic1kgPyAneScgOiB1bmRlZmluZWQpO1xuICAgIGlmICghdGhpcy5jb25maWcuYXhpcyAmJiAhdGhpcy5jb25maWcubG9ja0RpcmVjdGlvbikgcmV0dXJuIHtcbiAgICAgIF9pbnRlbnRpb25hbDogX2ludGVudGlvbmFsLFxuICAgICAgX2Jsb2NrZWQ6IGZhbHNlLFxuICAgICAgYXhpczogYXhpc1xuICAgIH07XG4gICAgaWYgKCFheGlzKSByZXR1cm4ge1xuICAgICAgX2ludGVudGlvbmFsOiBbZmFsc2UsIGZhbHNlXSxcbiAgICAgIF9ibG9ja2VkOiBmYWxzZSxcbiAgICAgIGF4aXM6IGF4aXNcbiAgICB9O1xuICAgIGlmICghIXRoaXMuY29uZmlnLmF4aXMgJiYgYXhpcyAhPT0gdGhpcy5jb25maWcuYXhpcykgcmV0dXJuIHtcbiAgICAgIF9pbnRlbnRpb25hbDogX2ludGVudGlvbmFsLFxuICAgICAgX2Jsb2NrZWQ6IHRydWUsXG4gICAgICBheGlzOiBheGlzXG4gICAgfTtcbiAgICBfaW50ZW50aW9uYWxbYXhpcyA9PT0gJ3gnID8gMSA6IDBdID0gZmFsc2U7XG4gICAgcmV0dXJuIHtcbiAgICAgIF9pbnRlbnRpb25hbDogX2ludGVudGlvbmFsLFxuICAgICAgX2Jsb2NrZWQ6IGZhbHNlLFxuICAgICAgYXhpczogYXhpc1xuICAgIH07XG4gIH07XG5cbiAgX3Byb3RvLmdldEtpbmVtYXRpY3MgPSBmdW5jdGlvbiBnZXRLaW5lbWF0aWNzKHZhbHVlcywgZXZlbnQpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLmdldE1vdmVtZW50KHZhbHVlcyk7XG5cbiAgICBpZiAoIXN0YXRlLl9ibG9ja2VkKSB7XG4gICAgICB2YXIgZHQgPSBldmVudC50aW1lU3RhbXAgLSB0aGlzLnN0YXRlLnRpbWVTdGFtcDtcbiAgICAgIE9iamVjdC5hc3NpZ24oc3RhdGUsIGNhbGN1bGF0ZUFsbEtpbmVtYXRpY3Moc3RhdGUubW92ZW1lbnQsIHN0YXRlLmRlbHRhLCBkdCkpO1xuICAgIH1cblxuICAgIHJldHVybiBzdGF0ZTtcbiAgfTtcblxuICBfcHJvdG8ubWFwU3RhdGVWYWx1ZXMgPSBmdW5jdGlvbiBtYXBTdGF0ZVZhbHVlcyhzdGF0ZSkge1xuICAgIHJldHVybiB7XG4gICAgICB4eTogc3RhdGUudmFsdWVzLFxuICAgICAgdnh2eTogc3RhdGUudmVsb2NpdGllc1xuICAgIH07XG4gIH07XG5cbiAgcmV0dXJuIENvb3JkaW5hdGVzUmVjb2duaXplcjtcbn0oUmVjb2duaXplcik7XG5cbnZhciBXRUJLSVRfRElTVEFOQ0VfU0NBTEVfRkFDVE9SID0gMjYwO1xuLyoqXHJcbiAqIFdoZXRoZXIgdGhlIGJyb3dzZXIgc3VwcG9ydHMgR2VzdHVyZUV2ZW50IChpZSBTYWZhcmkpXHJcbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgZ2VzdHVyZSBldmVudFxyXG4gKi9cblxuZnVuY3Rpb24gc3VwcG9ydHNHZXN0dXJlRXZlbnRzKCkge1xuICB0cnkge1xuICAgIC8vIFRPRE8gW1RTXSBwb3NzaWJseSBmaW5kIEdlc3R1cmVFdmVudCBkZWZpbml0aW9ucz9cbiAgICAvLyBAdHMtaWdub3JlOiBubyB0eXBlIGRlZmluaXRpb25zIGZvciB3ZWJraXQgR2VzdHVyZUV2ZW50c1xuICAgIHJldHVybiAnY29uc3RydWN0b3InIGluIEdlc3R1cmVFdmVudDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gc3VwcG9ydHNUb3VjaEV2ZW50cygpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5vbnRvdWNoc3RhcnQgPT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldFRvdWNoRXZlbnRzKGV2ZW50KSB7XG4gIGlmICgndG91Y2hlcycgaW4gZXZlbnQpIHtcbiAgICB2YXIgdGFyZ2V0VG91Y2hlcyA9IGV2ZW50LnRhcmdldFRvdWNoZXMsXG4gICAgICAgIGNoYW5nZWRUb3VjaGVzID0gZXZlbnQuY2hhbmdlZFRvdWNoZXM7XG4gICAgcmV0dXJuIHRhcmdldFRvdWNoZXMubGVuZ3RoID4gMCA/IHRhcmdldFRvdWNoZXMgOiBjaGFuZ2VkVG91Y2hlcztcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRHZW5lcmljRXZlbnREYXRhKGV2ZW50KSB7XG4gIHZhciBidXR0b25zID0gJ2J1dHRvbnMnIGluIGV2ZW50ID8gZXZlbnQuYnV0dG9ucyA6IDA7XG4gIHZhciB0b3VjaEV2ZW50cyA9IGdldFRvdWNoRXZlbnRzKGV2ZW50KTtcbiAgdmFyIHRvdWNoZXMgPSB0b3VjaEV2ZW50cyAmJiB0b3VjaEV2ZW50cy5sZW5ndGggfHwgMDtcbiAgdmFyIGRvd24gPSB0b3VjaGVzID4gMCB8fCBidXR0b25zID4gMDtcbiAgdmFyIHNoaWZ0S2V5ID0gZXZlbnQuc2hpZnRLZXksXG4gICAgICBhbHRLZXkgPSBldmVudC5hbHRLZXksXG4gICAgICBtZXRhS2V5ID0gZXZlbnQubWV0YUtleSxcbiAgICAgIGN0cmxLZXkgPSBldmVudC5jdHJsS2V5OyAvLyBUT0RPIGNoZWNrIGlmIHRoaXMgbWlnaHQgY3JlYXRlIHNvbWUgb3ZlcnJpZGVzP1xuXG4gIHJldHVybiB7XG4gICAgdG91Y2hlczogdG91Y2hlcyxcbiAgICBkb3duOiBkb3duLFxuICAgIGJ1dHRvbnM6IGJ1dHRvbnMsXG4gICAgc2hpZnRLZXk6IHNoaWZ0S2V5LFxuICAgIGFsdEtleTogYWx0S2V5LFxuICAgIG1ldGFLZXk6IG1ldGFLZXksXG4gICAgY3RybEtleTogY3RybEtleVxuICB9O1xufVxuLyoqXHJcbiAqIEdldHMgcG9pbnRlciBldmVudCB2YWx1ZXMuXHJcbiAqIEBwYXJhbSBldmVudFxyXG4gKiBAcmV0dXJucyBwb2ludGVyIGV2ZW50IHZhbHVlc1xyXG4gKi9cblxuZnVuY3Rpb24gZ2V0UG9pbnRlckV2ZW50VmFsdWVzKGV2ZW50KSB7XG4gIHZhciB0b3VjaEV2ZW50cyA9IGdldFRvdWNoRXZlbnRzKGV2ZW50KTtcblxuICB2YXIgX3JlZiA9IHRvdWNoRXZlbnRzID8gdG91Y2hFdmVudHNbMF0gOiBldmVudCxcbiAgICAgIGNsaWVudFggPSBfcmVmLmNsaWVudFgsXG4gICAgICBjbGllbnRZID0gX3JlZi5jbGllbnRZO1xuXG4gIHJldHVybiBbY2xpZW50WCwgY2xpZW50WV07XG59XG4vKipcclxuICogR2V0cyBzY3JvbGwgZXZlbnQgdmFsdWVzXHJcbiAqIEBwYXJhbSBldmVudFxyXG4gKiBAcmV0dXJucyBzY3JvbGwgZXZlbnQgdmFsdWVzXHJcbiAqL1xuXG5mdW5jdGlvbiBnZXRTY3JvbGxFdmVudFZhbHVlcyhldmVudCkge1xuICAvLyBJZiB0aGUgY3VycmVudFRhcmdldCBpcyB0aGUgd2luZG93IHRoZW4gd2UgcmV0dXJuIHRoZSBzY3JvbGxYL1kgcG9zaXRpb24uXG4gIC8vIElmIG5vdCAoaWUgdGhlIGN1cnJlbnRUYXJnZXQgaXMgYSBET00gZWxlbWVudCksIHRoZW4gd2UgcmV0dXJuIHNjcm9sbExlZnQvVG9wXG4gIHZhciBfZXZlbnQkY3VycmVudFRhcmdldCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQsXG4gICAgICBzY3JvbGxYID0gX2V2ZW50JGN1cnJlbnRUYXJnZXQuc2Nyb2xsWCxcbiAgICAgIHNjcm9sbFkgPSBfZXZlbnQkY3VycmVudFRhcmdldC5zY3JvbGxZLFxuICAgICAgc2Nyb2xsTGVmdCA9IF9ldmVudCRjdXJyZW50VGFyZ2V0LnNjcm9sbExlZnQsXG4gICAgICBzY3JvbGxUb3AgPSBfZXZlbnQkY3VycmVudFRhcmdldC5zY3JvbGxUb3A7XG4gIHJldHVybiBbc2Nyb2xsWCB8fCBzY3JvbGxMZWZ0IHx8IDAsIHNjcm9sbFkgfHwgc2Nyb2xsVG9wIHx8IDBdO1xufVxuLyoqXHJcbiAqIEdldHMgd2hlZWwgZXZlbnQgdmFsdWVzLlxyXG4gKiBAcGFyYW0gZXZlbnRcclxuICogQHJldHVybnMgd2hlZWwgZXZlbnQgdmFsdWVzXHJcbiAqL1xuXG5mdW5jdGlvbiBnZXRXaGVlbEV2ZW50VmFsdWVzKGV2ZW50KSB7XG4gIHZhciBkZWx0YVggPSBldmVudC5kZWx0YVgsXG4gICAgICBkZWx0YVkgPSBldmVudC5kZWx0YVk7IC8vVE9ETyBpbXBsZW1lbnQgcG9seWZpbGwgP1xuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9FdmVudHMvd2hlZWwjUG9seWZpbGxcblxuICByZXR1cm4gW2RlbHRhWCwgZGVsdGFZXTtcbn1cbi8qKlxyXG4gKiBHZXRzIHdlYmtpdCBnZXN0dXJlIGV2ZW50IHZhbHVlcy5cclxuICogQHBhcmFtIGV2ZW50XHJcbiAqIEByZXR1cm5zIHdlYmtpdCBnZXN0dXJlIGV2ZW50IHZhbHVlc1xyXG4gKi9cblxuZnVuY3Rpb24gZ2V0V2Via2l0R2VzdHVyZUV2ZW50VmFsdWVzKGV2ZW50KSB7XG4gIHJldHVybiBbZXZlbnQuc2NhbGUgKiBXRUJLSVRfRElTVEFOQ0VfU0NBTEVfRkFDVE9SLCBldmVudC5yb3RhdGlvbl07XG59XG4vKipcclxuICogR2V0cyB0d28gdG91Y2hlcyBldmVudCBkYXRhXHJcbiAqIEBwYXJhbSBldmVudFxyXG4gKiBAcmV0dXJucyB0d28gdG91Y2hlcyBldmVudCBkYXRhXHJcbiAqL1xuXG5mdW5jdGlvbiBnZXRUd29Ub3VjaGVzRXZlbnREYXRhKGV2ZW50KSB7XG4gIHZhciBfZSRyb3RhdGlvbjtcblxuICB2YXIgdGFyZ2V0VG91Y2hlcyA9IGV2ZW50LnRhcmdldFRvdWNoZXM7XG4gIHZhciBBID0gdGFyZ2V0VG91Y2hlc1swXSxcbiAgICAgIEIgPSB0YXJnZXRUb3VjaGVzWzFdO1xuICB2YXIgZHggPSBCLmNsaWVudFggLSBBLmNsaWVudFg7XG4gIHZhciBkeSA9IEIuY2xpZW50WSAtIEEuY2xpZW50WTtcbiAgdmFyIGN4ID0gKEIuY2xpZW50WCArIEEuY2xpZW50WCkgLyAyO1xuICB2YXIgY3kgPSAoQi5jbGllbnRZICsgQS5jbGllbnRZKSAvIDI7XG4gIHZhciBlID0gJ25hdGl2ZUV2ZW50JyBpbiBldmVudCA/IGV2ZW50Lm5hdGl2ZUV2ZW50IDogZXZlbnQ7XG4gIHZhciBkaXN0YW5jZSA9IE1hdGguaHlwb3QoZHgsIGR5KTtcbiAgdmFyIGFuZ2xlID0gKF9lJHJvdGF0aW9uID0gZS5yb3RhdGlvbikgIT0gbnVsbCA/IF9lJHJvdGF0aW9uIDogLShNYXRoLmF0YW4yKGR4LCBkeSkgKiAxODApIC8gTWF0aC5QSTtcbiAgdmFyIHZhbHVlcyA9IFtkaXN0YW5jZSwgYW5nbGVdO1xuICB2YXIgb3JpZ2luID0gW2N4LCBjeV07XG4gIHJldHVybiB7XG4gICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgb3JpZ2luOiBvcmlnaW5cbiAgfTtcbn1cblxudmFyIFRBUF9ESVNUQU5DRV9USFJFU0hPTEQgPSAzO1xudmFyIFNXSVBFX01BWF9FTEFQU0VEX1RJTUUgPSAyMjA7XG52YXIgRHJhZ1JlY29nbml6ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Db29yZGluYXRlc1JlY29nbml6ZSkge1xuICBfaW5oZXJpdHNMb29zZShEcmFnUmVjb2duaXplciwgX0Nvb3JkaW5hdGVzUmVjb2duaXplKTtcblxuICBmdW5jdGlvbiBEcmFnUmVjb2duaXplcigpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9Db29yZGluYXRlc1JlY29nbml6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMuaW5nS2V5ID0gJ2RyYWdnaW5nJztcbiAgICBfdGhpcy5zdGF0ZUtleSA9ICdkcmFnJztcbiAgICAvKipcclxuICAgICAqIFRPRE8gYWRkIGJhY2sgd2hlbiBzZXRQb2ludGVyQ2FwdHVyZSBpcyB3aWRlbHkgd3VwcG9ydGVkXHJcbiAgICAgKiBodHRwczovL2Nhbml1c2UuY29tLyNzZWFyY2g9c2V0UG9pbnRlckNhcHR1cmVcclxuICAgICAqIHByaXZhdGUgc2V0UG9pbnRlcnMgPSAoZXZlbnQ6IFVzZUdlc3R1cmVFdmVudDxQb2ludGVyRXZlbnQ+KSA9PiB7XHJcbiAgICAgKiAgIGNvbnN0IHsgY3VycmVudFRhcmdldCwgcG9pbnRlcklkIH0gPSBldmVudFxyXG4gICAgICogICBpZiAoY3VycmVudFRhcmdldCkgY3VycmVudFRhcmdldC5zZXRQb2ludGVyQ2FwdHVyZShwb2ludGVySWQpXHJcbiAgICAgKiAgIHRoaXMudXBkYXRlR2VzdHVyZVN0YXRlKHsgY3VycmVudFRhcmdldCwgcG9pbnRlcklkIH0pXHJcbiAgICAgKiB9XHJcbiAgICAgICAgICAgICogcHJpdmF0ZSByZW1vdmVQb2ludGVycyA9ICgpID0+IHtcclxuICAgICAqICAgY29uc3QgeyBjdXJyZW50VGFyZ2V0LCBwb2ludGVySWQgfSA9IHRoaXMuc3RhdGVcclxuICAgICAqICAgaWYgKGN1cnJlbnRUYXJnZXQgJiYgcG9pbnRlcklkKSBjdXJyZW50VGFyZ2V0LnJlbGVhc2VQb2ludGVyQ2FwdHVyZShwb2ludGVySWQpXHJcbiAgICAgKiB9XHJcbiAgICAgKi9cblxuICAgIF90aGlzLm9uRHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoIV90aGlzLmVuYWJsZWQgfHwgX3RoaXMuc3RhdGUuX2FjdGl2ZSkgcmV0dXJuO1xuICAgICAgLyoqXHJcbiAgICAgICAqIFRPRE8gYWRkIGJhY2sgd2hlbiBzZXRQb2ludGVyQ2FwdHVyZSBpcyB3aWRlbHkgc3VwcG9ydGVkXHJcbiAgICAgICAqIHRoaXMuc2V0UG9pbnRlcnMoZXZlbnQgYXMgUG9pbnRlckV2ZW50KVxyXG4gICAgICAgKi9cblxuICAgICAgdXBkYXRlV2luZG93TGlzdGVuZXJzKF90aGlzLmNvbnRyb2xsZXIsIF90aGlzLnN0YXRlS2V5LCBbWydwb2ludGVybW92ZScsIF90aGlzLm9uRHJhZ0NoYW5nZV0sIFsncG9pbnRlcnVwJywgX3RoaXMub25EcmFnRW5kXSwgWydwb2ludGVyY2FuY2VsJywgX3RoaXMub25EcmFnRW5kXV0pOyAvLyBXZSBzZXQgdGhlIHN0YXRlIHBvaW50ZXJJZCB0byB0aGUgZXZlbnQucG9pbnRlcklkIHNvIHdlIGNhbiBtYWtlIHN1cmVcbiAgICAgIC8vIHRoYXQgd2UgbG9jayB0aGUgZHJhZyB0byB0aGUgZXZlbnQgaW5pdGlhdGluZyB0aGUgZ2VzdHVyZVxuXG4gICAgICBfdGhpcy51cGRhdGVHZXN0dXJlU3RhdGUoe1xuICAgICAgICBfcG9pbnRlcklkOiBldmVudC5wb2ludGVySWRcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoX3RoaXMuY29uZmlnLmRlbGF5ID4gMCkge1xuICAgICAgICBfdGhpcy5zdGF0ZS5fZGVsYXllZEV2ZW50ID0gdHJ1ZTsgLy8gSWYgaXQncyBhIFJlYWN0IFN5bnRoZXRpY0V2ZW50IHdlIG5lZWQgdG8gcGVyc2lzdCBpdCBzbyB0aGF0IHdlIGNhbiB1c2UgaXQgYXN5bmNcblxuICAgICAgICBpZiAoJ3BlcnNpc3QnIGluIGV2ZW50ICYmIHR5cGVvZiBldmVudC5wZXJzaXN0ID09PSAnZnVuY3Rpb24nKSBldmVudC5wZXJzaXN0KCk7XG5cbiAgICAgICAgX3RoaXMuc2V0VGltZW91dChfdGhpcy5zdGFydERyYWcuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSksIF90aGlzLmNvbmZpZy5kZWxheSwgZXZlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMuc3RhcnREcmFnKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMub25EcmFnQ2hhbmdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAvLyBJZiB0aGUgZ2VzdHVyZSB3YXMgY2FuY2VsZWQgZG9uJ3QgcmVzcG9uZCB0byB0aGUgZXZlbnQuXG4gICAgICBpZiAoX3RoaXMuc3RhdGUuY2FuY2VsZWQpIHJldHVybjsgLy8gSWYgdGhlIGV2ZW50IHBvaW50ZXJJZCBkb2Vzbid0IG1hdGNoIHRoZSBpbml0aWF0aW5nIHBvaW50ZXJJZFxuICAgICAgLy8gZG9uJ3QgcmVzcG9uZCB0byB0aGUgZXZlbnQuXG5cbiAgICAgIGlmIChldmVudC5wb2ludGVySWQgIT09IF90aGlzLnN0YXRlLl9wb2ludGVySWQpIHJldHVybjsgLy8gSWYgdGhlIGdlc3R1cmUgaXNuJ3QgYWN0aXZlIHRoZW4gcmVzcG9uZCB0byB0aGUgZXZlbnQgb25seSBpZlxuICAgICAgLy8gaXQncyBiZWVuIGRlbGF5ZWQgdmlhIHRoZSBgZGVsYXlgIG9wdGlvbiwgaW4gd2hpY2ggY2FzZSBzdGFydFxuICAgICAgLy8gdGhlIGdlc3R1cmUgaW1tZWRpYXRlbHkuXG5cbiAgICAgIGlmICghX3RoaXMuc3RhdGUuX2FjdGl2ZSkge1xuICAgICAgICBpZiAoX3RoaXMuc3RhdGUuX2RlbGF5ZWRFdmVudCkge1xuICAgICAgICAgIF90aGlzLmNsZWFyVGltZW91dCgpO1xuXG4gICAgICAgICAgX3RoaXMuc3RhcnREcmFnKGV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGdlbmVyaWNFdmVudERhdGEgPSBnZXRHZW5lcmljRXZlbnREYXRhKGV2ZW50KTsgLy8gSWYgdGhlIGV2ZW50IGRvZXNuJ3QgaGF2ZSBhbnkgYnV0dG9uIC8gdG91Y2hlcyBsZWZ0IHdlIHNob3VsZCBjYW5jZWxcbiAgICAgIC8vIHRoZSBnZXN0dXJlLiBUaGlzIG1heSBoYXBwZW4gaWYgdGhlIGRyYWcgcmVsZWFzZSBoYXBwZW5zIG91dHNpZGUgdGhlIGJyb3dzZXJcbiAgICAgIC8vIHdpbmRvdy5cblxuICAgICAgaWYgKCFnZW5lcmljRXZlbnREYXRhLmRvd24pIHtcbiAgICAgICAgX3RoaXMub25EcmFnRW5kKGV2ZW50KTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIF90aGlzLnVwZGF0ZVNoYXJlZFN0YXRlKGdlbmVyaWNFdmVudERhdGEpO1xuXG4gICAgICB2YXIgdmFsdWVzID0gZ2V0UG9pbnRlckV2ZW50VmFsdWVzKGV2ZW50KTtcblxuICAgICAgdmFyIGtpbmVtYXRpY3MgPSBfdGhpcy5nZXRLaW5lbWF0aWNzKHZhbHVlcywgZXZlbnQpO1xuXG4gICAgICB2YXIgZ2VuZXJpY1BheWxvYWQgPSBnZXRHZW5lcmljUGF5bG9hZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgZXZlbnQpOyAvLyBUaGlzIHZlcmlmaWVzIGlmIHRoZSBkcmFnIGNhbiBiZSBhc3NpbWlsYXRlZCB0byBhIHRhcCBieSBjaGVja2luZ1xuICAgICAgLy8gaWYgdGhlIHJlYWwgZGlzdGFuY2Ugb2YgdGhlIGRyYWcgKGllIG5vdCBhY2NvdW50aW5nIGZvciB0aGUgdGhyZXNob2xkKSBpc1xuICAgICAgLy8gZ3JlYXRlciB0aGFuIHRoZSBUQVBfRElTVEFOQ0VfVEhSRVNIT0xELlxuXG4gICAgICB2YXIgX2lzVGFwID0gX3RoaXMuc3RhdGUuX2lzVGFwO1xuICAgICAgdmFyIHJlYWxEaXN0YW5jZSA9IGNhbGN1bGF0ZURpc3RhbmNlKGtpbmVtYXRpY3MuX21vdmVtZW50KTtcbiAgICAgIGlmIChfaXNUYXAgJiYgcmVhbERpc3RhbmNlID49IFRBUF9ESVNUQU5DRV9USFJFU0hPTEQpIF9pc1RhcCA9IGZhbHNlO1xuXG4gICAgICBfdGhpcy51cGRhdGVHZXN0dXJlU3RhdGUoX2V4dGVuZHMoe30sIGdlbmVyaWNQYXlsb2FkLCBraW5lbWF0aWNzLCB7XG4gICAgICAgIF9pc1RhcDogX2lzVGFwXG4gICAgICB9KSk7XG5cbiAgICAgIF90aGlzLmZpcmVHZXN0dXJlSGFuZGxlcigpO1xuICAgIH07XG5cbiAgICBfdGhpcy5vbkRyYWdFbmQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIC8vIElmIHRoZSBldmVudCBwb2ludGVySWQgZG9lc24ndCBtYXRjaCB0aGUgaW5pdGlhdGluZyBwb2ludGVySWRcbiAgICAgIC8vIGRvbid0IHJlc3BvbmQgdG8gdGhlIGV2ZW50LlxuICAgICAgaWYgKGV2ZW50LnBvaW50ZXJJZCAhPT0gX3RoaXMuc3RhdGUuX3BvaW50ZXJJZCkgcmV0dXJuO1xuICAgICAgX3RoaXMuc3RhdGUuX2FjdGl2ZSA9IGZhbHNlO1xuXG4gICAgICBfdGhpcy51cGRhdGVTaGFyZWRTdGF0ZSh7XG4gICAgICAgIGRvd246IGZhbHNlLFxuICAgICAgICBidXR0b25zOiAwLFxuICAgICAgICB0b3VjaGVzOiAwXG4gICAgICB9KTtcblxuICAgICAgdmFyIHRhcCA9IF90aGlzLnN0YXRlLl9pc1RhcDtcbiAgICAgIHZhciBfdGhpcyRzdGF0ZSR2ZWxvY2l0aWUgPSBfdGhpcy5zdGF0ZS52ZWxvY2l0aWVzLFxuICAgICAgICAgIHZ4ID0gX3RoaXMkc3RhdGUkdmVsb2NpdGllWzBdLFxuICAgICAgICAgIHZ5ID0gX3RoaXMkc3RhdGUkdmVsb2NpdGllWzFdO1xuICAgICAgdmFyIF90aGlzJHN0YXRlJG1vdmVtZW50ID0gX3RoaXMuc3RhdGUubW92ZW1lbnQsXG4gICAgICAgICAgbXggPSBfdGhpcyRzdGF0ZSRtb3ZlbWVudFswXSxcbiAgICAgICAgICBteSA9IF90aGlzJHN0YXRlJG1vdmVtZW50WzFdO1xuICAgICAgdmFyIF90aGlzJHN0YXRlJF9pbnRlbnRpbyA9IF90aGlzLnN0YXRlLl9pbnRlbnRpb25hbCxcbiAgICAgICAgICBpeCA9IF90aGlzJHN0YXRlJF9pbnRlbnRpb1swXSxcbiAgICAgICAgICBpeSA9IF90aGlzJHN0YXRlJF9pbnRlbnRpb1sxXTtcbiAgICAgIHZhciBfdGhpcyRjb25maWckc3dpcGVWZWwgPSBfdGhpcy5jb25maWcuc3dpcGVWZWxvY2l0eSxcbiAgICAgICAgICBzdnggPSBfdGhpcyRjb25maWckc3dpcGVWZWxbMF0sXG4gICAgICAgICAgc3Z5ID0gX3RoaXMkY29uZmlnJHN3aXBlVmVsWzFdO1xuICAgICAgdmFyIF90aGlzJGNvbmZpZyRzd2lwZURpcyA9IF90aGlzLmNvbmZpZy5zd2lwZURpc3RhbmNlLFxuICAgICAgICAgIHN4ID0gX3RoaXMkY29uZmlnJHN3aXBlRGlzWzBdLFxuICAgICAgICAgIHN5ID0gX3RoaXMkY29uZmlnJHN3aXBlRGlzWzFdO1xuXG4gICAgICB2YXIgZW5kU3RhdGUgPSBfZXh0ZW5kcyh7fSwgZ2V0R2VuZXJpY1BheWxvYWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIGV2ZW50KSwgX3RoaXMuZ2V0TW92ZW1lbnQoX3RoaXMuc3RhdGUudmFsdWVzKSk7XG5cbiAgICAgIHZhciBzd2lwZSA9IFswLCAwXTtcblxuICAgICAgaWYgKGVuZFN0YXRlLmVsYXBzZWRUaW1lIDwgU1dJUEVfTUFYX0VMQVBTRURfVElNRSkge1xuICAgICAgICBpZiAoaXggIT09IGZhbHNlICYmIE1hdGguYWJzKHZ4KSA+IHN2eCAmJiBNYXRoLmFicyhteCkgPiBzeCkgc3dpcGVbMF0gPSBzaWduKHZ4KTtcbiAgICAgICAgaWYgKGl5ICE9PSBmYWxzZSAmJiBNYXRoLmFicyh2eSkgPiBzdnkgJiYgTWF0aC5hYnMobXkpID4gc3kpIHN3aXBlWzFdID0gc2lnbih2eSk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLnVwZGF0ZUdlc3R1cmVTdGF0ZShfZXh0ZW5kcyh7fSwgZW5kU3RhdGUsIHtcbiAgICAgICAgdGFwOiB0YXAsXG4gICAgICAgIHN3aXBlOiBzd2lwZVxuICAgICAgfSkpO1xuXG4gICAgICBfdGhpcy5maXJlR2VzdHVyZUhhbmRsZXIodGFwID09PSB0cnVlKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuY2xlYW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfQ29vcmRpbmF0ZXNSZWNvZ25pemUucHJvdG90eXBlLmNsZWFuLmNhbGwoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgICBfdGhpcy5zdGF0ZS5fZGVsYXllZEV2ZW50ID0gZmFsc2U7IC8vIGNhbid0IHJlbWVtYmVyIGlmIHRoaXMgaXMgdXNlZnVsP1xuXG4gICAgICBjbGVhcldpbmRvd0xpc3RlbmVycyhfdGhpcy5jb250cm9sbGVyLCBfdGhpcy5zdGF0ZUtleSk7IC8vIFRPRE8gYWRkIGJhY2sgd2hlbiBzZXRQb2ludGVyQ2FwdHVyZSBpcyB3aWRlbHkgd3VwcG9ydGVkXG4gICAgICAvLyB0aGlzLnJlbW92ZVBvaW50ZXJzKClcbiAgICB9O1xuXG4gICAgX3RoaXMub25DYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoX3RoaXMuc3RhdGUuY2FuY2VsZWQpIHJldHVybjtcblxuICAgICAgX3RoaXMudXBkYXRlR2VzdHVyZVN0YXRlKHtcbiAgICAgICAgY2FuY2VsZWQ6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICBfdGhpcy5zdGF0ZS5fYWN0aXZlID0gZmFsc2U7XG5cbiAgICAgIF90aGlzLnVwZGF0ZVNoYXJlZFN0YXRlKHtcbiAgICAgICAgZG93bjogZmFsc2UsXG4gICAgICAgIGJ1dHRvbnM6IDAsXG4gICAgICAgIHRvdWNoZXM6IDBcbiAgICAgIH0pO1xuXG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuZmlyZUdlc3R1cmVIYW5kbGVyKCk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgX3RoaXMub25DbGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKCFfdGhpcy5zdGF0ZS5faXNUYXApIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH07XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gRHJhZ1JlY29nbml6ZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5zdGFydERyYWcgPSBmdW5jdGlvbiBzdGFydERyYWcoZXZlbnQpIHtcbiAgICB2YXIgdmFsdWVzID0gZ2V0UG9pbnRlckV2ZW50VmFsdWVzKGV2ZW50KTtcbiAgICB0aGlzLnVwZGF0ZVNoYXJlZFN0YXRlKGdldEdlbmVyaWNFdmVudERhdGEoZXZlbnQpKTtcbiAgICB0aGlzLnVwZGF0ZUdlc3R1cmVTdGF0ZShfZXh0ZW5kcyh7fSwgZ2V0U3RhcnRHZXN0dXJlU3RhdGUodGhpcywgdmFsdWVzLCBldmVudCksIGdldEdlbmVyaWNQYXlsb2FkKHRoaXMsIGV2ZW50LCB0cnVlKSwge1xuICAgICAgX3BvaW50ZXJJZDogZXZlbnQucG9pbnRlcklkLFxuICAgICAgY2FuY2VsOiB0aGlzLm9uQ2FuY2VsXG4gICAgfSkpO1xuICAgIHRoaXMudXBkYXRlR2VzdHVyZVN0YXRlKHRoaXMuZ2V0TW92ZW1lbnQodmFsdWVzKSk7XG4gICAgdGhpcy5maXJlR2VzdHVyZUhhbmRsZXIoKTtcbiAgfTtcblxuICBfcHJvdG8uYWRkQmluZGluZ3MgPSBmdW5jdGlvbiBhZGRCaW5kaW5ncyQxKGJpbmRpbmdzKSB7XG4gICAgYWRkQmluZGluZ3MoYmluZGluZ3MsICdvblBvaW50ZXJEb3duJywgdGhpcy5vbkRyYWdTdGFydCk7XG5cbiAgICBpZiAodGhpcy5jb25maWcuZmlsdGVyVGFwcykge1xuICAgICAgdmFyIGhhbmRsZXIgPSB0aGlzLmNvbnRyb2xsZXIuY29uZmlnLmV2ZW50T3B0aW9ucy5jYXB0dXJlID8gJ29uQ2xpY2snIDogJ29uQ2xpY2tDYXB0dXJlJztcblxuICAgICAgYWRkQmluZGluZ3MoYmluZGluZ3MsIGhhbmRsZXIsIHRoaXMub25DbGljayk7XG4gICAgfSAvLyBUT0RPIGFkZCBiYWNrIHdoZW4gc2V0UG9pbnRlckNhcHR1cmUgaXMgd2lkZWx5IHd1cHBvcnRlZFxuICAgIC8vIGFkZEJpbmRpbmdzKGJpbmRpbmdzLCAnb25Qb2ludGVyTW92ZScsIHRoaXMub25EcmFnQ2hhbmdlKVxuICAgIC8vIGFkZEJpbmRpbmdzKGJpbmRpbmdzLCAnb25Qb2ludGVyVXAnLCB0aGlzLm9uRHJhZ0VuZClcbiAgICAvLyBhZGRCaW5kaW5ncyhiaW5kaW5ncywgJ29uUG9pbnRlckNhbmNlbCcsIHRoaXMub25EcmFnRW5kKVxuXG4gIH07XG5cbiAgcmV0dXJuIERyYWdSZWNvZ25pemVyO1xufShDb29yZGluYXRlc1JlY29nbml6ZXIpO1xuXG4vKipcclxuICogSW5saW5lZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9hbGV4cmVhcmRvbi9tZW1vaXplLW9uZVxyXG4gKi9cbmZ1bmN0aW9uIG1lbW9pemVPbmUocmVzdWx0Rm4sIGlzRXF1YWwpIHtcbiAgdmFyIGxhc3RUaGlzO1xuICB2YXIgbGFzdEFyZ3MgPSBbXTtcbiAgdmFyIGxhc3RSZXN1bHQ7XG4gIHZhciBjYWxsZWRPbmNlID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gbWVtb2l6ZWQoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG5ld0FyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBuZXdBcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGlmIChjYWxsZWRPbmNlICYmIGxhc3RUaGlzID09PSB0aGlzICYmIGlzRXF1YWwobmV3QXJncywgbGFzdEFyZ3MpKSB7XG4gICAgICByZXR1cm4gbGFzdFJlc3VsdDtcbiAgICB9XG5cbiAgICBsYXN0UmVzdWx0ID0gcmVzdWx0Rm4uYXBwbHkodGhpcywgbmV3QXJncyk7XG4gICAgY2FsbGVkT25jZSA9IHRydWU7XG4gICAgbGFzdFRoaXMgPSB0aGlzO1xuICAgIGxhc3RBcmdzID0gbmV3QXJncztcbiAgICByZXR1cm4gbGFzdFJlc3VsdDtcbiAgfVxuXG4gIHJldHVybiBtZW1vaXplZDtcbn1cblxuLyoqXHJcbiAqIFRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL0Zvcm1pZGFibGVMYWJzL3JlYWN0LWZhc3QtY29tcGFyZVxyXG4gKlxyXG4gKiBEcm9wcGVkIGNvbW1lbnRzIGFuZCBBcnJheUJ1ZmZlciBoYW5kbGluZ1xyXG4gKi9cbmZ1bmN0aW9uIGVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xuXG4gIGlmIChhICYmIGIgJiYgdHlwZW9mIGEgPT0gJ29iamVjdCcgJiYgdHlwZW9mIGIgPT0gJ29iamVjdCcpIHtcbiAgICBpZiAoYS5jb25zdHJ1Y3RvciAhPT0gYi5jb25zdHJ1Y3RvcikgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBsZW5ndGgsIGksIGtleXM7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspIHtcbiAgICAgICAgaWYgKCFlcXVhbChhW2ldLCBiW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgaXQ7XG5cbiAgICBpZiAodHlwZW9mIE1hcCA9PT0gJ2Z1bmN0aW9uJyAmJiBhIGluc3RhbmNlb2YgTWFwICYmIGIgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgIGlmIChhLnNpemUgIT09IGIuc2l6ZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgaXQgPSBhLmVudHJpZXMoKTtcblxuICAgICAgd2hpbGUgKCEoaSA9IGl0Lm5leHQoKSkuZG9uZSkge1xuICAgICAgICBpZiAoIWIuaGFzKGkudmFsdWVbMF0pKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGl0ID0gYS5lbnRyaWVzKCk7XG5cbiAgICAgIHdoaWxlICghKGkgPSBpdC5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgaWYgKCFlcXVhbChpLnZhbHVlWzFdLCBiLmdldChpLnZhbHVlWzBdKSkpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBTZXQgPT09ICdmdW5jdGlvbicgJiYgYSBpbnN0YW5jZW9mIFNldCAmJiBiIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICBpZiAoYS5zaXplICE9PSBiLnNpemUpIHJldHVybiBmYWxzZTtcbiAgICAgIGl0ID0gYS5lbnRyaWVzKCk7XG5cbiAgICAgIHdoaWxlICghKGkgPSBpdC5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgaWYgKCFiLmhhcyhpLnZhbHVlWzBdKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoYS5jb25zdHJ1Y3RvciA9PT0gUmVnRXhwKSByZXR1cm4gYS5zb3VyY2UgPT09IGIuc291cmNlICYmIGEuZmxhZ3MgPT09IGIuZmxhZ3M7XG4gICAgaWYgKGEudmFsdWVPZiAhPT0gT2JqZWN0LnByb3RvdHlwZS52YWx1ZU9mKSByZXR1cm4gYS52YWx1ZU9mKCkgPT09IGIudmFsdWVPZigpO1xuICAgIGlmIChhLnRvU3RyaW5nICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKSByZXR1cm4gYS50b1N0cmluZygpID09PSBiLnRvU3RyaW5nKCk7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KSB7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBrZXlzW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgYSBpbnN0YW5jZW9mIEVsZW1lbnQpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOykge1xuICAgICAgaWYgKGtleXNbaV0gPT09ICdfb3duZXInICYmIGEuJCR0eXBlb2YpIGNvbnRpbnVlO1xuICAgICAgaWYgKCFlcXVhbChhW2tleXNbaV1dLCBiW2tleXNbaV1dKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIHRydWUgaWYgYm90aCBOYU4sIGZhbHNlIG90aGVyd2lzZSDigJQgTmFOICE9PSBOYU4g4oaSIHRydWVcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuXG5cbiAgcmV0dXJuIGEgIT09IGEgJiYgYiAhPT0gYjtcbn1cblxuZnVuY3Rpb24gaXNFcXVhbChhLCBiKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVxdWFsKGEsIGIpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmICgoZXJyb3IubWVzc2FnZSB8fCAnJykubWF0Y2goL3N0YWNrfHJlY3Vyc2lvbi9pKSkge1xuICAgICAgY29uc29sZS53YXJuKCdyZWFjdC1mYXN0LWNvbXBhcmUgY2Fubm90IGhhbmRsZSBjaXJjdWxhciByZWZzJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuLyoqXHJcbiAqIERyYWcgaG9vay5cclxuICpcclxuICogQHBhcmFtIGhhbmRsZXIgLSB0aGUgZnVuY3Rpb24gZmlyZWQgZXZlcnkgdGltZSB0aGUgZHJhZyBnZXN0dXJlIHVwZGF0ZXNcclxuICogQHBhcmFtIFtjb25maWc9e31dIC0gdGhlIGNvbmZpZyBvYmplY3QgaW5jbHVkaW5nIGdlbmVyaWMgb3B0aW9ucyBhbmQgZHJhZyBvcHRpb25zXHJcbiAqL1xuXG5mdW5jdGlvbiB1c2VEcmFnKGhhbmRsZXIsIGNvbmZpZykge1xuICBpZiAoY29uZmlnID09PSB2b2lkIDApIHtcbiAgICBjb25maWcgPSB7fTtcbiAgfVxuXG4gIFJlY29nbml6ZXJzTWFwLnNldCgnZHJhZycsIERyYWdSZWNvZ25pemVyKTtcbiAgdmFyIGJ1aWxkRHJhZ0NvbmZpZyA9IHVzZVJlZigpO1xuXG4gIGlmICghYnVpbGREcmFnQ29uZmlnLmN1cnJlbnQpIHtcbiAgICBidWlsZERyYWdDb25maWcuY3VycmVudCA9IG1lbW9pemVPbmUoX2J1aWxkRHJhZ0NvbmZpZywgaXNFcXVhbCk7XG4gIH1cblxuICByZXR1cm4gdXNlUmVjb2duaXplcnMoe1xuICAgIGRyYWc6IGhhbmRsZXJcbiAgfSwgYnVpbGREcmFnQ29uZmlnLmN1cnJlbnQoY29uZmlnKSk7XG59XG5cbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBBYnN0cmFjdCBjbGFzcyBmb3IgZGlzdGFuY2UvYW5nbGUtYmFzZWQgZ2VzdHVyZSByZWNvbmdpemVyc1xyXG4gKi9cblxudmFyIERpc3RhbmNlQW5nbGVSZWNvZ25pemVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVjb2duaXplcikge1xuICBfaW5oZXJpdHNMb29zZShEaXN0YW5jZUFuZ2xlUmVjb2duaXplciwgX1JlY29nbml6ZXIpO1xuXG4gIGZ1bmN0aW9uIERpc3RhbmNlQW5nbGVSZWNvZ25pemVyKCkge1xuICAgIHJldHVybiBfUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gRGlzdGFuY2VBbmdsZVJlY29nbml6ZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5nZXRJbnRlcm5hbE1vdmVtZW50ID0gZnVuY3Rpb24gZ2V0SW50ZXJuYWxNb3ZlbWVudCh2YWx1ZXMsIHN0YXRlKSB7XG4gICAgdmFyIHByZXZfYSA9IHN0YXRlLnZhbHVlc1sxXTsgLy8gbm90IGJlIGRlZmluZWQgaWYgY3RybCt3aGVlbCBpcyB1c2VkIGZvciB6b29tIG9ubHlcblxuICAgIHZhciBkID0gdmFsdWVzWzBdLFxuICAgICAgICBfdmFsdWVzJCA9IHZhbHVlc1sxXSxcbiAgICAgICAgYSA9IF92YWx1ZXMkID09PSB2b2lkIDAgPyBwcmV2X2EgOiBfdmFsdWVzJDtcbiAgICB2YXIgZGVsdGFfYSA9IGEgLSBwcmV2X2E7XG4gICAgdmFyIG5leHRfdHVybnMgPSBzdGF0ZS50dXJucztcbiAgICBpZiAoTWF0aC5hYnMoZGVsdGFfYSkgPiAyNzApIG5leHRfdHVybnMgKz0gc2lnbihkZWx0YV9hKTtcbiAgICByZXR1cm4gc3ViVihbZCwgYSAtIDM2MCAqIG5leHRfdHVybnNdLCBzdGF0ZS5pbml0aWFsKTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0S2luZW1hdGljcyA9IGZ1bmN0aW9uIGdldEtpbmVtYXRpY3ModmFsdWVzLCBldmVudCkge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuZ2V0TW92ZW1lbnQodmFsdWVzKTtcbiAgICB2YXIgdHVybnMgPSAodmFsdWVzWzFdIC0gc3RhdGUubW92ZW1lbnRbMV0gLSB0aGlzLnN0YXRlLmluaXRpYWxbMV0pIC8gMzYwO1xuICAgIHZhciBkdCA9IGV2ZW50LnRpbWVTdGFtcCAtIHRoaXMuc3RhdGUudGltZVN0YW1wO1xuICAgIHZhciBraW5lbWF0aWNzID0gY2FsY3VsYXRlQWxsS2luZW1hdGljcyhzdGF0ZS5tb3ZlbWVudCwgc3RhdGUuZGVsdGEsIGR0KTtcbiAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgdHVybnM6IHR1cm5zXG4gICAgfSwgc3RhdGUsIGtpbmVtYXRpY3MpO1xuICB9O1xuXG4gIF9wcm90by5tYXBTdGF0ZVZhbHVlcyA9IGZ1bmN0aW9uIG1hcFN0YXRlVmFsdWVzKHN0YXRlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhOiBzdGF0ZS52YWx1ZXMsXG4gICAgICB2ZHZhOiBzdGF0ZS52ZWxvY2l0aWVzXG4gICAgfTtcbiAgfTtcblxuICByZXR1cm4gRGlzdGFuY2VBbmdsZVJlY29nbml6ZXI7XG59KFJlY29nbml6ZXIpO1xuXG52YXIgUGluY2hSZWNvZ25pemVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRGlzdGFuY2VBbmdsZVJlY29nbmkpIHtcbiAgX2luaGVyaXRzTG9vc2UoUGluY2hSZWNvZ25pemVyLCBfRGlzdGFuY2VBbmdsZVJlY29nbmkpO1xuXG4gIGZ1bmN0aW9uIFBpbmNoUmVjb2duaXplcigpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9EaXN0YW5jZUFuZ2xlUmVjb2duaS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMuaW5nS2V5ID0gJ3BpbmNoaW5nJztcbiAgICBfdGhpcy5zdGF0ZUtleSA9ICdwaW5jaCc7XG5cbiAgICBfdGhpcy5waW5jaFNob3VsZFN0YXJ0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB2YXIgX2dldEdlbmVyaWNFdmVudERhdGEgPSBnZXRHZW5lcmljRXZlbnREYXRhKGV2ZW50KSxcbiAgICAgICAgICB0b3VjaGVzID0gX2dldEdlbmVyaWNFdmVudERhdGEudG91Y2hlcztcblxuICAgICAgcmV0dXJuIF90aGlzLmVuYWJsZWQgJiYgdG91Y2hlcyA9PT0gMjtcbiAgICB9O1xuXG4gICAgX3RoaXMub25QaW5jaFN0YXJ0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoIV90aGlzLnBpbmNoU2hvdWxkU3RhcnQoZXZlbnQpKSByZXR1cm47XG5cbiAgICAgIHZhciBfZ2V0VHdvVG91Y2hlc0V2ZW50RGEgPSBnZXRUd29Ub3VjaGVzRXZlbnREYXRhKGV2ZW50KSxcbiAgICAgICAgICB2YWx1ZXMgPSBfZ2V0VHdvVG91Y2hlc0V2ZW50RGEudmFsdWVzLFxuICAgICAgICAgIG9yaWdpbiA9IF9nZXRUd29Ub3VjaGVzRXZlbnREYS5vcmlnaW47XG5cbiAgICAgIF90aGlzLnVwZGF0ZVNoYXJlZFN0YXRlKGdldEdlbmVyaWNFdmVudERhdGEoZXZlbnQpKTtcblxuICAgICAgX3RoaXMudXBkYXRlR2VzdHVyZVN0YXRlKF9leHRlbmRzKHt9LCBnZXRTdGFydEdlc3R1cmVTdGF0ZShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgdmFsdWVzLCBldmVudCksIGdldEdlbmVyaWNQYXlsb2FkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBldmVudCwgdHJ1ZSksIHtcbiAgICAgICAgY2FuY2VsOiBfdGhpcy5vbkNhbmNlbCxcbiAgICAgICAgb3JpZ2luOiBvcmlnaW5cbiAgICAgIH0pKTtcblxuICAgICAgX3RoaXMudXBkYXRlR2VzdHVyZVN0YXRlKF90aGlzLmdldE1vdmVtZW50KHZhbHVlcykpO1xuXG4gICAgICBfdGhpcy5maXJlR2VzdHVyZUhhbmRsZXIoKTtcbiAgICB9O1xuXG4gICAgX3RoaXMub25QaW5jaENoYW5nZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgdmFyIF90aGlzJHN0YXRlID0gX3RoaXMuc3RhdGUsXG4gICAgICAgICAgY2FuY2VsZWQgPSBfdGhpcyRzdGF0ZS5jYW5jZWxlZCxcbiAgICAgICAgICBfYWN0aXZlID0gX3RoaXMkc3RhdGUuX2FjdGl2ZTtcbiAgICAgIGlmIChjYW5jZWxlZCB8fCAhX2FjdGl2ZSkgcmV0dXJuO1xuICAgICAgdmFyIGdlbmVyaWNFdmVudERhdGEgPSBnZXRHZW5lcmljRXZlbnREYXRhKGV2ZW50KTtcblxuICAgICAgX3RoaXMudXBkYXRlU2hhcmVkU3RhdGUoZ2VuZXJpY0V2ZW50RGF0YSk7XG5cbiAgICAgIHZhciBfZ2V0VHdvVG91Y2hlc0V2ZW50RGEyID0gZ2V0VHdvVG91Y2hlc0V2ZW50RGF0YShldmVudCksXG4gICAgICAgICAgdmFsdWVzID0gX2dldFR3b1RvdWNoZXNFdmVudERhMi52YWx1ZXMsXG4gICAgICAgICAgb3JpZ2luID0gX2dldFR3b1RvdWNoZXNFdmVudERhMi5vcmlnaW47IC8vIEB0cy1pZ25vcmVcblxuXG4gICAgICB2YXIga2luZW1hdGljcyA9IF90aGlzLmdldEtpbmVtYXRpY3ModmFsdWVzLCBldmVudCk7XG5cbiAgICAgIF90aGlzLnVwZGF0ZUdlc3R1cmVTdGF0ZShfZXh0ZW5kcyh7fSwgZ2V0R2VuZXJpY1BheWxvYWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIGV2ZW50KSwga2luZW1hdGljcywge1xuICAgICAgICBvcmlnaW46IG9yaWdpblxuICAgICAgfSkpO1xuXG4gICAgICBfdGhpcy5maXJlR2VzdHVyZUhhbmRsZXIoKTtcbiAgICB9O1xuXG4gICAgX3RoaXMub25QaW5jaEVuZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKCFfdGhpcy5zdGF0ZS5hY3RpdmUpIHJldHVybjtcbiAgICAgIF90aGlzLnN0YXRlLl9hY3RpdmUgPSBmYWxzZTtcblxuICAgICAgX3RoaXMudXBkYXRlU2hhcmVkU3RhdGUoe1xuICAgICAgICBkb3duOiBmYWxzZSxcbiAgICAgICAgdG91Y2hlczogMFxuICAgICAgfSk7XG5cbiAgICAgIF90aGlzLnVwZGF0ZUdlc3R1cmVTdGF0ZShfZXh0ZW5kcyh7fSwgZ2V0R2VuZXJpY1BheWxvYWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIGV2ZW50KSwgX3RoaXMuZ2V0TW92ZW1lbnQoX3RoaXMuc3RhdGUudmFsdWVzKSkpO1xuXG4gICAgICBfdGhpcy5maXJlR2VzdHVyZUhhbmRsZXIoKTtcbiAgICB9O1xuXG4gICAgX3RoaXMub25DYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoX3RoaXMuc3RhdGUuY2FuY2VsZWQpIHJldHVybjtcbiAgICAgIF90aGlzLnN0YXRlLl9hY3RpdmUgPSBmYWxzZTtcblxuICAgICAgX3RoaXMudXBkYXRlR2VzdHVyZVN0YXRlKHtcbiAgICAgICAgY2FuY2VsZWQ6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICBfdGhpcy51cGRhdGVTaGFyZWRTdGF0ZSh7XG4gICAgICAgIGRvd246IGZhbHNlLFxuICAgICAgICB0b3VjaGVzOiAwXG4gICAgICB9KTtcblxuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmZpcmVHZXN0dXJlSGFuZGxlcigpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcclxuICAgICAqIFBJTkNIIFdJVEggV0VCS0lUIEdFU1RVUkVTXHJcbiAgICAgKi9cblxuXG4gICAgX3RoaXMub25HZXN0dXJlU3RhcnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmICghX3RoaXMuZW5hYmxlZCkgcmV0dXJuO1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgLy8gdXNlbGVzc1xuXG4gICAgICB2YXIgdmFsdWVzID0gZ2V0V2Via2l0R2VzdHVyZUV2ZW50VmFsdWVzKGV2ZW50KTtcblxuICAgICAgX3RoaXMudXBkYXRlU2hhcmVkU3RhdGUoZ2V0R2VuZXJpY0V2ZW50RGF0YShldmVudCkpO1xuXG4gICAgICBfdGhpcy51cGRhdGVHZXN0dXJlU3RhdGUoX2V4dGVuZHMoe30sIGdldFN0YXJ0R2VzdHVyZVN0YXRlKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCB2YWx1ZXMsIGV2ZW50KSwgZ2V0R2VuZXJpY1BheWxvYWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIGV2ZW50LCB0cnVlKSwge1xuICAgICAgICBvcmlnaW46IFtldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZXSxcbiAgICAgICAgY2FuY2VsOiBfdGhpcy5vbkNhbmNlbFxuICAgICAgfSkpO1xuXG4gICAgICBfdGhpcy51cGRhdGVHZXN0dXJlU3RhdGUoX3RoaXMuZ2V0TW92ZW1lbnQodmFsdWVzKSk7XG5cbiAgICAgIF90aGlzLmZpcmVHZXN0dXJlSGFuZGxlcigpO1xuICAgIH07XG5cbiAgICBfdGhpcy5vbkdlc3R1cmVDaGFuZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciBfdGhpcyRzdGF0ZTIgPSBfdGhpcy5zdGF0ZSxcbiAgICAgICAgICBjYW5jZWxlZCA9IF90aGlzJHN0YXRlMi5jYW5jZWxlZCxcbiAgICAgICAgICBfYWN0aXZlID0gX3RoaXMkc3RhdGUyLl9hY3RpdmU7XG4gICAgICBpZiAoY2FuY2VsZWQgfHwgIV9hY3RpdmUpIHJldHVybjtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB2YXIgZ2VuZXJpY0V2ZW50RGF0YSA9IGdldEdlbmVyaWNFdmVudERhdGEoZXZlbnQpO1xuXG4gICAgICBfdGhpcy51cGRhdGVTaGFyZWRTdGF0ZShnZW5lcmljRXZlbnREYXRhKTtcblxuICAgICAgdmFyIHZhbHVlcyA9IGdldFdlYmtpdEdlc3R1cmVFdmVudFZhbHVlcyhldmVudCk7XG5cbiAgICAgIHZhciBraW5lbWF0aWNzID0gX3RoaXMuZ2V0S2luZW1hdGljcyh2YWx1ZXMsIGV2ZW50KTtcblxuICAgICAgX3RoaXMudXBkYXRlR2VzdHVyZVN0YXRlKF9leHRlbmRzKHt9LCBnZXRHZW5lcmljUGF5bG9hZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgZXZlbnQpLCBraW5lbWF0aWNzLCB7XG4gICAgICAgIG9yaWdpbjogW2V2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFldXG4gICAgICB9KSk7XG5cbiAgICAgIF90aGlzLmZpcmVHZXN0dXJlSGFuZGxlcigpO1xuICAgIH07XG5cbiAgICBfdGhpcy5vbkdlc3R1cmVFbmQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBpZiAoIV90aGlzLnN0YXRlLmFjdGl2ZSkgcmV0dXJuO1xuICAgICAgX3RoaXMuc3RhdGUuX2FjdGl2ZSA9IGZhbHNlO1xuXG4gICAgICBfdGhpcy51cGRhdGVTaGFyZWRTdGF0ZSh7XG4gICAgICAgIGRvd246IGZhbHNlLFxuICAgICAgICB0b3VjaGVzOiAwXG4gICAgICB9KTtcblxuICAgICAgX3RoaXMudXBkYXRlR2VzdHVyZVN0YXRlKF9leHRlbmRzKHt9LCBnZXRHZW5lcmljUGF5bG9hZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgZXZlbnQpLCBfdGhpcy5nZXRNb3ZlbWVudChfdGhpcy5zdGF0ZS52YWx1ZXMpLCB7XG4gICAgICAgIG9yaWdpbjogW2V2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFldXG4gICAgICB9KSk7XG5cbiAgICAgIF90aGlzLmZpcmVHZXN0dXJlSGFuZGxlcigpO1xuICAgIH07XG4gICAgLyoqXHJcbiAgICAgKiBQSU5DSCBXSVRIIFdIRUVMXHJcbiAgICAgKi9cblxuXG4gICAgX3RoaXMud2hlZWxTaG91bGRSdW4gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHJldHVybiBfdGhpcy5lbmFibGVkICYmIGV2ZW50LmN0cmxLZXk7XG4gICAgfTtcblxuICAgIF90aGlzLmdldFdoZWVsVmFsdWVzRnJvbUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB2YXIgX2dldFdoZWVsRXZlbnRWYWx1ZXMgPSBnZXRXaGVlbEV2ZW50VmFsdWVzKGV2ZW50KSxcbiAgICAgICAgICBkZWx0YV9kID0gX2dldFdoZWVsRXZlbnRWYWx1ZXNbMV07XG5cbiAgICAgIHZhciBfdGhpcyRzdGF0ZSR2YWx1ZXMgPSBfdGhpcy5zdGF0ZS52YWx1ZXMsXG4gICAgICAgICAgcHJldl9kID0gX3RoaXMkc3RhdGUkdmFsdWVzWzBdLFxuICAgICAgICAgIHByZXZfYSA9IF90aGlzJHN0YXRlJHZhbHVlc1sxXTtcbiAgICAgIHZhciBkID0gcHJldl9kIC0gZGVsdGFfZDtcbiAgICAgIHZhciBhID0gcHJldl9hICE9PSB2b2lkIDAgPyBwcmV2X2EgOiAwO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWVzOiBbZCwgYV0sXG4gICAgICAgIG9yaWdpbjogW2V2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFldLFxuICAgICAgICBkZWx0YTogWzAsIGRlbHRhX2RdXG4gICAgICB9O1xuICAgIH07XG5cbiAgICBfdGhpcy5vbldoZWVsID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoIV90aGlzLndoZWVsU2hvdWxkUnVuKGV2ZW50KSkgcmV0dXJuO1xuXG4gICAgICBfdGhpcy5zZXRUaW1lb3V0KF90aGlzLm9uV2hlZWxFbmQpO1xuXG4gICAgICBpZiAoIV90aGlzLnN0YXRlLl9hY3RpdmUpIF90aGlzLm9uV2hlZWxTdGFydChldmVudCk7ZWxzZSBfdGhpcy5vbldoZWVsQ2hhbmdlKGV2ZW50KTtcbiAgICB9O1xuXG4gICAgX3RoaXMub25XaGVlbFN0YXJ0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB2YXIgX3RoaXMkZ2V0V2hlZWxWYWx1ZXNGID0gX3RoaXMuZ2V0V2hlZWxWYWx1ZXNGcm9tRXZlbnQoZXZlbnQpLFxuICAgICAgICAgIHZhbHVlcyA9IF90aGlzJGdldFdoZWVsVmFsdWVzRi52YWx1ZXMsXG4gICAgICAgICAgZGVsdGEgPSBfdGhpcyRnZXRXaGVlbFZhbHVlc0YuZGVsdGEsXG4gICAgICAgICAgb3JpZ2luID0gX3RoaXMkZ2V0V2hlZWxWYWx1ZXNGLm9yaWdpbjtcblxuICAgICAgaWYgKGV2ZW50LmNhbmNlbGFibGUpIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7ZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdUbyBwcm9wZXJseSBzdXBwb3J0IHpvb20gb24gdHJhY2twYWRzLCB0cnkgdXNpbmcgdGhlIGBkb21UYXJnZXRgIG9wdGlvbiBhbmQgYGNvbmZpZy5ldmVudE9wdGlvbnMucGFzc2l2ZWAgc2V0IHRvIGBmYWxzZWAuIFRoaXMgbWVzc2FnZSB3aWxsIG9ubHkgYXBwZWFyIGluIGRldmVsb3BtZW50IG1vZGUuJyk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLnVwZGF0ZVNoYXJlZFN0YXRlKGdldEdlbmVyaWNFdmVudERhdGEoZXZlbnQpKTtcblxuICAgICAgX3RoaXMudXBkYXRlR2VzdHVyZVN0YXRlKF9leHRlbmRzKHt9LCBnZXRTdGFydEdlc3R1cmVTdGF0ZShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgdmFsdWVzLCBldmVudCksIGdldEdlbmVyaWNQYXlsb2FkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBldmVudCwgdHJ1ZSksIHtcbiAgICAgICAgaW5pdGlhbDogX3RoaXMuc3RhdGUudmFsdWVzLFxuICAgICAgICBvZmZzZXQ6IHZhbHVlcyxcbiAgICAgICAgZGVsdGE6IGRlbHRhLFxuICAgICAgICBvcmlnaW46IG9yaWdpblxuICAgICAgfSkpO1xuXG4gICAgICBfdGhpcy51cGRhdGVHZXN0dXJlU3RhdGUoX3RoaXMuZ2V0TW92ZW1lbnQodmFsdWVzKSk7XG5cbiAgICAgIF90aGlzLmZpcmVHZXN0dXJlSGFuZGxlcigpO1xuICAgIH07XG5cbiAgICBfdGhpcy5vbldoZWVsQ2hhbmdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBfdGhpcy51cGRhdGVTaGFyZWRTdGF0ZShnZXRHZW5lcmljRXZlbnREYXRhKGV2ZW50KSk7XG5cbiAgICAgIHZhciBfdGhpcyRnZXRXaGVlbFZhbHVlc0YyID0gX3RoaXMuZ2V0V2hlZWxWYWx1ZXNGcm9tRXZlbnQoZXZlbnQpLFxuICAgICAgICAgIHZhbHVlcyA9IF90aGlzJGdldFdoZWVsVmFsdWVzRjIudmFsdWVzLFxuICAgICAgICAgIG9yaWdpbiA9IF90aGlzJGdldFdoZWVsVmFsdWVzRjIub3JpZ2luLFxuICAgICAgICAgIGRlbHRhID0gX3RoaXMkZ2V0V2hlZWxWYWx1ZXNGMi5kZWx0YTtcblxuICAgICAgX3RoaXMudXBkYXRlR2VzdHVyZVN0YXRlKF9leHRlbmRzKHt9LCBnZXRHZW5lcmljUGF5bG9hZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgZXZlbnQpLCBfdGhpcy5nZXRLaW5lbWF0aWNzKHZhbHVlcywgZXZlbnQpLCB7XG4gICAgICAgIG9yaWdpbjogb3JpZ2luLFxuICAgICAgICBkZWx0YTogZGVsdGFcbiAgICAgIH0pKTtcblxuICAgICAgX3RoaXMuZmlyZUdlc3R1cmVIYW5kbGVyKCk7XG4gICAgfTtcblxuICAgIF90aGlzLm9uV2hlZWxFbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5zdGF0ZS5fYWN0aXZlID0gZmFsc2U7XG5cbiAgICAgIF90aGlzLnVwZGF0ZUdlc3R1cmVTdGF0ZShfdGhpcy5nZXRNb3ZlbWVudChfdGhpcy5zdGF0ZS52YWx1ZXMpKTtcblxuICAgICAgX3RoaXMuZmlyZUdlc3R1cmVIYW5kbGVyKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBQaW5jaFJlY29nbml6ZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5hZGRCaW5kaW5ncyA9IGZ1bmN0aW9uIGFkZEJpbmRpbmdzJDEoYmluZGluZ3MpIHtcbiAgICAvLyBPbmx5IHRyeSB0byB1c2UgZ2VzdHVyZSBldmVudHMgd2hlbiB0aGV5IGFyZSBzdXBwb3J0ZWQgYW5kIGRvbVRhcmdldCBpcyBzZXRcbiAgICAvLyBhcyBSZWFjdCBkb2Vzbid0IHN1cHBvcnQgZ2VzdHVyZSBoYW5kbGVycy5cbiAgICBpZiAodGhpcy5jb250cm9sbGVyLmNvbmZpZy5kb21UYXJnZXQgJiYgIXN1cHBvcnRzVG91Y2hFdmVudHMoKSAmJiBzdXBwb3J0c0dlc3R1cmVFdmVudHMoKSkge1xuICAgICAgYWRkQmluZGluZ3MoYmluZGluZ3MsICdvbkdlc3R1cmVTdGFydCcsIHRoaXMub25HZXN0dXJlU3RhcnQpO1xuXG4gICAgICBhZGRCaW5kaW5ncyhiaW5kaW5ncywgJ29uR2VzdHVyZUNoYW5nZScsIHRoaXMub25HZXN0dXJlQ2hhbmdlKTtcblxuICAgICAgYWRkQmluZGluZ3MoYmluZGluZ3MsICdvbkdlc3R1cmVFbmQnLCB0aGlzLm9uR2VzdHVyZUVuZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFkZEJpbmRpbmdzKGJpbmRpbmdzLCAnb25Ub3VjaFN0YXJ0JywgdGhpcy5vblBpbmNoU3RhcnQpO1xuXG4gICAgICBhZGRCaW5kaW5ncyhiaW5kaW5ncywgJ29uVG91Y2hNb3ZlJywgdGhpcy5vblBpbmNoQ2hhbmdlKTtcblxuICAgICAgYWRkQmluZGluZ3MoYmluZGluZ3MsICdvblRvdWNoRW5kJywgdGhpcy5vblBpbmNoRW5kKTtcblxuICAgICAgYWRkQmluZGluZ3MoYmluZGluZ3MsICdvblRvdWNoQ2FuY2VsJywgdGhpcy5vblBpbmNoRW5kKTtcblxuICAgICAgYWRkQmluZGluZ3MoYmluZGluZ3MsICdvbldoZWVsJywgdGhpcy5vbldoZWVsKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFBpbmNoUmVjb2duaXplcjtcbn0oRGlzdGFuY2VBbmdsZVJlY29nbml6ZXIpO1xuXG4vKipcclxuICogUGluY2ggaG9vay5cclxuICpcclxuICogQHBhcmFtIGhhbmRsZXIgLSB0aGUgZnVuY3Rpb24gZmlyZWQgZXZlcnkgdGltZSB0aGUgcGluY2ggZ2VzdHVyZSB1cGRhdGVzXHJcbiAqIEBwYXJhbSBbY29uZmlnPXt9XSAtIHRoZSBjb25maWcgb2JqZWN0IGluY2x1ZGluZyBnZW5lcmljIG9wdGlvbnMgYW5kIHBpbmNoIG9wdGlvbnNcclxuICovXG5cbmZ1bmN0aW9uIHVzZVBpbmNoKGhhbmRsZXIsIGNvbmZpZykge1xuICBpZiAoY29uZmlnID09PSB2b2lkIDApIHtcbiAgICBjb25maWcgPSB7fTtcbiAgfVxuXG4gIFJlY29nbml6ZXJzTWFwLnNldCgncGluY2gnLCBQaW5jaFJlY29nbml6ZXIpO1xuICB2YXIgYnVpbGRQaW5jaENvbmZpZyA9IHVzZVJlZigpO1xuXG4gIGlmICghYnVpbGRQaW5jaENvbmZpZy5jdXJyZW50KSB7XG4gICAgYnVpbGRQaW5jaENvbmZpZy5jdXJyZW50ID0gbWVtb2l6ZU9uZShfYnVpbGRQaW5jaENvbmZpZywgaXNFcXVhbCk7XG4gIH1cblxuICByZXR1cm4gdXNlUmVjb2duaXplcnMoe1xuICAgIHBpbmNoOiBoYW5kbGVyXG4gIH0sIGJ1aWxkUGluY2hDb25maWcuY3VycmVudChjb25maWcpKTtcbn1cblxudmFyIFdoZWVsUmVjb2duaXplciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Nvb3JkaW5hdGVzUmVjb2duaXplKSB7XG4gIF9pbmhlcml0c0xvb3NlKFdoZWVsUmVjb2duaXplciwgX0Nvb3JkaW5hdGVzUmVjb2duaXplKTtcblxuICBmdW5jdGlvbiBXaGVlbFJlY29nbml6ZXIoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfQ29vcmRpbmF0ZXNSZWNvZ25pemUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLmluZ0tleSA9ICd3aGVlbGluZyc7XG4gICAgX3RoaXMuc3RhdGVLZXkgPSAnd2hlZWwnO1xuICAgIF90aGlzLmRlYm91bmNlZCA9IHRydWU7XG5cbiAgICBfdGhpcy5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKGV2ZW50LmN0cmxLZXkgJiYgJ3BpbmNoJyBpbiBfdGhpcy5jb250cm9sbGVyLmhhbmRsZXJzKSByZXR1cm47XG4gICAgICBpZiAoIV90aGlzLmVuYWJsZWQpIHJldHVybjtcblxuICAgICAgX3RoaXMuc2V0VGltZW91dChfdGhpcy5vbkVuZCk7XG5cbiAgICAgIF90aGlzLnVwZGF0ZVNoYXJlZFN0YXRlKGdldEdlbmVyaWNFdmVudERhdGEoZXZlbnQpKTtcblxuICAgICAgdmFyIHZhbHVlcyA9IGFkZFYoZ2V0V2hlZWxFdmVudFZhbHVlcyhldmVudCksIF90aGlzLnN0YXRlLnZhbHVlcyk7XG5cbiAgICAgIGlmICghX3RoaXMuc3RhdGUuX2FjdGl2ZSkge1xuICAgICAgICBfdGhpcy51cGRhdGVHZXN0dXJlU3RhdGUoX2V4dGVuZHMoe30sIGdldFN0YXJ0R2VzdHVyZVN0YXRlKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCB2YWx1ZXMsIGV2ZW50KSwgZ2V0R2VuZXJpY1BheWxvYWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIGV2ZW50LCB0cnVlKSwge1xuICAgICAgICAgIGluaXRpYWw6IF90aGlzLnN0YXRlLnZhbHVlc1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgdmFyIG1vdmVtZW50ID0gX3RoaXMuZ2V0TW92ZW1lbnQodmFsdWVzKTtcblxuICAgICAgICB2YXIgZ2VvbWV0cnkgPSBjYWxjdWxhdGVBbGxHZW9tZXRyeShtb3ZlbWVudC5kZWx0YSk7XG5cbiAgICAgICAgX3RoaXMudXBkYXRlR2VzdHVyZVN0YXRlKG1vdmVtZW50KTtcblxuICAgICAgICBfdGhpcy51cGRhdGVHZXN0dXJlU3RhdGUoZ2VvbWV0cnkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMudXBkYXRlR2VzdHVyZVN0YXRlKF9leHRlbmRzKHt9LCBnZXRHZW5lcmljUGF5bG9hZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgZXZlbnQpLCBfdGhpcy5nZXRLaW5lbWF0aWNzKHZhbHVlcywgZXZlbnQpKSk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLmZpcmVHZXN0dXJlSGFuZGxlcigpO1xuICAgIH07XG5cbiAgICBfdGhpcy5vbkVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBtb3ZlbWVudCA9IF90aGlzLmdldE1vdmVtZW50KF90aGlzLnN0YXRlLnZhbHVlcyk7XG5cbiAgICAgIF90aGlzLnVwZGF0ZUdlc3R1cmVTdGF0ZShtb3ZlbWVudCk7XG5cbiAgICAgIF90aGlzLnVwZGF0ZUdlc3R1cmVTdGF0ZSh7XG4gICAgICAgIF9hY3RpdmU6IGZhbHNlLFxuICAgICAgICB2ZWxvY2l0aWVzOiBbMCwgMF0sXG4gICAgICAgIHZlbG9jaXR5OiAwXG4gICAgICB9KTtcblxuICAgICAgX3RoaXMuZmlyZUdlc3R1cmVIYW5kbGVyKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBXaGVlbFJlY29nbml6ZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5hZGRCaW5kaW5ncyA9IGZ1bmN0aW9uIGFkZEJpbmRpbmdzJDEoYmluZGluZ3MpIHtcbiAgICBhZGRCaW5kaW5ncyhiaW5kaW5ncywgJ29uV2hlZWwnLCB0aGlzLmhhbmRsZUV2ZW50KTtcbiAgfTtcblxuICByZXR1cm4gV2hlZWxSZWNvZ25pemVyO1xufShDb29yZGluYXRlc1JlY29nbml6ZXIpO1xuXG4vKipcclxuICogV2hlZWwgaG9vay5cclxuICpcclxuICogQHBhcmFtIGhhbmRsZXIgLSB0aGUgZnVuY3Rpb24gZmlyZWQgZXZlcnkgdGltZSB0aGUgd2hlZWwgZ2VzdHVyZSB1cGRhdGVzXHJcbiAqIEBwYXJhbSB0aGUgY29uZmlnIG9iamVjdCBpbmNsdWRpbmcgZ2VuZXJpYyBvcHRpb25zIGFuZCB3aGVlbCBvcHRpb25zXHJcbiAqL1xuXG5mdW5jdGlvbiB1c2VXaGVlbChoYW5kbGVyLCBjb25maWcpIHtcbiAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7XG4gICAgY29uZmlnID0ge307XG4gIH1cblxuICBSZWNvZ25pemVyc01hcC5zZXQoJ3doZWVsJywgV2hlZWxSZWNvZ25pemVyKTtcbiAgdmFyIGJ1aWxkV2hlZWxDb25maWcgPSB1c2VSZWYoKTtcblxuICBpZiAoIWJ1aWxkV2hlZWxDb25maWcuY3VycmVudCkge1xuICAgIGJ1aWxkV2hlZWxDb25maWcuY3VycmVudCA9IG1lbW9pemVPbmUoX2J1aWxkV2hlZWxDb25maWcsIGlzRXF1YWwpO1xuICB9XG5cbiAgcmV0dXJuIHVzZVJlY29nbml6ZXJzKHtcbiAgICB3aGVlbDogaGFuZGxlclxuICB9LCBidWlsZFdoZWVsQ29uZmlnLmN1cnJlbnQoY29uZmlnKSk7XG59XG5cbnZhciBNb3ZlUmVjb2duaXplciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Nvb3JkaW5hdGVzUmVjb2duaXplKSB7XG4gIF9pbmhlcml0c0xvb3NlKE1vdmVSZWNvZ25pemVyLCBfQ29vcmRpbmF0ZXNSZWNvZ25pemUpO1xuXG4gIGZ1bmN0aW9uIE1vdmVSZWNvZ25pemVyKCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0Nvb3JkaW5hdGVzUmVjb2duaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy5pbmdLZXkgPSAnbW92aW5nJztcbiAgICBfdGhpcy5zdGF0ZUtleSA9ICdtb3ZlJztcbiAgICBfdGhpcy5kZWJvdW5jZWQgPSB0cnVlO1xuXG4gICAgX3RoaXMub25Nb3ZlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoIV90aGlzLmVuYWJsZWQpIHJldHVybjtcblxuICAgICAgX3RoaXMuc2V0VGltZW91dChfdGhpcy5vbk1vdmVFbmQpO1xuXG4gICAgICBpZiAoIV90aGlzLnN0YXRlLl9hY3RpdmUpIF90aGlzLm9uTW92ZVN0YXJ0KGV2ZW50KTtlbHNlIF90aGlzLm9uTW92ZUNoYW5nZShldmVudCk7XG4gICAgfTtcblxuICAgIF90aGlzLm9uTW92ZVN0YXJ0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBfdGhpcy51cGRhdGVTaGFyZWRTdGF0ZShnZXRHZW5lcmljRXZlbnREYXRhKGV2ZW50KSk7XG5cbiAgICAgIHZhciB2YWx1ZXMgPSBnZXRQb2ludGVyRXZlbnRWYWx1ZXMoZXZlbnQpO1xuXG4gICAgICBfdGhpcy51cGRhdGVHZXN0dXJlU3RhdGUoX2V4dGVuZHMoe30sIGdldFN0YXJ0R2VzdHVyZVN0YXRlKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCB2YWx1ZXMsIGV2ZW50KSwgZ2V0R2VuZXJpY1BheWxvYWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIGV2ZW50LCB0cnVlKSkpO1xuXG4gICAgICBfdGhpcy51cGRhdGVHZXN0dXJlU3RhdGUoX3RoaXMuZ2V0TW92ZW1lbnQodmFsdWVzKSk7XG5cbiAgICAgIF90aGlzLmZpcmVHZXN0dXJlSGFuZGxlcigpO1xuICAgIH07XG5cbiAgICBfdGhpcy5vbk1vdmVDaGFuZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIF90aGlzLnVwZGF0ZVNoYXJlZFN0YXRlKGdldEdlbmVyaWNFdmVudERhdGEoZXZlbnQpKTtcblxuICAgICAgdmFyIHZhbHVlcyA9IGdldFBvaW50ZXJFdmVudFZhbHVlcyhldmVudCk7XG5cbiAgICAgIF90aGlzLnVwZGF0ZUdlc3R1cmVTdGF0ZShfZXh0ZW5kcyh7fSwgZ2V0R2VuZXJpY1BheWxvYWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIGV2ZW50KSwgX3RoaXMuZ2V0S2luZW1hdGljcyh2YWx1ZXMsIGV2ZW50KSkpO1xuXG4gICAgICBfdGhpcy5maXJlR2VzdHVyZUhhbmRsZXIoKTtcbiAgICB9O1xuXG4gICAgX3RoaXMub25Nb3ZlRW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHZhbHVlcyA9IF90aGlzLnN0YXRlLnZhbHVlcztcblxuICAgICAgX3RoaXMudXBkYXRlR2VzdHVyZVN0YXRlKF90aGlzLmdldE1vdmVtZW50KHZhbHVlcykpO1xuXG4gICAgICBfdGhpcy51cGRhdGVHZXN0dXJlU3RhdGUoe1xuICAgICAgICB2ZWxvY2l0aWVzOiBbMCwgMF0sXG4gICAgICAgIHZlbG9jaXR5OiAwLFxuICAgICAgICBfYWN0aXZlOiBmYWxzZVxuICAgICAgfSk7XG5cbiAgICAgIF90aGlzLmZpcmVHZXN0dXJlSGFuZGxlcigpO1xuICAgIH07XG5cbiAgICBfdGhpcy5vblBvaW50ZXJFbnRlciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgX3RoaXMuY29udHJvbGxlci5zdGF0ZS5zaGFyZWQuaG92ZXJpbmcgPSB0cnVlO1xuICAgICAgaWYgKCFfdGhpcy5jb250cm9sbGVyLmNvbmZpZy5lbmFibGVkKSByZXR1cm47XG5cbiAgICAgIGlmIChfdGhpcy5jb250cm9sbGVyLmNvbmZpZy5ob3Zlci5lbmFibGVkKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBnZXRQb2ludGVyRXZlbnRWYWx1ZXMoZXZlbnQpO1xuXG4gICAgICAgIHZhciBzdGF0ZSA9IF9leHRlbmRzKHt9LCBfdGhpcy5jb250cm9sbGVyLnN0YXRlLnNoYXJlZCwgX3RoaXMuc3RhdGUsIGdldEdlbmVyaWNQYXlsb2FkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBldmVudCwgdHJ1ZSksIHtcbiAgICAgICAgICB2YWx1ZXM6IHZhbHVlcyxcbiAgICAgICAgICBhY3RpdmU6IHRydWUsXG4gICAgICAgICAgaG92ZXJpbmc6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgX3RoaXMuY29udHJvbGxlci5oYW5kbGVycy5ob3ZlcihfZXh0ZW5kcyh7fSwgc3RhdGUsIF90aGlzLm1hcFN0YXRlVmFsdWVzKHN0YXRlKSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoJ21vdmUnIGluIF90aGlzLmNvbnRyb2xsZXIuaGFuZGxlcnMpIF90aGlzLm9uTW92ZVN0YXJ0KGV2ZW50KTtcbiAgICB9O1xuXG4gICAgX3RoaXMub25Qb2ludGVyTGVhdmUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIF90aGlzLmNvbnRyb2xsZXIuc3RhdGUuc2hhcmVkLmhvdmVyaW5nID0gZmFsc2U7XG4gICAgICBpZiAoJ21vdmUnIGluIF90aGlzLmNvbnRyb2xsZXIuaGFuZGxlcnMpIF90aGlzLm9uTW92ZUVuZCgpO1xuICAgICAgaWYgKCFfdGhpcy5jb250cm9sbGVyLmNvbmZpZy5ob3Zlci5lbmFibGVkKSByZXR1cm47XG4gICAgICB2YXIgdmFsdWVzID0gZ2V0UG9pbnRlckV2ZW50VmFsdWVzKGV2ZW50KTtcblxuICAgICAgdmFyIHN0YXRlID0gX2V4dGVuZHMoe30sIF90aGlzLmNvbnRyb2xsZXIuc3RhdGUuc2hhcmVkLCBfdGhpcy5zdGF0ZSwgZ2V0R2VuZXJpY1BheWxvYWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIGV2ZW50KSwge1xuICAgICAgICB2YWx1ZXM6IHZhbHVlcyxcbiAgICAgICAgYWN0aXZlOiBmYWxzZVxuICAgICAgfSk7XG5cbiAgICAgIF90aGlzLmNvbnRyb2xsZXIuaGFuZGxlcnMuaG92ZXIoX2V4dGVuZHMoe30sIHN0YXRlLCBfdGhpcy5tYXBTdGF0ZVZhbHVlcyhzdGF0ZSkpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IE1vdmVSZWNvZ25pemVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uYWRkQmluZGluZ3MgPSBmdW5jdGlvbiBhZGRCaW5kaW5ncyQxKGJpbmRpbmdzKSB7XG4gICAgaWYgKCdtb3ZlJyBpbiB0aGlzLmNvbnRyb2xsZXIuaGFuZGxlcnMpIHtcbiAgICAgIGFkZEJpbmRpbmdzKGJpbmRpbmdzLCAnb25Qb2ludGVyTW92ZScsIHRoaXMub25Nb3ZlKTtcbiAgICB9XG5cbiAgICBpZiAoJ2hvdmVyJyBpbiB0aGlzLmNvbnRyb2xsZXIuaGFuZGxlcnMpIHtcbiAgICAgIGFkZEJpbmRpbmdzKGJpbmRpbmdzLCAnb25Qb2ludGVyRW50ZXInLCB0aGlzLm9uUG9pbnRlckVudGVyKTtcblxuICAgICAgYWRkQmluZGluZ3MoYmluZGluZ3MsICdvblBvaW50ZXJMZWF2ZScsIHRoaXMub25Qb2ludGVyTGVhdmUpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gTW92ZVJlY29nbml6ZXI7XG59KENvb3JkaW5hdGVzUmVjb2duaXplcik7XG5cbi8qKlxyXG4gKiBNb3ZlIGhvb2suXHJcbiAqXHJcbiAqIEBwYXJhbSBoYW5kbGVyIC0gdGhlIGZ1bmN0aW9uIGZpcmVkIGV2ZXJ5IHRpbWUgdGhlIG1vdmUgZ2VzdHVyZSB1cGRhdGVzXHJcbiAqIEBwYXJhbSBbY29uZmlnPXt9XSAtIHRoZSBjb25maWcgb2JqZWN0IGluY2x1ZGluZyBnZW5lcmljIG9wdGlvbnMgYW5kIG1vdmUgb3B0aW9uc1xyXG4gKi9cblxuZnVuY3Rpb24gdXNlTW92ZShoYW5kbGVyLCBjb25maWcpIHtcbiAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7XG4gICAgY29uZmlnID0ge307XG4gIH1cblxuICBSZWNvZ25pemVyc01hcC5zZXQoJ21vdmUnLCBNb3ZlUmVjb2duaXplcik7XG4gIHZhciBidWlsZE1vdmVDb25maWcgPSB1c2VSZWYoKTtcblxuICBpZiAoIWJ1aWxkTW92ZUNvbmZpZy5jdXJyZW50KSB7XG4gICAgYnVpbGRNb3ZlQ29uZmlnLmN1cnJlbnQgPSBtZW1vaXplT25lKF9idWlsZE1vdmVDb25maWcsIGlzRXF1YWwpO1xuICB9XG5cbiAgcmV0dXJuIHVzZVJlY29nbml6ZXJzKHtcbiAgICBtb3ZlOiBoYW5kbGVyXG4gIH0sIGJ1aWxkTW92ZUNvbmZpZy5jdXJyZW50KGNvbmZpZykpO1xufVxuXG4vKipcclxuICogSG92ZXIgaG9vay5cclxuICpcclxuICogQHBhcmFtIGhhbmRsZXIgLSB0aGUgZnVuY3Rpb24gZmlyZWQgZXZlcnkgdGltZSB0aGUgaG92ZXIgZ2VzdHVyZSB1cGRhdGVzXHJcbiAqIEBwYXJhbSBbY29uZmlnPXt9XSAtIHRoZSBjb25maWcgb2JqZWN0IGluY2x1ZGluZyBnZW5lcmljIG9wdGlvbnMgYW5kIGhvdmVyIG9wdGlvbnNcclxuICovXG5cbmZ1bmN0aW9uIHVzZUhvdmVyKGhhbmRsZXIsIGNvbmZpZykge1xuICBpZiAoY29uZmlnID09PSB2b2lkIDApIHtcbiAgICBjb25maWcgPSB7fTtcbiAgfVxuXG4gIFJlY29nbml6ZXJzTWFwLnNldCgnaG92ZXInLCBNb3ZlUmVjb2duaXplcik7XG4gIHZhciBidWlsZEhvdmVyQ29uZmlnID0gdXNlUmVmKCk7XG5cbiAgaWYgKCFidWlsZEhvdmVyQ29uZmlnLmN1cnJlbnQpIHtcbiAgICBidWlsZEhvdmVyQ29uZmlnLmN1cnJlbnQgPSBtZW1vaXplT25lKF9idWlsZEhvdmVyQ29uZmlnLCBpc0VxdWFsKTtcbiAgfVxuXG4gIHJldHVybiB1c2VSZWNvZ25pemVycyh7XG4gICAgaG92ZXI6IGhhbmRsZXJcbiAgfSwgYnVpbGRIb3ZlckNvbmZpZy5jdXJyZW50KGNvbmZpZykpO1xufVxuXG52YXIgU2Nyb2xsUmVjb2duaXplciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Nvb3JkaW5hdGVzUmVjb2duaXplKSB7XG4gIF9pbmhlcml0c0xvb3NlKFNjcm9sbFJlY29nbml6ZXIsIF9Db29yZGluYXRlc1JlY29nbml6ZSk7XG5cbiAgZnVuY3Rpb24gU2Nyb2xsUmVjb2duaXplcigpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9Db29yZGluYXRlc1JlY29nbml6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMuaW5nS2V5ID0gJ3Njcm9sbGluZyc7XG4gICAgX3RoaXMuc3RhdGVLZXkgPSAnc2Nyb2xsJztcbiAgICBfdGhpcy5kZWJvdW5jZWQgPSB0cnVlO1xuXG4gICAgX3RoaXMuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmICghX3RoaXMuZW5hYmxlZCkgcmV0dXJuO1xuXG4gICAgICBfdGhpcy5jbGVhclRpbWVvdXQoKTtcblxuICAgICAgX3RoaXMuc2V0VGltZW91dChfdGhpcy5vbkVuZCk7XG5cbiAgICAgIHZhciB2YWx1ZXMgPSBnZXRTY3JvbGxFdmVudFZhbHVlcyhldmVudCk7XG5cbiAgICAgIF90aGlzLnVwZGF0ZVNoYXJlZFN0YXRlKGdldEdlbmVyaWNFdmVudERhdGEoZXZlbnQpKTtcblxuICAgICAgaWYgKCFfdGhpcy5zdGF0ZS5fYWN0aXZlKSB7XG4gICAgICAgIF90aGlzLnVwZGF0ZUdlc3R1cmVTdGF0ZShfZXh0ZW5kcyh7fSwgZ2V0U3RhcnRHZXN0dXJlU3RhdGUoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIHZhbHVlcywgZXZlbnQpLCBnZXRHZW5lcmljUGF5bG9hZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgZXZlbnQsIHRydWUpLCB7XG4gICAgICAgICAgaW5pdGlhbDogX3RoaXMuc3RhdGUudmFsdWVzXG4gICAgICAgIH0pKTtcblxuICAgICAgICB2YXIgbW92ZW1lbnREZXRlY3Rpb24gPSBfdGhpcy5nZXRNb3ZlbWVudCh2YWx1ZXMpO1xuXG4gICAgICAgIHZhciBnZW9tZXRyeSA9IGNhbGN1bGF0ZUFsbEdlb21ldHJ5KG1vdmVtZW50RGV0ZWN0aW9uLmRlbHRhKTtcblxuICAgICAgICBfdGhpcy51cGRhdGVHZXN0dXJlU3RhdGUobW92ZW1lbnREZXRlY3Rpb24pO1xuXG4gICAgICAgIF90aGlzLnVwZGF0ZUdlc3R1cmVTdGF0ZShnZW9tZXRyeSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpcy51cGRhdGVHZXN0dXJlU3RhdGUoX2V4dGVuZHMoe30sIGdldEdlbmVyaWNQYXlsb2FkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBldmVudCksIF90aGlzLmdldEtpbmVtYXRpY3ModmFsdWVzLCBldmVudCkpKTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuZmlyZUdlc3R1cmVIYW5kbGVyKCk7XG4gICAgfTtcblxuICAgIF90aGlzLm9uRW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuc3RhdGUuX2FjdGl2ZSA9IGZhbHNlO1xuXG4gICAgICBfdGhpcy51cGRhdGVHZXN0dXJlU3RhdGUoX2V4dGVuZHMoe30sIF90aGlzLmdldE1vdmVtZW50KF90aGlzLnN0YXRlLnZhbHVlcyksIHtcbiAgICAgICAgdmVsb2NpdGllczogWzAsIDBdLFxuICAgICAgICB2ZWxvY2l0eTogMFxuICAgICAgfSkpO1xuXG4gICAgICBfdGhpcy5maXJlR2VzdHVyZUhhbmRsZXIoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFNjcm9sbFJlY29nbml6ZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5hZGRCaW5kaW5ncyA9IGZ1bmN0aW9uIGFkZEJpbmRpbmdzJDEoYmluZGluZ3MpIHtcbiAgICBhZGRCaW5kaW5ncyhiaW5kaW5ncywgJ29uU2Nyb2xsJywgdGhpcy5oYW5kbGVFdmVudCk7XG4gIH07XG5cbiAgcmV0dXJuIFNjcm9sbFJlY29nbml6ZXI7XG59KENvb3JkaW5hdGVzUmVjb2duaXplcik7XG5cbi8qKlxyXG4gKiBTY3JvbGwgaG9vay5cclxuICpcclxuICogQHBhcmFtIGhhbmRsZXIgLSB0aGUgZnVuY3Rpb24gZmlyZWQgZXZlcnkgdGltZSB0aGUgc2Nyb2xsIGdlc3R1cmUgdXBkYXRlc1xyXG4gKiBAcGFyYW0gW2NvbmZpZz17fV0gLSB0aGUgY29uZmlnIG9iamVjdCBpbmNsdWRpbmcgZ2VuZXJpYyBvcHRpb25zIGFuZCBzY3JvbGwgb3B0aW9uc1xyXG4gKi9cblxuZnVuY3Rpb24gdXNlU2Nyb2xsKGhhbmRsZXIsIGNvbmZpZykge1xuICBpZiAoY29uZmlnID09PSB2b2lkIDApIHtcbiAgICBjb25maWcgPSB7fTtcbiAgfVxuXG4gIFJlY29nbml6ZXJzTWFwLnNldCgnc2Nyb2xsJywgU2Nyb2xsUmVjb2duaXplcik7XG4gIHZhciBidWlsZFNjcm9sbENvbmZpZyA9IHVzZVJlZigpO1xuXG4gIGlmICghYnVpbGRTY3JvbGxDb25maWcuY3VycmVudCkge1xuICAgIGJ1aWxkU2Nyb2xsQ29uZmlnLmN1cnJlbnQgPSBtZW1vaXplT25lKF9idWlsZFNjcm9sbENvbmZpZywgaXNFcXVhbCk7XG4gIH1cblxuICByZXR1cm4gdXNlUmVjb2duaXplcnMoe1xuICAgIHNjcm9sbDogaGFuZGxlclxuICB9LCBidWlsZFNjcm9sbENvbmZpZy5jdXJyZW50KGNvbmZpZykpO1xufVxuXG52YXIgUkVfTk9UX05BVElWRSA9IC9eb24oRHJhZ3xXaGVlbHxTY3JvbGx8TW92ZXxQaW5jaHxIb3ZlcikvO1xuXG5mdW5jdGlvbiBzb3J0SGFuZGxlcnMoaGFuZGxlcnMpIHtcbiAgdmFyIF9uYXRpdmUgPSB7fTtcbiAgdmFyIGhhbmRsZSA9IHt9O1xuICB2YXIgYWN0aW9ucyA9IG5ldyBTZXQoKTtcblxuICBmb3IgKHZhciBrZXkgaW4gaGFuZGxlcnMpIHtcbiAgICBpZiAoUkVfTk9UX05BVElWRS50ZXN0KGtleSkpIHtcbiAgICAgIGFjdGlvbnMuYWRkKFJlZ0V4cC5sYXN0TWF0Y2gpO1xuICAgICAgaGFuZGxlW2tleV0gPSBoYW5kbGVyc1trZXldO1xuICAgIH0gZWxzZSB7XG4gICAgICBfbmF0aXZlW2tleV0gPSBoYW5kbGVyc1trZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBbaGFuZGxlLCBfbmF0aXZlLCBhY3Rpb25zXTtcbn1cbi8qKlxyXG4gKiBAcHVibGljXHJcbiAqXHJcbiAqIFRoZSBtb3N0IGNvbXBsZXRlIGdlc3R1cmUgaG9vaywgYWxsb3dpbmcgc3VwcG9ydCBmb3IgbXVsdGlwbGUgZ2VzdHVyZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7SGFuZGxlcnN9IGhhbmRsZXJzIC0gYW4gb2JqZWN0IHdpdGggb25bR2VzdHVyZV0ga2V5cyBjb250YWluZyBnZXN0dXJlIGhhbmRsZXJzXHJcbiAqIEBwYXJhbSB7VXNlR2VzdHVyZUNvbmZpZ30gW2NvbmZpZz17fV0gLSB0aGUgZnVsbCBjb25maWcgb2JqZWN0XHJcbiAqIEByZXR1cm5zIHsoLi4uYXJnczogYW55W10pID0+IEhvb2tSZXR1cm5UeXBlPENvbmZpZz59XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHVzZUdlc3R1cmUoX2hhbmRsZXJzLCBjb25maWcpIHtcbiAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7XG4gICAgY29uZmlnID0ge307XG4gIH1cblxuICB2YXIgX3NvcnRIYW5kbGVycyA9IHNvcnRIYW5kbGVycyhfaGFuZGxlcnMpLFxuICAgICAgaGFuZGxlcnMgPSBfc29ydEhhbmRsZXJzWzBdLFxuICAgICAgbmF0aXZlSGFuZGxlcnMgPSBfc29ydEhhbmRsZXJzWzFdLFxuICAgICAgYWN0aW9ucyA9IF9zb3J0SGFuZGxlcnNbMl07XG5cbiAgUmVjb2duaXplcnNNYXAuc2V0KCdkcmFnJywgRHJhZ1JlY29nbml6ZXIpO1xuICBSZWNvZ25pemVyc01hcC5zZXQoJ2hvdmVyJywgTW92ZVJlY29nbml6ZXIpO1xuICBSZWNvZ25pemVyc01hcC5zZXQoJ21vdmUnLCBNb3ZlUmVjb2duaXplcik7XG4gIFJlY29nbml6ZXJzTWFwLnNldCgncGluY2gnLCBQaW5jaFJlY29nbml6ZXIpO1xuICBSZWNvZ25pemVyc01hcC5zZXQoJ3Njcm9sbCcsIFNjcm9sbFJlY29nbml6ZXIpO1xuICBSZWNvZ25pemVyc01hcC5zZXQoJ3doZWVsJywgV2hlZWxSZWNvZ25pemVyKTtcbiAgdmFyIG1lcmdlZENvbmZpZyA9IGJ1aWxkQ29tcGxleENvbmZpZyhjb25maWcsIGFjdGlvbnMpO1xuICB2YXIgaW50ZXJuYWxIYW5kbGVycyA9IHt9O1xuICBpZiAoYWN0aW9ucy5oYXMoJ29uRHJhZycpKSBpbnRlcm5hbEhhbmRsZXJzLmRyYWcgPSBpbmNsdWRlU3RhcnRFbmRIYW5kbGVycyhoYW5kbGVycywgJ29uRHJhZycpO1xuICBpZiAoYWN0aW9ucy5oYXMoJ29uV2hlZWwnKSkgaW50ZXJuYWxIYW5kbGVycy53aGVlbCA9IGluY2x1ZGVTdGFydEVuZEhhbmRsZXJzKGhhbmRsZXJzLCAnb25XaGVlbCcpO1xuICBpZiAoYWN0aW9ucy5oYXMoJ29uU2Nyb2xsJykpIGludGVybmFsSGFuZGxlcnMuc2Nyb2xsID0gaW5jbHVkZVN0YXJ0RW5kSGFuZGxlcnMoaGFuZGxlcnMsICdvblNjcm9sbCcpO1xuICBpZiAoYWN0aW9ucy5oYXMoJ29uTW92ZScpKSBpbnRlcm5hbEhhbmRsZXJzLm1vdmUgPSBpbmNsdWRlU3RhcnRFbmRIYW5kbGVycyhoYW5kbGVycywgJ29uTW92ZScpO1xuICBpZiAoYWN0aW9ucy5oYXMoJ29uUGluY2gnKSkgaW50ZXJuYWxIYW5kbGVycy5waW5jaCA9IGluY2x1ZGVTdGFydEVuZEhhbmRsZXJzKGhhbmRsZXJzLCAnb25QaW5jaCcpO1xuICBpZiAoYWN0aW9ucy5oYXMoJ29uSG92ZXInKSkgaW50ZXJuYWxIYW5kbGVycy5ob3ZlciA9IGhhbmRsZXJzLm9uSG92ZXI7XG4gIHJldHVybiB1c2VSZWNvZ25pemVycyhpbnRlcm5hbEhhbmRsZXJzLCBtZXJnZWRDb25maWcsIG5hdGl2ZUhhbmRsZXJzKTtcbn1cblxuZnVuY3Rpb24gaW5jbHVkZVN0YXJ0RW5kSGFuZGxlcnMoaGFuZGxlcnMsIGhhbmRsZXJLZXkpIHtcbiAgdmFyIHN0YXJ0S2V5ID0gaGFuZGxlcktleSArICdTdGFydCc7XG4gIHZhciBlbmRLZXkgPSBoYW5kbGVyS2V5ICsgJ0VuZCc7XG5cbiAgdmFyIGZuID0gZnVuY3Rpb24gZm4oc3RhdGUpIHtcbiAgICB2YXIgbWVtbyA9IHVuZGVmaW5lZDtcbiAgICBpZiAoc3RhdGUuZmlyc3QgJiYgc3RhcnRLZXkgaW4gaGFuZGxlcnMpIGhhbmRsZXJzW3N0YXJ0S2V5XShzdGF0ZSk7XG4gICAgaWYgKGhhbmRsZXJLZXkgaW4gaGFuZGxlcnMpIG1lbW8gPSBoYW5kbGVyc1toYW5kbGVyS2V5XShzdGF0ZSk7XG4gICAgaWYgKHN0YXRlLmxhc3QgJiYgZW5kS2V5IGluIGhhbmRsZXJzKSBoYW5kbGVyc1tlbmRLZXldKHN0YXRlKTtcbiAgICByZXR1cm4gbWVtbztcbiAgfTtcblxuICByZXR1cm4gZm47XG59XG5cbmV4cG9ydCB7IGFkZFYsIHJ1YmJlcmJhbmRJZk91dE9mQm91bmRzLCBzdWJWLCB1c2VEcmFnLCB1c2VHZXN0dXJlLCB1c2VIb3ZlciwgdXNlTW92ZSwgdXNlUGluY2gsIHVzZVNjcm9sbCwgdXNlV2hlZWwgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlYWN0LXVzZS1nZXN0dXJlLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZVJlZiIsImFkZFYiLCJ2MSIsInYyIiwibWFwIiwidiIsImkiLCJzdWJWIiwiY2FsY3VsYXRlRGlzdGFuY2UiLCJtb3ZlbWVudCIsIk1hdGgiLCJoeXBvdCIsImFwcGx5IiwiY2FsY3VsYXRlQWxsR2VvbWV0cnkiLCJkZWx0YSIsImRsIiwiYWxwaGEiLCJkaXJlY3Rpb24iLCJkaXN0YW5jZSIsImNhbGN1bGF0ZUFsbEtpbmVtYXRpY3MiLCJkdCIsImJldGEiLCJ2ZWxvY2l0eSIsInZlbG9jaXRpZXMiLCJzaWduIiwieCIsIk51bWJlciIsIm1pbk1heCIsInZhbHVlIiwibWluIiwibWF4IiwicnViYmVyYmFuZDIiLCJjb25zdGFudCIsInBvdyIsInJ1YmJlcmJhbmQiLCJkaW1lbnNpb24iLCJhYnMiLCJJbmZpbml0eSIsInJ1YmJlcmJhbmRJZk91dE9mQm91bmRzIiwicG9zaXRpb24iLCJfZGVmaW5lUHJvcGVydGllcyIsInRhcmdldCIsInByb3BzIiwibGVuZ3RoIiwiZGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5Iiwia2V5IiwiX2NyZWF0ZUNsYXNzIiwiQ29uc3RydWN0b3IiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJwcm90b3R5cGUiLCJfZXh0ZW5kcyIsImFzc2lnbiIsImFyZ3VtZW50cyIsInNvdXJjZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsIl9pbmhlcml0c0xvb3NlIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwiY3JlYXRlIiwiY29uc3RydWN0b3IiLCJfX3Byb3RvX18iLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsImV4Y2x1ZGVkIiwic291cmNlS2V5cyIsImtleXMiLCJpbmRleE9mIiwiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsInNlbGYiLCJSZWZlcmVuY2VFcnJvciIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIm8iLCJtaW5MZW4iLCJfYXJyYXlMaWtlVG9BcnJheSIsIm4iLCJ0b1N0cmluZyIsInNsaWNlIiwibmFtZSIsIkFycmF5IiwiZnJvbSIsInRlc3QiLCJhcnIiLCJsZW4iLCJhcnIyIiwiX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZSIsImFsbG93QXJyYXlMaWtlIiwiaXQiLCJTeW1ib2wiLCJpdGVyYXRvciIsImlzQXJyYXkiLCJkb25lIiwiVHlwZUVycm9yIiwibmV4dCIsImJpbmQiLCJub29wIiwiY2hhaW5GbnMiLCJfbGVuIiwiZm5zIiwiX2tleSIsInJlc3VsdCIsIl9pdGVyYXRvciIsIl9zdGVwIiwiZm4iLCJlbnN1cmVWZWN0b3IiLCJmYWxsYmFjayIsInVuZGVmaW5lZCIsIkVycm9yIiwiYXNzaWduRGVmYXVsdCIsInZhbHVlRm4iLCJfbGVuMiIsImFyZ3MiLCJfa2V5MiIsInJlc29sdmVXaXRoIiwiY29uZmlnIiwicmVzb2x2ZXJzIiwiX2kiLCJfT2JqZWN0JGVudHJpZXMiLCJlbnRyaWVzIiwiX09iamVjdCRlbnRyaWVzJF9pIiwicmVzb2x2ZXIiLCJERUZBVUxUX0RSQUdfREVMQVkiLCJERUZBVUxUX1JVQkJFUkJBTkQiLCJERUZBVUxUX1NXSVBFX1ZFTE9DSVRZIiwiREVGQVVMVF9TV0lQRV9ESVNUQU5DRSIsIkludGVybmFsR2VzdHVyZU9wdGlvbnNOb3JtYWxpemVycyIsInRocmVzaG9sZCIsImVuYWJsZWQiLCJ0cmlnZ2VyQWxsRXZlbnRzIiwiaW5pdGlhbCIsIkludGVybmFsQ29vcmRpbmF0ZXNPcHRpb25zTm9ybWFsaXplcnMiLCJheGlzIiwibG9ja0RpcmVjdGlvbiIsImJvdW5kcyIsInN0YXRlIiwiX3ZhbHVlMiIsIl92YWx1ZTIkbGVmdCIsImxlZnQiLCJfdmFsdWUyJHJpZ2h0IiwicmlnaHQiLCJfdmFsdWUyJHRvcCIsInRvcCIsIl92YWx1ZTIkYm90dG9tIiwiYm90dG9tIiwiaXNCcm93c2VyIiwid2luZG93IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiSW50ZXJuYWxHZW5lcmljT3B0aW9uc05vcm1hbGl6ZXJzIiwiZG9tVGFyZ2V0IiwiX3dpbmRvdyIsIl94IiwiZXZlbnRPcHRpb25zIiwiX3RlbXAiLCJfcmVmIiwiX3JlZiRwYXNzaXZlIiwicGFzc2l2ZSIsIl9yZWYkY2FwdHVyZSIsImNhcHR1cmUiLCJJbnRlcm5hbERpc3RhbmNlQW5nbGVPcHRpb25zTm9ybWFsaXplcnMiLCJfdmFsdWUiLCJfcmVmMiIsIl9yZWYyJGRpc3RhbmNlQm91bmRzIiwiZGlzdGFuY2VCb3VuZHMiLCJfcmVmMiRhbmdsZUJvdW5kcyIsImFuZ2xlQm91bmRzIiwiX2Rpc3RhbmNlQm91bmRzIiwiRCIsIl9hbmdsZUJvdW5kcyIsIkEiLCJJbnRlcm5hbERyYWdPcHRpb25zTm9ybWFsaXplcnMiLCJfayIsIl9yZWYzIiwiX3JlZjMkZmlsdGVyVGFwcyIsImZpbHRlclRhcHMiLCJfcmVmMyRsb2NrRGlyZWN0aW9uIiwiX3JlZjMkYXhpcyIsInN3aXBlVmVsb2NpdHkiLCJzd2lwZURpc3RhbmNlIiwiZGVsYXkiLCJnZXRJbnRlcm5hbEdlbmVyaWNPcHRpb25zIiwiZ2V0SW50ZXJuYWxDb29yZGluYXRlc09wdGlvbnMiLCJnZXRJbnRlcm5hbERpc3RhbmNlQW5nbGVPcHRpb25zIiwiZ2V0SW50ZXJuYWxEcmFnT3B0aW9ucyIsIl9idWlsZE1vdmVDb25maWciLCJyZXN0Iiwib3B0cyIsIm1vdmUiLCJfYnVpbGRIb3ZlckNvbmZpZyIsImhvdmVyIiwiX2J1aWxkRHJhZ0NvbmZpZyIsImRyYWciLCJfYnVpbGRQaW5jaENvbmZpZyIsIl9yZWY0IiwicGluY2giLCJfYnVpbGRTY3JvbGxDb25maWciLCJfcmVmNSIsInNjcm9sbCIsIl9idWlsZFdoZWVsQ29uZmlnIiwiX3JlZjYiLCJ3aGVlbCIsImJ1aWxkQ29tcGxleENvbmZpZyIsImFjdGlvbnMiLCJTZXQiLCJfY29uZmlnIiwibWVyZ2VkQ29uZmlnIiwiaGFzIiwiZ2V0SW5pdGlhbCIsIm1peGVkIiwiX2FjdGl2ZSIsIl9ibG9ja2VkIiwiX2ludGVudGlvbmFsIiwiX21vdmVtZW50IiwiX2luaXRpYWwiLCJfYm91bmRzIiwiX2xhc3RFdmVudFR5cGUiLCJldmVudCIsImludGVudGlvbmFsIiwidmFsdWVzIiwib2Zmc2V0IiwibGFzdE9mZnNldCIsInByZXZpb3VzIiwiZmlyc3QiLCJsYXN0IiwiYWN0aXZlIiwidGltZVN0YW1wIiwic3RhcnRUaW1lIiwiZWxhcHNlZFRpbWUiLCJjYW5jZWwiLCJjYW5jZWxlZCIsIm1lbW8iLCJnZXRJbml0aWFsU3RhdGUiLCJzaGFyZWQiLCJob3ZlcmluZyIsInNjcm9sbGluZyIsIndoZWVsaW5nIiwiZHJhZ2dpbmciLCJtb3ZpbmciLCJwaW5jaGluZyIsInRvdWNoZXMiLCJidXR0b25zIiwiZG93biIsInNoaWZ0S2V5IiwiYWx0S2V5IiwibWV0YUtleSIsImN0cmxLZXkiLCJ4eSIsInZ4dnkiLCJfaXNUYXAiLCJfZGVsYXllZEV2ZW50IiwiX3BvaW50ZXJJZCIsInRhcCIsInN3aXBlIiwiZGEiLCJ2ZHZhIiwib3JpZ2luIiwidHVybnMiLCJSZWNvZ25pemVyc01hcCIsIk1hcCIsIlJlY29nbml6ZXIiLCJjb250cm9sbGVyIiwiX3RoaXMiLCJkZWJvdW5jZWQiLCJzZXRUaW1lb3V0IiwiY2FsbGJhY2siLCJtcyIsImNsZWFyVGltZW91dCIsInRpbWVvdXRzIiwic3RhdGVLZXkiLCJjb25jYXQiLCJmaXJlR2VzdHVyZUhhbmRsZXIiLCJmb3JjZUZsYWciLCJjbGVhbiIsInByZXZfYWN0aXZlIiwibmV4dF9hY3RpdmUiLCJpbmdLZXkiLCJtYXBTdGF0ZVZhbHVlcyIsIm5ld01lbW8iLCJoYW5kbGVyIiwiX3Byb3RvIiwidXBkYXRlU2hhcmVkU3RhdGUiLCJzaGFyZWRTdGF0ZSIsInVwZGF0ZUdlc3R1cmVTdGF0ZSIsImdlc3R1cmVTdGF0ZSIsImNoZWNrSW50ZW50aW9uYWxpdHkiLCJnZXRNb3ZlbWVudCIsIl90aGlzJGNvbmZpZyIsIlQiLCJfdGhpcyRzdGF0ZSIsIndhc0ludGVudGlvbmFsIiwicHJldk1vdmVtZW50IiwiTSIsImdldEludGVybmFsTW92ZW1lbnQiLCJpMCIsImdldEludGVudGlvbmFsRGlzcGxhY2VtZW50IiwiaTEiLCJpbnRlbnRpb25hbGl0eUNoZWNrIiwiX19jYWNoZWRCb3VuZHMiLCJfX2NhY2hlZEluaXRpYWwiLCJfY2FjaGVkSW5pdGlhbCIsIl9jYWNoZWRCb3VuZHMiLCJfcnViYmVyYmFuZCIsImNvbXB1dGVSdWJiZXJiYW5kIiwiZ2V0IiwiaGFuZGxlcnMiLCJWeCIsIlZ5IiwiUngiLCJSeSIsIl9ib3VuZHMkIiwiWDEiLCJYMiIsIl9ib3VuZHMkMiIsIlkxIiwiWTIiLCJnZXRHZW5lcmljUGF5bG9hZCIsImlzU3RhcnRFdmVudCIsInR5cGUiLCJnZXRTdGFydEdlc3R1cmVTdGF0ZSIsInJlY29nbml6ZXIiLCJwYXJ0aWFsIiwiZnVuYyIsIkNvbnRyb2xsZXIiLCJjbGFzc2VzIiwiYmluZGluZ3MiLCJSZWNvZ25pemVyQ2xhc3MiLCJhZGRCaW5kaW5ncyIsIm5hdGl2ZVJlZnMiLCJ1cGRhdGVEb21MaXN0ZW5lcnMiLCJnZXRQcm9wc0xpc3RlbmVyIiwiZWZmZWN0IiwiZ2V0RG9tVGFyZ2V0RnJvbUNvbmZpZyIsInJlbW92ZUxpc3RlbmVycyIsInRha2VBbGwiLCJkb21MaXN0ZW5lcnMiLCJmb3JFYWNoIiwiY2xlYXJBbGxXaW5kb3dMaXN0ZW5lcnMiLCJ3aW5kb3dMaXN0ZW5lcnMiLCJfY29udHJvbGxlciRjb25maWciLCJlbCIsImNsZWFyV2luZG93TGlzdGVuZXJzIiwidXBkYXRlV2luZG93TGlzdGVuZXJzIiwibGlzdGVuZXJzIiwiYWRkTGlzdGVuZXJzIiwiX2kyIiwiX09iamVjdCRlbnRyaWVzMiIsIl9PYmplY3QkZW50cmllczIkX2kiLCJ0b0xvd2VyQ2FzZSIsInB1c2giLCJjYXB0dXJlU3RyaW5nIiwiX2kzIiwiX09iamVjdCRlbnRyaWVzMyIsIl9PYmplY3QkZW50cmllczMkX2kiLCJmbnNBcnJheSIsImFycmF5Iiwic3BsaWNlIiwiY3VycmVudCIsIm9wdGlvbnMiLCJfaXRlcmF0b3IyIiwiX3N0ZXAyIiwiX3N0ZXAyJHZhbHVlIiwiZXZlbnROYW1lIiwiZXZlbnRIYW5kbGVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsIl9pdGVyYXRvcjMiLCJfc3RlcDMiLCJfc3RlcDMkdmFsdWUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwidXNlUmVjb2duaXplcnMiLCJuYXRpdmVIYW5kbGVycyIsInJlc29sdmVDbGFzc2VzIiwidXNlTWVtbyIsInVzZUVmZmVjdCIsImRlcHJlY2F0aW9uTm90aWNlRm9yRG9tVGFyZ2V0IiwicHJvY2VzcyIsImNvbnNvbGUiLCJ3YXJuIiwiaW50ZXJuYWxIYW5kbGVycyIsImFkZCIsIkNvb3JkaW5hdGVzUmVjb2duaXplciIsIl9SZWNvZ25pemVyIiwiX21vdmVtZW50JG1hcCIsImFic1giLCJhYnNZIiwiZ2V0S2luZW1hdGljcyIsIldFQktJVF9ESVNUQU5DRV9TQ0FMRV9GQUNUT1IiLCJzdXBwb3J0c0dlc3R1cmVFdmVudHMiLCJHZXN0dXJlRXZlbnQiLCJlIiwic3VwcG9ydHNUb3VjaEV2ZW50cyIsIm9udG91Y2hzdGFydCIsImdldFRvdWNoRXZlbnRzIiwidGFyZ2V0VG91Y2hlcyIsImNoYW5nZWRUb3VjaGVzIiwiZ2V0R2VuZXJpY0V2ZW50RGF0YSIsInRvdWNoRXZlbnRzIiwiZ2V0UG9pbnRlckV2ZW50VmFsdWVzIiwiY2xpZW50WCIsImNsaWVudFkiLCJnZXRTY3JvbGxFdmVudFZhbHVlcyIsIl9ldmVudCRjdXJyZW50VGFyZ2V0IiwiY3VycmVudFRhcmdldCIsInNjcm9sbFgiLCJzY3JvbGxZIiwic2Nyb2xsTGVmdCIsInNjcm9sbFRvcCIsImdldFdoZWVsRXZlbnRWYWx1ZXMiLCJkZWx0YVgiLCJkZWx0YVkiLCJnZXRXZWJraXRHZXN0dXJlRXZlbnRWYWx1ZXMiLCJzY2FsZSIsInJvdGF0aW9uIiwiZ2V0VHdvVG91Y2hlc0V2ZW50RGF0YSIsIl9lJHJvdGF0aW9uIiwiQiIsImR4IiwiZHkiLCJjeCIsImN5IiwibmF0aXZlRXZlbnQiLCJhbmdsZSIsImF0YW4yIiwiUEkiLCJUQVBfRElTVEFOQ0VfVEhSRVNIT0xEIiwiU1dJUEVfTUFYX0VMQVBTRURfVElNRSIsIkRyYWdSZWNvZ25pemVyIiwiX0Nvb3JkaW5hdGVzUmVjb2duaXplIiwib25EcmFnU3RhcnQiLCJvbkRyYWdDaGFuZ2UiLCJvbkRyYWdFbmQiLCJwb2ludGVySWQiLCJwZXJzaXN0Iiwic3RhcnREcmFnIiwiZ2VuZXJpY0V2ZW50RGF0YSIsImtpbmVtYXRpY3MiLCJnZW5lcmljUGF5bG9hZCIsInJlYWxEaXN0YW5jZSIsIl90aGlzJHN0YXRlJHZlbG9jaXRpZSIsInZ4IiwidnkiLCJfdGhpcyRzdGF0ZSRtb3ZlbWVudCIsIm14IiwibXkiLCJfdGhpcyRzdGF0ZSRfaW50ZW50aW8iLCJpeCIsIml5IiwiX3RoaXMkY29uZmlnJHN3aXBlVmVsIiwic3Z4Iiwic3Z5IiwiX3RoaXMkY29uZmlnJHN3aXBlRGlzIiwic3giLCJzeSIsImVuZFN0YXRlIiwib25DYW5jZWwiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJvbkNsaWNrIiwic3RvcFByb3BhZ2F0aW9uIiwiYWRkQmluZGluZ3MkMSIsIm1lbW9pemVPbmUiLCJyZXN1bHRGbiIsImlzRXF1YWwiLCJsYXN0VGhpcyIsImxhc3RBcmdzIiwibGFzdFJlc3VsdCIsImNhbGxlZE9uY2UiLCJtZW1vaXplZCIsIm5ld0FyZ3MiLCJlcXVhbCIsImEiLCJiIiwic2l6ZSIsIlJlZ0V4cCIsImZsYWdzIiwidmFsdWVPZiIsIkVsZW1lbnQiLCIkJHR5cGVvZiIsImVycm9yIiwibWVzc2FnZSIsIm1hdGNoIiwidXNlRHJhZyIsInNldCIsImJ1aWxkRHJhZ0NvbmZpZyIsIkRpc3RhbmNlQW5nbGVSZWNvZ25pemVyIiwicHJldl9hIiwiZCIsIl92YWx1ZXMkIiwiZGVsdGFfYSIsIm5leHRfdHVybnMiLCJQaW5jaFJlY29nbml6ZXIiLCJfRGlzdGFuY2VBbmdsZVJlY29nbmkiLCJwaW5jaFNob3VsZFN0YXJ0IiwiX2dldEdlbmVyaWNFdmVudERhdGEiLCJvblBpbmNoU3RhcnQiLCJfZ2V0VHdvVG91Y2hlc0V2ZW50RGEiLCJvblBpbmNoQ2hhbmdlIiwiX2dldFR3b1RvdWNoZXNFdmVudERhMiIsIm9uUGluY2hFbmQiLCJvbkdlc3R1cmVTdGFydCIsInByZXZlbnREZWZhdWx0Iiwib25HZXN0dXJlQ2hhbmdlIiwiX3RoaXMkc3RhdGUyIiwib25HZXN0dXJlRW5kIiwid2hlZWxTaG91bGRSdW4iLCJnZXRXaGVlbFZhbHVlc0Zyb21FdmVudCIsIl9nZXRXaGVlbEV2ZW50VmFsdWVzIiwiZGVsdGFfZCIsIl90aGlzJHN0YXRlJHZhbHVlcyIsInByZXZfZCIsIm9uV2hlZWwiLCJvbldoZWVsRW5kIiwib25XaGVlbFN0YXJ0Iiwib25XaGVlbENoYW5nZSIsIl90aGlzJGdldFdoZWVsVmFsdWVzRiIsImNhbmNlbGFibGUiLCJfdGhpcyRnZXRXaGVlbFZhbHVlc0YyIiwidXNlUGluY2giLCJidWlsZFBpbmNoQ29uZmlnIiwiV2hlZWxSZWNvZ25pemVyIiwiaGFuZGxlRXZlbnQiLCJvbkVuZCIsImdlb21ldHJ5IiwidXNlV2hlZWwiLCJidWlsZFdoZWVsQ29uZmlnIiwiTW92ZVJlY29nbml6ZXIiLCJvbk1vdmUiLCJvbk1vdmVFbmQiLCJvbk1vdmVTdGFydCIsIm9uTW92ZUNoYW5nZSIsIm9uUG9pbnRlckVudGVyIiwib25Qb2ludGVyTGVhdmUiLCJ1c2VNb3ZlIiwiYnVpbGRNb3ZlQ29uZmlnIiwidXNlSG92ZXIiLCJidWlsZEhvdmVyQ29uZmlnIiwiU2Nyb2xsUmVjb2duaXplciIsIm1vdmVtZW50RGV0ZWN0aW9uIiwidXNlU2Nyb2xsIiwiYnVpbGRTY3JvbGxDb25maWciLCJSRV9OT1RfTkFUSVZFIiwic29ydEhhbmRsZXJzIiwiX25hdGl2ZSIsImhhbmRsZSIsImxhc3RNYXRjaCIsInVzZUdlc3R1cmUiLCJfaGFuZGxlcnMiLCJfc29ydEhhbmRsZXJzIiwiaW5jbHVkZVN0YXJ0RW5kSGFuZGxlcnMiLCJvbkhvdmVyIiwiaGFuZGxlcktleSIsInN0YXJ0S2V5IiwiZW5kS2V5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-use-gesture/dist/react-use-gesture.esm.js\n");

/***/ })

};
;