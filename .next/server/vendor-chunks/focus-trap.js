"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/focus-trap";
exports.ids = ["vendor-chunks/focus-trap"];
exports.modules = {

/***/ "(ssr)/./node_modules/focus-trap/dist/focus-trap.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/focus-trap/dist/focus-trap.esm.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createFocusTrap: () => (/* binding */ createFocusTrap)\n/* harmony export */ });\n/* harmony import */ var tabbable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tabbable */ \"(ssr)/./node_modules/tabbable/dist/index.esm.js\");\n/*!\n* focus-trap 6.9.4\n* @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE\n*/ \nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        enumerableOnly && (symbols = symbols.filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        })), keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread2(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = null != arguments[i] ? arguments[i] : {};\n        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n    }\n    return target;\n}\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nvar activeFocusTraps = function() {\n    var trapQueue = [];\n    return {\n        activateTrap: function activateTrap(trap) {\n            if (trapQueue.length > 0) {\n                var activeTrap = trapQueue[trapQueue.length - 1];\n                if (activeTrap !== trap) {\n                    activeTrap.pause();\n                }\n            }\n            var trapIndex = trapQueue.indexOf(trap);\n            if (trapIndex === -1) {\n                trapQueue.push(trap);\n            } else {\n                // move this existing trap to the front of the queue\n                trapQueue.splice(trapIndex, 1);\n                trapQueue.push(trap);\n            }\n        },\n        deactivateTrap: function deactivateTrap(trap) {\n            var trapIndex = trapQueue.indexOf(trap);\n            if (trapIndex !== -1) {\n                trapQueue.splice(trapIndex, 1);\n            }\n            if (trapQueue.length > 0) {\n                trapQueue[trapQueue.length - 1].unpause();\n            }\n        }\n    };\n}();\nvar isSelectableInput = function isSelectableInput(node) {\n    return node.tagName && node.tagName.toLowerCase() === \"input\" && typeof node.select === \"function\";\n};\nvar isEscapeEvent = function isEscapeEvent(e) {\n    return e.key === \"Escape\" || e.key === \"Esc\" || e.keyCode === 27;\n};\nvar isTabEvent = function isTabEvent(e) {\n    return e.key === \"Tab\" || e.keyCode === 9;\n};\nvar delay = function delay(fn) {\n    return setTimeout(fn, 0);\n}; // Array.find/findIndex() are not supported on IE; this replicates enough\n//  of Array.findIndex() for our needs\nvar findIndex = function findIndex(arr, fn) {\n    var idx = -1;\n    arr.every(function(value, i) {\n        if (fn(value)) {\n            idx = i;\n            return false; // break\n        }\n        return true; // next\n    });\n    return idx;\n};\n/**\n * Get an option's value when it could be a plain value, or a handler that provides\n *  the value.\n * @param {*} value Option's value to check.\n * @param {...*} [params] Any parameters to pass to the handler, if `value` is a function.\n * @returns {*} The `value`, or the handler's returned value.\n */ var valueOrHandler = function valueOrHandler(value) {\n    for(var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        params[_key - 1] = arguments[_key];\n    }\n    return typeof value === \"function\" ? value.apply(void 0, params) : value;\n};\nvar getActualTarget = function getActualTarget(event) {\n    // NOTE: If the trap is _inside_ a shadow DOM, event.target will always be the\n    //  shadow host. However, event.target.composedPath() will be an array of\n    //  nodes \"clicked\" from inner-most (the actual element inside the shadow) to\n    //  outer-most (the host HTML document). If we have access to composedPath(),\n    //  then use its first element; otherwise, fall back to event.target (and\n    //  this only works for an _open_ shadow DOM; otherwise,\n    //  composedPath()[0] === event.target always).\n    return event.target.shadowRoot && typeof event.composedPath === \"function\" ? event.composedPath()[0] : event.target;\n};\nvar createFocusTrap = function createFocusTrap(elements, userOptions) {\n    // SSR: a live trap shouldn't be created in this type of environment so this\n    //  should be safe code to execute if the `document` option isn't specified\n    var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;\n    var config = _objectSpread2({\n        returnFocusOnDeactivate: true,\n        escapeDeactivates: true,\n        delayInitialFocus: true\n    }, userOptions);\n    var state = {\n        // containers given to createFocusTrap()\n        // @type {Array<HTMLElement>}\n        containers: [],\n        // list of objects identifying tabbable nodes in `containers` in the trap\n        // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap\n        //  is active, but the trap should never get to a state where there isn't at least one group\n        //  with at least one tabbable node in it (that would lead to an error condition that would\n        //  result in an error being thrown)\n        // @type {Array<{\n        //   container: HTMLElement,\n        //   tabbableNodes: Array<HTMLElement>, // empty if none\n        //   focusableNodes: Array<HTMLElement>, // empty if none\n        //   firstTabbableNode: HTMLElement|null,\n        //   lastTabbableNode: HTMLElement|null,\n        //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined\n        // }>}\n        containerGroups: [],\n        // same order/length as `containers` list\n        // references to objects in `containerGroups`, but only those that actually have\n        //  tabbable nodes in them\n        // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__\n        //  the same length\n        tabbableGroups: [],\n        nodeFocusedBeforeActivation: null,\n        mostRecentlyFocusedNode: null,\n        active: false,\n        paused: false,\n        // timer ID for when delayInitialFocus is true and initial focus in this trap\n        //  has been delayed during activation\n        delayInitialFocusTimer: undefined\n    };\n    var trap; // eslint-disable-line prefer-const -- some private functions reference it, and its methods reference private functions, so we must declare here and define later\n    /**\n   * Gets a configuration option value.\n   * @param {Object|undefined} configOverrideOptions If true, and option is defined in this set,\n   *  value will be taken from this object. Otherwise, value will be taken from base configuration.\n   * @param {string} optionName Name of the option whose value is sought.\n   * @param {string|undefined} [configOptionName] Name of option to use __instead of__ `optionName`\n   *  IIF `configOverrideOptions` is not defined. Otherwise, `optionName` is used.\n   */ var getOption = function getOption(configOverrideOptions, optionName, configOptionName) {\n        return configOverrideOptions && configOverrideOptions[optionName] !== undefined ? configOverrideOptions[optionName] : config[configOptionName || optionName];\n    };\n    /**\n   * Finds the index of the container that contains the element.\n   * @param {HTMLElement} element\n   * @returns {number} Index of the container in either `state.containers` or\n   *  `state.containerGroups` (the order/length of these lists are the same); -1\n   *  if the element isn't found.\n   */ var findContainerIndex = function findContainerIndex(element) {\n        // NOTE: search `containerGroups` because it's possible a group contains no tabbable\n        //  nodes, but still contains focusable nodes (e.g. if they all have `tabindex=-1`)\n        //  and we still need to find the element in there\n        return state.containerGroups.findIndex(function(_ref) {\n            var container = _ref.container, tabbableNodes = _ref.tabbableNodes;\n            return container.contains(element) || // fall back to explicit tabbable search which will take into consideration any\n            //  web components if the `tabbableOptions.getShadowRoot` option was used for\n            //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't\n            //  look inside web components even if open)\n            tabbableNodes.find(function(node) {\n                return node === element;\n            });\n        });\n    };\n    /**\n   * Gets the node for the given option, which is expected to be an option that\n   *  can be either a DOM node, a string that is a selector to get a node, `false`\n   *  (if a node is explicitly NOT given), or a function that returns any of these\n   *  values.\n   * @param {string} optionName\n   * @returns {undefined | false | HTMLElement | SVGElement} Returns\n   *  `undefined` if the option is not specified; `false` if the option\n   *  resolved to `false` (node explicitly not given); otherwise, the resolved\n   *  DOM node.\n   * @throws {Error} If the option is set, not `false`, and is not, or does not\n   *  resolve to a node.\n   */ var getNodeForOption = function getNodeForOption(optionName) {\n        var optionValue = config[optionName];\n        if (typeof optionValue === \"function\") {\n            for(var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                params[_key2 - 1] = arguments[_key2];\n            }\n            optionValue = optionValue.apply(void 0, params);\n        }\n        if (optionValue === true) {\n            optionValue = undefined; // use default value\n        }\n        if (!optionValue) {\n            if (optionValue === undefined || optionValue === false) {\n                return optionValue;\n            } // else, empty string (invalid), null (invalid), 0 (invalid)\n            throw new Error(\"`\".concat(optionName, \"` was specified but was not a node, or did not return a node\"));\n        }\n        var node = optionValue; // could be HTMLElement, SVGElement, or non-empty string at this point\n        if (typeof optionValue === \"string\") {\n            node = doc.querySelector(optionValue); // resolve to node, or null if fails\n            if (!node) {\n                throw new Error(\"`\".concat(optionName, \"` as selector refers to no known node\"));\n            }\n        }\n        return node;\n    };\n    var getInitialFocusNode = function getInitialFocusNode() {\n        var node = getNodeForOption(\"initialFocus\"); // false explicitly indicates we want no initialFocus at all\n        if (node === false) {\n            return false;\n        }\n        if (node === undefined) {\n            // option not specified: use fallback options\n            if (findContainerIndex(doc.activeElement) >= 0) {\n                node = doc.activeElement;\n            } else {\n                var firstTabbableGroup = state.tabbableGroups[0];\n                var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode; // NOTE: `fallbackFocus` option function cannot return `false` (not supported)\n                node = firstTabbableNode || getNodeForOption(\"fallbackFocus\");\n            }\n        }\n        if (!node) {\n            throw new Error(\"Your focus-trap needs to have at least one focusable element\");\n        }\n        return node;\n    };\n    var updateTabbableNodes = function updateTabbableNodes() {\n        state.containerGroups = state.containers.map(function(container) {\n            var tabbableNodes = (0,tabbable__WEBPACK_IMPORTED_MODULE_0__.tabbable)(container, config.tabbableOptions); // NOTE: if we have tabbable nodes, we must have focusable nodes; focusable nodes\n            //  are a superset of tabbable nodes\n            var focusableNodes = (0,tabbable__WEBPACK_IMPORTED_MODULE_0__.focusable)(container, config.tabbableOptions);\n            return {\n                container: container,\n                tabbableNodes: tabbableNodes,\n                focusableNodes: focusableNodes,\n                firstTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[0] : null,\n                lastTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : null,\n                /**\n         * Finds the __tabbable__ node that follows the given node in the specified direction,\n         *  in this container, if any.\n         * @param {HTMLElement} node\n         * @param {boolean} [forward] True if going in forward tab order; false if going\n         *  in reverse.\n         * @returns {HTMLElement|undefined} The next tabbable node, if any.\n         */ nextTabbableNode: function nextTabbableNode(node) {\n                    var forward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n                    // NOTE: If tabindex is positive (in order to manipulate the tab order separate\n                    //  from the DOM order), this __will not work__ because the list of focusableNodes,\n                    //  while it contains tabbable nodes, does not sort its nodes in any order other\n                    //  than DOM order, because it can't: Where would you place focusable (but not\n                    //  tabbable) nodes in that order? They have no order, because they aren't tabbale...\n                    // Support for positive tabindex is already broken and hard to manage (possibly\n                    //  not supportable, TBD), so this isn't going to make things worse than they\n                    //  already are, and at least makes things better for the majority of cases where\n                    //  tabindex is either 0/unset or negative.\n                    // FYI, positive tabindex issue: https://github.com/focus-trap/focus-trap/issues/375\n                    var nodeIdx = focusableNodes.findIndex(function(n) {\n                        return n === node;\n                    });\n                    if (nodeIdx < 0) {\n                        return undefined;\n                    }\n                    if (forward) {\n                        return focusableNodes.slice(nodeIdx + 1).find(function(n) {\n                            return (0,tabbable__WEBPACK_IMPORTED_MODULE_0__.isTabbable)(n, config.tabbableOptions);\n                        });\n                    }\n                    return focusableNodes.slice(0, nodeIdx).reverse().find(function(n) {\n                        return (0,tabbable__WEBPACK_IMPORTED_MODULE_0__.isTabbable)(n, config.tabbableOptions);\n                    });\n                }\n            };\n        });\n        state.tabbableGroups = state.containerGroups.filter(function(group) {\n            return group.tabbableNodes.length > 0;\n        }); // throw if no groups have tabbable nodes and we don't have a fallback focus node either\n        if (state.tabbableGroups.length <= 0 && !getNodeForOption(\"fallbackFocus\") // returning false not supported for this option\n        ) {\n            throw new Error(\"Your focus-trap must have at least one container with at least one tabbable node in it at all times\");\n        }\n    };\n    var tryFocus = function tryFocus(node) {\n        if (node === false) {\n            return;\n        }\n        if (node === doc.activeElement) {\n            return;\n        }\n        if (!node || !node.focus) {\n            tryFocus(getInitialFocusNode());\n            return;\n        }\n        node.focus({\n            preventScroll: !!config.preventScroll\n        });\n        state.mostRecentlyFocusedNode = node;\n        if (isSelectableInput(node)) {\n            node.select();\n        }\n    };\n    var getReturnFocusNode = function getReturnFocusNode(previousActiveElement) {\n        var node = getNodeForOption(\"setReturnFocus\", previousActiveElement);\n        return node ? node : node === false ? false : previousActiveElement;\n    }; // This needs to be done on mousedown and touchstart instead of click\n    // so that it precedes the focus event.\n    var checkPointerDown = function checkPointerDown(e) {\n        var target = getActualTarget(e);\n        if (findContainerIndex(target) >= 0) {\n            // allow the click since it ocurred inside the trap\n            return;\n        }\n        if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n            // immediately deactivate the trap\n            trap.deactivate({\n                // if, on deactivation, we should return focus to the node originally-focused\n                //  when the trap was activated (or the configured `setReturnFocus` node),\n                //  then assume it's also OK to return focus to the outside node that was\n                //  just clicked, causing deactivation, as long as that node is focusable;\n                //  if it isn't focusable, then return focus to the original node focused\n                //  on activation (or the configured `setReturnFocus` node)\n                // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,\n                //  which will result in the outside click setting focus to the node\n                //  that was clicked, whether it's focusable or not; by setting\n                //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused\n                //  on activation (or the configured `setReturnFocus` node)\n                returnFocus: config.returnFocusOnDeactivate && !(0,tabbable__WEBPACK_IMPORTED_MODULE_0__.isFocusable)(target, config.tabbableOptions)\n            });\n            return;\n        } // This is needed for mobile devices.\n        // (If we'll only let `click` events through,\n        // then on mobile they will be blocked anyways if `touchstart` is blocked.)\n        if (valueOrHandler(config.allowOutsideClick, e)) {\n            // allow the click outside the trap to take place\n            return;\n        } // otherwise, prevent the click\n        e.preventDefault();\n    }; // In case focus escapes the trap for some strange reason, pull it back in.\n    var checkFocusIn = function checkFocusIn(e) {\n        var target = getActualTarget(e);\n        var targetContained = findContainerIndex(target) >= 0; // In Firefox when you Tab out of an iframe the Document is briefly focused.\n        if (targetContained || target instanceof Document) {\n            if (targetContained) {\n                state.mostRecentlyFocusedNode = target;\n            }\n        } else {\n            // escaped! pull it back in to where it just left\n            e.stopImmediatePropagation();\n            tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());\n        }\n    }; // Hijack Tab events on the first and last focusable nodes of the trap,\n    // in order to prevent focus from escaping. If it escapes for even a\n    // moment it can end up scrolling the page and causing confusion so we\n    // kind of need to capture the action at the keydown phase.\n    var checkTab = function checkTab(e) {\n        var target = getActualTarget(e);\n        updateTabbableNodes();\n        var destinationNode = null;\n        if (state.tabbableGroups.length > 0) {\n            // make sure the target is actually contained in a group\n            // NOTE: the target may also be the container itself if it's focusable\n            //  with tabIndex='-1' and was given initial focus\n            var containerIndex = findContainerIndex(target);\n            var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : undefined;\n            if (containerIndex < 0) {\n                // target not found in any group: quite possible focus has escaped the trap,\n                //  so bring it back in to...\n                if (e.shiftKey) {\n                    // ...the last node in the last group\n                    destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;\n                } else {\n                    // ...the first node in the first group\n                    destinationNode = state.tabbableGroups[0].firstTabbableNode;\n                }\n            } else if (e.shiftKey) {\n                // REVERSE\n                // is the target the first tabbable node in a group?\n                var startOfGroupIndex = findIndex(state.tabbableGroups, function(_ref2) {\n                    var firstTabbableNode = _ref2.firstTabbableNode;\n                    return target === firstTabbableNode;\n                });\n                if (startOfGroupIndex < 0 && (containerGroup.container === target || (0,tabbable__WEBPACK_IMPORTED_MODULE_0__.isFocusable)(target, config.tabbableOptions) && !(0,tabbable__WEBPACK_IMPORTED_MODULE_0__.isTabbable)(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {\n                    // an exception case where the target is either the container itself, or\n                    //  a non-tabbable node that was given focus (i.e. tabindex is negative\n                    //  and user clicked on it or node was programmatically given focus)\n                    //  and is not followed by any other tabbable node, in which\n                    //  case, we should handle shift+tab as if focus were on the container's\n                    //  first tabbable node, and go to the last tabbable node of the LAST group\n                    startOfGroupIndex = containerIndex;\n                }\n                if (startOfGroupIndex >= 0) {\n                    // YES: then shift+tab should go to the last tabbable node in the\n                    //  previous group (and wrap around to the last tabbable node of\n                    //  the LAST group if it's the first tabbable node of the FIRST group)\n                    var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;\n                    var destinationGroup = state.tabbableGroups[destinationGroupIndex];\n                    destinationNode = destinationGroup.lastTabbableNode;\n                }\n            } else {\n                // FORWARD\n                // is the target the last tabbable node in a group?\n                var lastOfGroupIndex = findIndex(state.tabbableGroups, function(_ref3) {\n                    var lastTabbableNode = _ref3.lastTabbableNode;\n                    return target === lastTabbableNode;\n                });\n                if (lastOfGroupIndex < 0 && (containerGroup.container === target || (0,tabbable__WEBPACK_IMPORTED_MODULE_0__.isFocusable)(target, config.tabbableOptions) && !(0,tabbable__WEBPACK_IMPORTED_MODULE_0__.isTabbable)(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {\n                    // an exception case where the target is the container itself, or\n                    //  a non-tabbable node that was given focus (i.e. tabindex is negative\n                    //  and user clicked on it or node was programmatically given focus)\n                    //  and is not followed by any other tabbable node, in which\n                    //  case, we should handle tab as if focus were on the container's\n                    //  last tabbable node, and go to the first tabbable node of the FIRST group\n                    lastOfGroupIndex = containerIndex;\n                }\n                if (lastOfGroupIndex >= 0) {\n                    // YES: then tab should go to the first tabbable node in the next\n                    //  group (and wrap around to the first tabbable node of the FIRST\n                    //  group if it's the last tabbable node of the LAST group)\n                    var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;\n                    var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];\n                    destinationNode = _destinationGroup.firstTabbableNode;\n                }\n            }\n        } else {\n            // NOTE: the fallbackFocus option does not support returning false to opt-out\n            destinationNode = getNodeForOption(\"fallbackFocus\");\n        }\n        if (destinationNode) {\n            e.preventDefault();\n            tryFocus(destinationNode);\n        } // else, let the browser take care of [shift+]tab and move the focus\n    };\n    var checkKey = function checkKey(e) {\n        if (isEscapeEvent(e) && valueOrHandler(config.escapeDeactivates, e) !== false) {\n            e.preventDefault();\n            trap.deactivate();\n            return;\n        }\n        if (isTabEvent(e)) {\n            checkTab(e);\n            return;\n        }\n    };\n    var checkClick = function checkClick(e) {\n        var target = getActualTarget(e);\n        if (findContainerIndex(target) >= 0) {\n            return;\n        }\n        if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n            return;\n        }\n        if (valueOrHandler(config.allowOutsideClick, e)) {\n            return;\n        }\n        e.preventDefault();\n        e.stopImmediatePropagation();\n    }; //\n    // EVENT LISTENERS\n    //\n    var addListeners = function addListeners() {\n        if (!state.active) {\n            return;\n        } // There can be only one listening focus trap at a time\n        activeFocusTraps.activateTrap(trap); // Delay ensures that the focused element doesn't capture the event\n        // that caused the focus trap activation.\n        state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function() {\n            tryFocus(getInitialFocusNode());\n        }) : tryFocus(getInitialFocusNode());\n        doc.addEventListener(\"focusin\", checkFocusIn, true);\n        doc.addEventListener(\"mousedown\", checkPointerDown, {\n            capture: true,\n            passive: false\n        });\n        doc.addEventListener(\"touchstart\", checkPointerDown, {\n            capture: true,\n            passive: false\n        });\n        doc.addEventListener(\"click\", checkClick, {\n            capture: true,\n            passive: false\n        });\n        doc.addEventListener(\"keydown\", checkKey, {\n            capture: true,\n            passive: false\n        });\n        return trap;\n    };\n    var removeListeners = function removeListeners() {\n        if (!state.active) {\n            return;\n        }\n        doc.removeEventListener(\"focusin\", checkFocusIn, true);\n        doc.removeEventListener(\"mousedown\", checkPointerDown, true);\n        doc.removeEventListener(\"touchstart\", checkPointerDown, true);\n        doc.removeEventListener(\"click\", checkClick, true);\n        doc.removeEventListener(\"keydown\", checkKey, true);\n        return trap;\n    }; //\n    // TRAP DEFINITION\n    //\n    trap = {\n        get active () {\n            return state.active;\n        },\n        get paused () {\n            return state.paused;\n        },\n        activate: function activate(activateOptions) {\n            if (state.active) {\n                return this;\n            }\n            var onActivate = getOption(activateOptions, \"onActivate\");\n            var onPostActivate = getOption(activateOptions, \"onPostActivate\");\n            var checkCanFocusTrap = getOption(activateOptions, \"checkCanFocusTrap\");\n            if (!checkCanFocusTrap) {\n                updateTabbableNodes();\n            }\n            state.active = true;\n            state.paused = false;\n            state.nodeFocusedBeforeActivation = doc.activeElement;\n            if (onActivate) {\n                onActivate();\n            }\n            var finishActivation = function finishActivation() {\n                if (checkCanFocusTrap) {\n                    updateTabbableNodes();\n                }\n                addListeners();\n                if (onPostActivate) {\n                    onPostActivate();\n                }\n            };\n            if (checkCanFocusTrap) {\n                checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);\n                return this;\n            }\n            finishActivation();\n            return this;\n        },\n        deactivate: function deactivate(deactivateOptions) {\n            if (!state.active) {\n                return this;\n            }\n            var options = _objectSpread2({\n                onDeactivate: config.onDeactivate,\n                onPostDeactivate: config.onPostDeactivate,\n                checkCanReturnFocus: config.checkCanReturnFocus\n            }, deactivateOptions);\n            clearTimeout(state.delayInitialFocusTimer); // noop if undefined\n            state.delayInitialFocusTimer = undefined;\n            removeListeners();\n            state.active = false;\n            state.paused = false;\n            activeFocusTraps.deactivateTrap(trap);\n            var onDeactivate = getOption(options, \"onDeactivate\");\n            var onPostDeactivate = getOption(options, \"onPostDeactivate\");\n            var checkCanReturnFocus = getOption(options, \"checkCanReturnFocus\");\n            var returnFocus = getOption(options, \"returnFocus\", \"returnFocusOnDeactivate\");\n            if (onDeactivate) {\n                onDeactivate();\n            }\n            var finishDeactivation = function finishDeactivation() {\n                delay(function() {\n                    if (returnFocus) {\n                        tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));\n                    }\n                    if (onPostDeactivate) {\n                        onPostDeactivate();\n                    }\n                });\n            };\n            if (returnFocus && checkCanReturnFocus) {\n                checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);\n                return this;\n            }\n            finishDeactivation();\n            return this;\n        },\n        pause: function pause() {\n            if (state.paused || !state.active) {\n                return this;\n            }\n            state.paused = true;\n            removeListeners();\n            return this;\n        },\n        unpause: function unpause() {\n            if (!state.paused || !state.active) {\n                return this;\n            }\n            state.paused = false;\n            updateTabbableNodes();\n            addListeners();\n            return this;\n        },\n        updateContainerElements: function updateContainerElements(containerElements) {\n            var elementsAsArray = [].concat(containerElements).filter(Boolean);\n            state.containers = elementsAsArray.map(function(element) {\n                return typeof element === \"string\" ? doc.querySelector(element) : element;\n            });\n            if (state.active) {\n                updateTabbableNodes();\n            }\n            return this;\n        }\n    }; // initialize container elements\n    trap.updateContainerElements(elements);\n    return trap;\n};\n //# sourceMappingURL=focus-trap.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZm9jdXMtdHJhcC9kaXN0L2ZvY3VzLXRyYXAuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7OztBQUdBLEdBQ3dFO0FBRXhFLFNBQVNJLFFBQVFDLE1BQU0sRUFBRUMsY0FBYztJQUNyQyxJQUFJQyxPQUFPQyxPQUFPRCxJQUFJLENBQUNGO0lBRXZCLElBQUlHLE9BQU9DLHFCQUFxQixFQUFFO1FBQ2hDLElBQUlDLFVBQVVGLE9BQU9DLHFCQUFxQixDQUFDSjtRQUMzQ0Msa0JBQW1CSSxDQUFBQSxVQUFVQSxRQUFRQyxNQUFNLENBQUMsU0FBVUMsR0FBRztZQUN2RCxPQUFPSixPQUFPSyx3QkFBd0IsQ0FBQ1IsUUFBUU8sS0FBS0UsVUFBVTtRQUNoRSxFQUFDLEdBQUlQLEtBQUtRLElBQUksQ0FBQ0MsS0FBSyxDQUFDVCxNQUFNRztJQUM3QjtJQUVBLE9BQU9IO0FBQ1Q7QUFFQSxTQUFTVSxlQUFlQyxNQUFNO0lBQzVCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJQyxVQUFVQyxNQUFNLEVBQUVGLElBQUs7UUFDekMsSUFBSUcsU0FBUyxRQUFRRixTQUFTLENBQUNELEVBQUUsR0FBR0MsU0FBUyxDQUFDRCxFQUFFLEdBQUcsQ0FBQztRQUNwREEsSUFBSSxJQUFJZixRQUFRSSxPQUFPYyxTQUFTLENBQUMsR0FBR0MsT0FBTyxDQUFDLFNBQVVDLEdBQUc7WUFDdkRDLGdCQUFnQlAsUUFBUU0sS0FBS0YsTUFBTSxDQUFDRSxJQUFJO1FBQzFDLEtBQUtoQixPQUFPa0IseUJBQXlCLEdBQUdsQixPQUFPbUIsZ0JBQWdCLENBQUNULFFBQVFWLE9BQU9rQix5QkFBeUIsQ0FBQ0osV0FBV2xCLFFBQVFJLE9BQU9jLFNBQVNDLE9BQU8sQ0FBQyxTQUFVQyxHQUFHO1lBQy9KaEIsT0FBT29CLGNBQWMsQ0FBQ1YsUUFBUU0sS0FBS2hCLE9BQU9LLHdCQUF3QixDQUFDUyxRQUFRRTtRQUM3RTtJQUNGO0lBRUEsT0FBT047QUFDVDtB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Q2I7SUFDRixHQUFHLGdDQUFnQztJQUVuQzFFLEtBQUt3SSx1QkFBdUIsQ0FBQ3RHO0lBQzdCLE9BQU9sQztBQUNUO0FBRTJCLENBQzNCLDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy1jcmVkaXQtY2FyZC1hcHAvLi9ub2RlX21vZHVsZXMvZm9jdXMtdHJhcC9kaXN0L2ZvY3VzLXRyYXAuZXNtLmpzP2NmOWUiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4qIGZvY3VzLXRyYXAgNi45LjRcbiogQGxpY2Vuc2UgTUlULCBodHRwczovL2dpdGh1Yi5jb20vZm9jdXMtdHJhcC9mb2N1cy10cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiovXG5pbXBvcnQgeyB0YWJiYWJsZSwgZm9jdXNhYmxlLCBpc1RhYmJhYmxlLCBpc0ZvY3VzYWJsZSB9IGZyb20gJ3RhYmJhYmxlJztcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgIGVudW1lcmFibGVPbmx5ICYmIChzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgfSkpLCBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gIH1cblxuICByZXR1cm4ga2V5cztcbn1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZDIodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307XG4gICAgaSAlIDIgPyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKSA6IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxudmFyIGFjdGl2ZUZvY3VzVHJhcHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0cmFwUXVldWUgPSBbXTtcbiAgcmV0dXJuIHtcbiAgICBhY3RpdmF0ZVRyYXA6IGZ1bmN0aW9uIGFjdGl2YXRlVHJhcCh0cmFwKSB7XG4gICAgICBpZiAodHJhcFF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGFjdGl2ZVRyYXAgPSB0cmFwUXVldWVbdHJhcFF1ZXVlLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIGlmIChhY3RpdmVUcmFwICE9PSB0cmFwKSB7XG4gICAgICAgICAgYWN0aXZlVHJhcC5wYXVzZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB0cmFwSW5kZXggPSB0cmFwUXVldWUuaW5kZXhPZih0cmFwKTtcblxuICAgICAgaWYgKHRyYXBJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgdHJhcFF1ZXVlLnB1c2godHJhcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBtb3ZlIHRoaXMgZXhpc3RpbmcgdHJhcCB0byB0aGUgZnJvbnQgb2YgdGhlIHF1ZXVlXG4gICAgICAgIHRyYXBRdWV1ZS5zcGxpY2UodHJhcEluZGV4LCAxKTtcbiAgICAgICAgdHJhcFF1ZXVlLnB1c2godHJhcCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkZWFjdGl2YXRlVHJhcDogZnVuY3Rpb24gZGVhY3RpdmF0ZVRyYXAodHJhcCkge1xuICAgICAgdmFyIHRyYXBJbmRleCA9IHRyYXBRdWV1ZS5pbmRleE9mKHRyYXApO1xuXG4gICAgICBpZiAodHJhcEluZGV4ICE9PSAtMSkge1xuICAgICAgICB0cmFwUXVldWUuc3BsaWNlKHRyYXBJbmRleCwgMSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0cmFwUXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICB0cmFwUXVldWVbdHJhcFF1ZXVlLmxlbmd0aCAtIDFdLnVucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59KCk7XG5cbnZhciBpc1NlbGVjdGFibGVJbnB1dCA9IGZ1bmN0aW9uIGlzU2VsZWN0YWJsZUlucHV0KG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUudGFnTmFtZSAmJiBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0JyAmJiB0eXBlb2Ygbm9kZS5zZWxlY3QgPT09ICdmdW5jdGlvbic7XG59O1xuXG52YXIgaXNFc2NhcGVFdmVudCA9IGZ1bmN0aW9uIGlzRXNjYXBlRXZlbnQoZSkge1xuICByZXR1cm4gZS5rZXkgPT09ICdFc2NhcGUnIHx8IGUua2V5ID09PSAnRXNjJyB8fCBlLmtleUNvZGUgPT09IDI3O1xufTtcblxudmFyIGlzVGFiRXZlbnQgPSBmdW5jdGlvbiBpc1RhYkV2ZW50KGUpIHtcbiAgcmV0dXJuIGUua2V5ID09PSAnVGFiJyB8fCBlLmtleUNvZGUgPT09IDk7XG59O1xuXG52YXIgZGVsYXkgPSBmdW5jdGlvbiBkZWxheShmbikge1xuICByZXR1cm4gc2V0VGltZW91dChmbiwgMCk7XG59OyAvLyBBcnJheS5maW5kL2ZpbmRJbmRleCgpIGFyZSBub3Qgc3VwcG9ydGVkIG9uIElFOyB0aGlzIHJlcGxpY2F0ZXMgZW5vdWdoXG4vLyAgb2YgQXJyYXkuZmluZEluZGV4KCkgZm9yIG91ciBuZWVkc1xuXG5cbnZhciBmaW5kSW5kZXggPSBmdW5jdGlvbiBmaW5kSW5kZXgoYXJyLCBmbikge1xuICB2YXIgaWR4ID0gLTE7XG4gIGFyci5ldmVyeShmdW5jdGlvbiAodmFsdWUsIGkpIHtcbiAgICBpZiAoZm4odmFsdWUpKSB7XG4gICAgICBpZHggPSBpO1xuICAgICAgcmV0dXJuIGZhbHNlOyAvLyBicmVha1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlOyAvLyBuZXh0XG4gIH0pO1xuICByZXR1cm4gaWR4O1xufTtcbi8qKlxuICogR2V0IGFuIG9wdGlvbidzIHZhbHVlIHdoZW4gaXQgY291bGQgYmUgYSBwbGFpbiB2YWx1ZSwgb3IgYSBoYW5kbGVyIHRoYXQgcHJvdmlkZXNcbiAqICB0aGUgdmFsdWUuXG4gKiBAcGFyYW0geyp9IHZhbHVlIE9wdGlvbidzIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHsuLi4qfSBbcGFyYW1zXSBBbnkgcGFyYW1ldGVycyB0byBwYXNzIHRvIHRoZSBoYW5kbGVyLCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7Kn0gVGhlIGB2YWx1ZWAsIG9yIHRoZSBoYW5kbGVyJ3MgcmV0dXJuZWQgdmFsdWUuXG4gKi9cblxuXG52YXIgdmFsdWVPckhhbmRsZXIgPSBmdW5jdGlvbiB2YWx1ZU9ySGFuZGxlcih2YWx1ZSkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcGFyYW1zID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBwYXJhbXNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLmFwcGx5KHZvaWQgMCwgcGFyYW1zKSA6IHZhbHVlO1xufTtcblxudmFyIGdldEFjdHVhbFRhcmdldCA9IGZ1bmN0aW9uIGdldEFjdHVhbFRhcmdldChldmVudCkge1xuICAvLyBOT1RFOiBJZiB0aGUgdHJhcCBpcyBfaW5zaWRlXyBhIHNoYWRvdyBET00sIGV2ZW50LnRhcmdldCB3aWxsIGFsd2F5cyBiZSB0aGVcbiAgLy8gIHNoYWRvdyBob3N0LiBIb3dldmVyLCBldmVudC50YXJnZXQuY29tcG9zZWRQYXRoKCkgd2lsbCBiZSBhbiBhcnJheSBvZlxuICAvLyAgbm9kZXMgXCJjbGlja2VkXCIgZnJvbSBpbm5lci1tb3N0ICh0aGUgYWN0dWFsIGVsZW1lbnQgaW5zaWRlIHRoZSBzaGFkb3cpIHRvXG4gIC8vICBvdXRlci1tb3N0ICh0aGUgaG9zdCBIVE1MIGRvY3VtZW50KS4gSWYgd2UgaGF2ZSBhY2Nlc3MgdG8gY29tcG9zZWRQYXRoKCksXG4gIC8vICB0aGVuIHVzZSBpdHMgZmlyc3QgZWxlbWVudDsgb3RoZXJ3aXNlLCBmYWxsIGJhY2sgdG8gZXZlbnQudGFyZ2V0IChhbmRcbiAgLy8gIHRoaXMgb25seSB3b3JrcyBmb3IgYW4gX29wZW5fIHNoYWRvdyBET007IG90aGVyd2lzZSxcbiAgLy8gIGNvbXBvc2VkUGF0aCgpWzBdID09PSBldmVudC50YXJnZXQgYWx3YXlzKS5cbiAgcmV0dXJuIGV2ZW50LnRhcmdldC5zaGFkb3dSb290ICYmIHR5cGVvZiBldmVudC5jb21wb3NlZFBhdGggPT09ICdmdW5jdGlvbicgPyBldmVudC5jb21wb3NlZFBhdGgoKVswXSA6IGV2ZW50LnRhcmdldDtcbn07XG5cbnZhciBjcmVhdGVGb2N1c1RyYXAgPSBmdW5jdGlvbiBjcmVhdGVGb2N1c1RyYXAoZWxlbWVudHMsIHVzZXJPcHRpb25zKSB7XG4gIC8vIFNTUjogYSBsaXZlIHRyYXAgc2hvdWxkbid0IGJlIGNyZWF0ZWQgaW4gdGhpcyB0eXBlIG9mIGVudmlyb25tZW50IHNvIHRoaXNcbiAgLy8gIHNob3VsZCBiZSBzYWZlIGNvZGUgdG8gZXhlY3V0ZSBpZiB0aGUgYGRvY3VtZW50YCBvcHRpb24gaXNuJ3Qgc3BlY2lmaWVkXG4gIHZhciBkb2MgPSAodXNlck9wdGlvbnMgPT09IG51bGwgfHwgdXNlck9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVzZXJPcHRpb25zLmRvY3VtZW50KSB8fCBkb2N1bWVudDtcblxuICB2YXIgY29uZmlnID0gX29iamVjdFNwcmVhZDIoe1xuICAgIHJldHVybkZvY3VzT25EZWFjdGl2YXRlOiB0cnVlLFxuICAgIGVzY2FwZURlYWN0aXZhdGVzOiB0cnVlLFxuICAgIGRlbGF5SW5pdGlhbEZvY3VzOiB0cnVlXG4gIH0sIHVzZXJPcHRpb25zKTtcblxuICB2YXIgc3RhdGUgPSB7XG4gICAgLy8gY29udGFpbmVycyBnaXZlbiB0byBjcmVhdGVGb2N1c1RyYXAoKVxuICAgIC8vIEB0eXBlIHtBcnJheTxIVE1MRWxlbWVudD59XG4gICAgY29udGFpbmVyczogW10sXG4gICAgLy8gbGlzdCBvZiBvYmplY3RzIGlkZW50aWZ5aW5nIHRhYmJhYmxlIG5vZGVzIGluIGBjb250YWluZXJzYCBpbiB0aGUgdHJhcFxuICAgIC8vIE5PVEU6IGl0J3MgcG9zc2libGUgdGhhdCBhIGdyb3VwIGhhcyBubyB0YWJiYWJsZSBub2RlcyBpZiBub2RlcyBnZXQgcmVtb3ZlZCB3aGlsZSB0aGUgdHJhcFxuICAgIC8vICBpcyBhY3RpdmUsIGJ1dCB0aGUgdHJhcCBzaG91bGQgbmV2ZXIgZ2V0IHRvIGEgc3RhdGUgd2hlcmUgdGhlcmUgaXNuJ3QgYXQgbGVhc3Qgb25lIGdyb3VwXG4gICAgLy8gIHdpdGggYXQgbGVhc3Qgb25lIHRhYmJhYmxlIG5vZGUgaW4gaXQgKHRoYXQgd291bGQgbGVhZCB0byBhbiBlcnJvciBjb25kaXRpb24gdGhhdCB3b3VsZFxuICAgIC8vICByZXN1bHQgaW4gYW4gZXJyb3IgYmVpbmcgdGhyb3duKVxuICAgIC8vIEB0eXBlIHtBcnJheTx7XG4gICAgLy8gICBjb250YWluZXI6IEhUTUxFbGVtZW50LFxuICAgIC8vICAgdGFiYmFibGVOb2RlczogQXJyYXk8SFRNTEVsZW1lbnQ+LCAvLyBlbXB0eSBpZiBub25lXG4gICAgLy8gICBmb2N1c2FibGVOb2RlczogQXJyYXk8SFRNTEVsZW1lbnQ+LCAvLyBlbXB0eSBpZiBub25lXG4gICAgLy8gICBmaXJzdFRhYmJhYmxlTm9kZTogSFRNTEVsZW1lbnR8bnVsbCxcbiAgICAvLyAgIGxhc3RUYWJiYWJsZU5vZGU6IEhUTUxFbGVtZW50fG51bGwsXG4gICAgLy8gICBuZXh0VGFiYmFibGVOb2RlOiAobm9kZTogSFRNTEVsZW1lbnQsIGZvcndhcmQ6IGJvb2xlYW4pID0+IEhUTUxFbGVtZW50fHVuZGVmaW5lZFxuICAgIC8vIH0+fVxuICAgIGNvbnRhaW5lckdyb3VwczogW10sXG4gICAgLy8gc2FtZSBvcmRlci9sZW5ndGggYXMgYGNvbnRhaW5lcnNgIGxpc3RcbiAgICAvLyByZWZlcmVuY2VzIHRvIG9iamVjdHMgaW4gYGNvbnRhaW5lckdyb3Vwc2AsIGJ1dCBvbmx5IHRob3NlIHRoYXQgYWN0dWFsbHkgaGF2ZVxuICAgIC8vICB0YWJiYWJsZSBub2RlcyBpbiB0aGVtXG4gICAgLy8gTk9URTogc2FtZSBvcmRlciBhcyBgY29udGFpbmVyc2AgYW5kIGBjb250YWluZXJHcm91cHNgLCBidXQgX19ub3QgbmVjZXNzYXJpbHlfX1xuICAgIC8vICB0aGUgc2FtZSBsZW5ndGhcbiAgICB0YWJiYWJsZUdyb3VwczogW10sXG4gICAgbm9kZUZvY3VzZWRCZWZvcmVBY3RpdmF0aW9uOiBudWxsLFxuICAgIG1vc3RSZWNlbnRseUZvY3VzZWROb2RlOiBudWxsLFxuICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgcGF1c2VkOiBmYWxzZSxcbiAgICAvLyB0aW1lciBJRCBmb3Igd2hlbiBkZWxheUluaXRpYWxGb2N1cyBpcyB0cnVlIGFuZCBpbml0aWFsIGZvY3VzIGluIHRoaXMgdHJhcFxuICAgIC8vICBoYXMgYmVlbiBkZWxheWVkIGR1cmluZyBhY3RpdmF0aW9uXG4gICAgZGVsYXlJbml0aWFsRm9jdXNUaW1lcjogdW5kZWZpbmVkXG4gIH07XG4gIHZhciB0cmFwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHByZWZlci1jb25zdCAtLSBzb21lIHByaXZhdGUgZnVuY3Rpb25zIHJlZmVyZW5jZSBpdCwgYW5kIGl0cyBtZXRob2RzIHJlZmVyZW5jZSBwcml2YXRlIGZ1bmN0aW9ucywgc28gd2UgbXVzdCBkZWNsYXJlIGhlcmUgYW5kIGRlZmluZSBsYXRlclxuXG4gIC8qKlxuICAgKiBHZXRzIGEgY29uZmlndXJhdGlvbiBvcHRpb24gdmFsdWUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fHVuZGVmaW5lZH0gY29uZmlnT3ZlcnJpZGVPcHRpb25zIElmIHRydWUsIGFuZCBvcHRpb24gaXMgZGVmaW5lZCBpbiB0aGlzIHNldCxcbiAgICogIHZhbHVlIHdpbGwgYmUgdGFrZW4gZnJvbSB0aGlzIG9iamVjdC4gT3RoZXJ3aXNlLCB2YWx1ZSB3aWxsIGJlIHRha2VuIGZyb20gYmFzZSBjb25maWd1cmF0aW9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9uTmFtZSBOYW1lIG9mIHRoZSBvcHRpb24gd2hvc2UgdmFsdWUgaXMgc291Z2h0LlxuICAgKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IFtjb25maWdPcHRpb25OYW1lXSBOYW1lIG9mIG9wdGlvbiB0byB1c2UgX19pbnN0ZWFkIG9mX18gYG9wdGlvbk5hbWVgXG4gICAqICBJSUYgYGNvbmZpZ092ZXJyaWRlT3B0aW9uc2AgaXMgbm90IGRlZmluZWQuIE90aGVyd2lzZSwgYG9wdGlvbk5hbWVgIGlzIHVzZWQuXG4gICAqL1xuXG4gIHZhciBnZXRPcHRpb24gPSBmdW5jdGlvbiBnZXRPcHRpb24oY29uZmlnT3ZlcnJpZGVPcHRpb25zLCBvcHRpb25OYW1lLCBjb25maWdPcHRpb25OYW1lKSB7XG4gICAgcmV0dXJuIGNvbmZpZ092ZXJyaWRlT3B0aW9ucyAmJiBjb25maWdPdmVycmlkZU9wdGlvbnNbb3B0aW9uTmFtZV0gIT09IHVuZGVmaW5lZCA/IGNvbmZpZ092ZXJyaWRlT3B0aW9uc1tvcHRpb25OYW1lXSA6IGNvbmZpZ1tjb25maWdPcHRpb25OYW1lIHx8IG9wdGlvbk5hbWVdO1xuICB9O1xuICAvKipcbiAgICogRmluZHMgdGhlIGluZGV4IG9mIHRoZSBjb250YWluZXIgdGhhdCBjb250YWlucyB0aGUgZWxlbWVudC5cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBJbmRleCBvZiB0aGUgY29udGFpbmVyIGluIGVpdGhlciBgc3RhdGUuY29udGFpbmVyc2Agb3JcbiAgICogIGBzdGF0ZS5jb250YWluZXJHcm91cHNgICh0aGUgb3JkZXIvbGVuZ3RoIG9mIHRoZXNlIGxpc3RzIGFyZSB0aGUgc2FtZSk7IC0xXG4gICAqICBpZiB0aGUgZWxlbWVudCBpc24ndCBmb3VuZC5cbiAgICovXG5cblxuICB2YXIgZmluZENvbnRhaW5lckluZGV4ID0gZnVuY3Rpb24gZmluZENvbnRhaW5lckluZGV4KGVsZW1lbnQpIHtcbiAgICAvLyBOT1RFOiBzZWFyY2ggYGNvbnRhaW5lckdyb3Vwc2AgYmVjYXVzZSBpdCdzIHBvc3NpYmxlIGEgZ3JvdXAgY29udGFpbnMgbm8gdGFiYmFibGVcbiAgICAvLyAgbm9kZXMsIGJ1dCBzdGlsbCBjb250YWlucyBmb2N1c2FibGUgbm9kZXMgKGUuZy4gaWYgdGhleSBhbGwgaGF2ZSBgdGFiaW5kZXg9LTFgKVxuICAgIC8vICBhbmQgd2Ugc3RpbGwgbmVlZCB0byBmaW5kIHRoZSBlbGVtZW50IGluIHRoZXJlXG4gICAgcmV0dXJuIHN0YXRlLmNvbnRhaW5lckdyb3Vwcy5maW5kSW5kZXgoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgIHZhciBjb250YWluZXIgPSBfcmVmLmNvbnRhaW5lcixcbiAgICAgICAgICB0YWJiYWJsZU5vZGVzID0gX3JlZi50YWJiYWJsZU5vZGVzO1xuICAgICAgcmV0dXJuIGNvbnRhaW5lci5jb250YWlucyhlbGVtZW50KSB8fCAvLyBmYWxsIGJhY2sgdG8gZXhwbGljaXQgdGFiYmFibGUgc2VhcmNoIHdoaWNoIHdpbGwgdGFrZSBpbnRvIGNvbnNpZGVyYXRpb24gYW55XG4gICAgICAvLyAgd2ViIGNvbXBvbmVudHMgaWYgdGhlIGB0YWJiYWJsZU9wdGlvbnMuZ2V0U2hhZG93Um9vdGAgb3B0aW9uIHdhcyB1c2VkIGZvclxuICAgICAgLy8gIHRoZSB0cmFwLCBlbmFibGluZyBzaGFkb3cgRE9NIHN1cHBvcnQgaW4gdGFiYmFibGUgKGBOb2RlLmNvbnRhaW5zKClgIGRvZXNuJ3RcbiAgICAgIC8vICBsb29rIGluc2lkZSB3ZWIgY29tcG9uZW50cyBldmVuIGlmIG9wZW4pXG4gICAgICB0YWJiYWJsZU5vZGVzLmZpbmQoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUgPT09IGVsZW1lbnQ7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbiAgLyoqXG4gICAqIEdldHMgdGhlIG5vZGUgZm9yIHRoZSBnaXZlbiBvcHRpb24sIHdoaWNoIGlzIGV4cGVjdGVkIHRvIGJlIGFuIG9wdGlvbiB0aGF0XG4gICAqICBjYW4gYmUgZWl0aGVyIGEgRE9NIG5vZGUsIGEgc3RyaW5nIHRoYXQgaXMgYSBzZWxlY3RvciB0byBnZXQgYSBub2RlLCBgZmFsc2VgXG4gICAqICAoaWYgYSBub2RlIGlzIGV4cGxpY2l0bHkgTk9UIGdpdmVuKSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW55IG9mIHRoZXNlXG4gICAqICB2YWx1ZXMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25OYW1lXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWQgfCBmYWxzZSB8IEhUTUxFbGVtZW50IHwgU1ZHRWxlbWVudH0gUmV0dXJuc1xuICAgKiAgYHVuZGVmaW5lZGAgaWYgdGhlIG9wdGlvbiBpcyBub3Qgc3BlY2lmaWVkOyBgZmFsc2VgIGlmIHRoZSBvcHRpb25cbiAgICogIHJlc29sdmVkIHRvIGBmYWxzZWAgKG5vZGUgZXhwbGljaXRseSBub3QgZ2l2ZW4pOyBvdGhlcndpc2UsIHRoZSByZXNvbHZlZFxuICAgKiAgRE9NIG5vZGUuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgb3B0aW9uIGlzIHNldCwgbm90IGBmYWxzZWAsIGFuZCBpcyBub3QsIG9yIGRvZXMgbm90XG4gICAqICByZXNvbHZlIHRvIGEgbm9kZS5cbiAgICovXG5cblxuICB2YXIgZ2V0Tm9kZUZvck9wdGlvbiA9IGZ1bmN0aW9uIGdldE5vZGVGb3JPcHRpb24ob3B0aW9uTmFtZSkge1xuICAgIHZhciBvcHRpb25WYWx1ZSA9IGNvbmZpZ1tvcHRpb25OYW1lXTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9uVmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgcGFyYW1zID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgcGFyYW1zW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBvcHRpb25WYWx1ZSA9IG9wdGlvblZhbHVlLmFwcGx5KHZvaWQgMCwgcGFyYW1zKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9uVmFsdWUgPT09IHRydWUpIHtcbiAgICAgIG9wdGlvblZhbHVlID0gdW5kZWZpbmVkOyAvLyB1c2UgZGVmYXVsdCB2YWx1ZVxuICAgIH1cblxuICAgIGlmICghb3B0aW9uVmFsdWUpIHtcbiAgICAgIGlmIChvcHRpb25WYWx1ZSA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvblZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gb3B0aW9uVmFsdWU7XG4gICAgICB9IC8vIGVsc2UsIGVtcHR5IHN0cmluZyAoaW52YWxpZCksIG51bGwgKGludmFsaWQpLCAwIChpbnZhbGlkKVxuXG5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImBcIi5jb25jYXQob3B0aW9uTmFtZSwgXCJgIHdhcyBzcGVjaWZpZWQgYnV0IHdhcyBub3QgYSBub2RlLCBvciBkaWQgbm90IHJldHVybiBhIG5vZGVcIikpO1xuICAgIH1cblxuICAgIHZhciBub2RlID0gb3B0aW9uVmFsdWU7IC8vIGNvdWxkIGJlIEhUTUxFbGVtZW50LCBTVkdFbGVtZW50LCBvciBub24tZW1wdHkgc3RyaW5nIGF0IHRoaXMgcG9pbnRcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9uVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBub2RlID0gZG9jLnF1ZXJ5U2VsZWN0b3Iob3B0aW9uVmFsdWUpOyAvLyByZXNvbHZlIHRvIG5vZGUsIG9yIG51bGwgaWYgZmFpbHNcblxuICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImBcIi5jb25jYXQob3B0aW9uTmFtZSwgXCJgIGFzIHNlbGVjdG9yIHJlZmVycyB0byBubyBrbm93biBub2RlXCIpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfTtcblxuICB2YXIgZ2V0SW5pdGlhbEZvY3VzTm9kZSA9IGZ1bmN0aW9uIGdldEluaXRpYWxGb2N1c05vZGUoKSB7XG4gICAgdmFyIG5vZGUgPSBnZXROb2RlRm9yT3B0aW9uKCdpbml0aWFsRm9jdXMnKTsgLy8gZmFsc2UgZXhwbGljaXRseSBpbmRpY2F0ZXMgd2Ugd2FudCBubyBpbml0aWFsRm9jdXMgYXQgYWxsXG5cbiAgICBpZiAobm9kZSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBvcHRpb24gbm90IHNwZWNpZmllZDogdXNlIGZhbGxiYWNrIG9wdGlvbnNcbiAgICAgIGlmIChmaW5kQ29udGFpbmVySW5kZXgoZG9jLmFjdGl2ZUVsZW1lbnQpID49IDApIHtcbiAgICAgICAgbm9kZSA9IGRvYy5hY3RpdmVFbGVtZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGZpcnN0VGFiYmFibGVHcm91cCA9IHN0YXRlLnRhYmJhYmxlR3JvdXBzWzBdO1xuICAgICAgICB2YXIgZmlyc3RUYWJiYWJsZU5vZGUgPSBmaXJzdFRhYmJhYmxlR3JvdXAgJiYgZmlyc3RUYWJiYWJsZUdyb3VwLmZpcnN0VGFiYmFibGVOb2RlOyAvLyBOT1RFOiBgZmFsbGJhY2tGb2N1c2Agb3B0aW9uIGZ1bmN0aW9uIGNhbm5vdCByZXR1cm4gYGZhbHNlYCAobm90IHN1cHBvcnRlZClcblxuICAgICAgICBub2RlID0gZmlyc3RUYWJiYWJsZU5vZGUgfHwgZ2V0Tm9kZUZvck9wdGlvbignZmFsbGJhY2tGb2N1cycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghbm9kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3VyIGZvY3VzLXRyYXAgbmVlZHMgdG8gaGF2ZSBhdCBsZWFzdCBvbmUgZm9jdXNhYmxlIGVsZW1lbnQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfTtcblxuICB2YXIgdXBkYXRlVGFiYmFibGVOb2RlcyA9IGZ1bmN0aW9uIHVwZGF0ZVRhYmJhYmxlTm9kZXMoKSB7XG4gICAgc3RhdGUuY29udGFpbmVyR3JvdXBzID0gc3RhdGUuY29udGFpbmVycy5tYXAoZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgICAgdmFyIHRhYmJhYmxlTm9kZXMgPSB0YWJiYWJsZShjb250YWluZXIsIGNvbmZpZy50YWJiYWJsZU9wdGlvbnMpOyAvLyBOT1RFOiBpZiB3ZSBoYXZlIHRhYmJhYmxlIG5vZGVzLCB3ZSBtdXN0IGhhdmUgZm9jdXNhYmxlIG5vZGVzOyBmb2N1c2FibGUgbm9kZXNcbiAgICAgIC8vICBhcmUgYSBzdXBlcnNldCBvZiB0YWJiYWJsZSBub2Rlc1xuXG4gICAgICB2YXIgZm9jdXNhYmxlTm9kZXMgPSBmb2N1c2FibGUoY29udGFpbmVyLCBjb25maWcudGFiYmFibGVPcHRpb25zKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgICAgICB0YWJiYWJsZU5vZGVzOiB0YWJiYWJsZU5vZGVzLFxuICAgICAgICBmb2N1c2FibGVOb2RlczogZm9jdXNhYmxlTm9kZXMsXG4gICAgICAgIGZpcnN0VGFiYmFibGVOb2RlOiB0YWJiYWJsZU5vZGVzLmxlbmd0aCA+IDAgPyB0YWJiYWJsZU5vZGVzWzBdIDogbnVsbCxcbiAgICAgICAgbGFzdFRhYmJhYmxlTm9kZTogdGFiYmFibGVOb2Rlcy5sZW5ndGggPiAwID8gdGFiYmFibGVOb2Rlc1t0YWJiYWJsZU5vZGVzLmxlbmd0aCAtIDFdIDogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRmluZHMgdGhlIF9fdGFiYmFibGVfXyBub2RlIHRoYXQgZm9sbG93cyB0aGUgZ2l2ZW4gbm9kZSBpbiB0aGUgc3BlY2lmaWVkIGRpcmVjdGlvbixcbiAgICAgICAgICogIGluIHRoaXMgY29udGFpbmVyLCBpZiBhbnkuXG4gICAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbZm9yd2FyZF0gVHJ1ZSBpZiBnb2luZyBpbiBmb3J3YXJkIHRhYiBvcmRlcjsgZmFsc2UgaWYgZ29pbmdcbiAgICAgICAgICogIGluIHJldmVyc2UuXG4gICAgICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudHx1bmRlZmluZWR9IFRoZSBuZXh0IHRhYmJhYmxlIG5vZGUsIGlmIGFueS5cbiAgICAgICAgICovXG4gICAgICAgIG5leHRUYWJiYWJsZU5vZGU6IGZ1bmN0aW9uIG5leHRUYWJiYWJsZU5vZGUobm9kZSkge1xuICAgICAgICAgIHZhciBmb3J3YXJkID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgICAgICAgIC8vIE5PVEU6IElmIHRhYmluZGV4IGlzIHBvc2l0aXZlIChpbiBvcmRlciB0byBtYW5pcHVsYXRlIHRoZSB0YWIgb3JkZXIgc2VwYXJhdGVcbiAgICAgICAgICAvLyAgZnJvbSB0aGUgRE9NIG9yZGVyKSwgdGhpcyBfX3dpbGwgbm90IHdvcmtfXyBiZWNhdXNlIHRoZSBsaXN0IG9mIGZvY3VzYWJsZU5vZGVzLFxuICAgICAgICAgIC8vICB3aGlsZSBpdCBjb250YWlucyB0YWJiYWJsZSBub2RlcywgZG9lcyBub3Qgc29ydCBpdHMgbm9kZXMgaW4gYW55IG9yZGVyIG90aGVyXG4gICAgICAgICAgLy8gIHRoYW4gRE9NIG9yZGVyLCBiZWNhdXNlIGl0IGNhbid0OiBXaGVyZSB3b3VsZCB5b3UgcGxhY2UgZm9jdXNhYmxlIChidXQgbm90XG4gICAgICAgICAgLy8gIHRhYmJhYmxlKSBub2RlcyBpbiB0aGF0IG9yZGVyPyBUaGV5IGhhdmUgbm8gb3JkZXIsIGJlY2F1c2UgdGhleSBhcmVuJ3QgdGFiYmFsZS4uLlxuICAgICAgICAgIC8vIFN1cHBvcnQgZm9yIHBvc2l0aXZlIHRhYmluZGV4IGlzIGFscmVhZHkgYnJva2VuIGFuZCBoYXJkIHRvIG1hbmFnZSAocG9zc2libHlcbiAgICAgICAgICAvLyAgbm90IHN1cHBvcnRhYmxlLCBUQkQpLCBzbyB0aGlzIGlzbid0IGdvaW5nIHRvIG1ha2UgdGhpbmdzIHdvcnNlIHRoYW4gdGhleVxuICAgICAgICAgIC8vICBhbHJlYWR5IGFyZSwgYW5kIGF0IGxlYXN0IG1ha2VzIHRoaW5ncyBiZXR0ZXIgZm9yIHRoZSBtYWpvcml0eSBvZiBjYXNlcyB3aGVyZVxuICAgICAgICAgIC8vICB0YWJpbmRleCBpcyBlaXRoZXIgMC91bnNldCBvciBuZWdhdGl2ZS5cbiAgICAgICAgICAvLyBGWUksIHBvc2l0aXZlIHRhYmluZGV4IGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vZm9jdXMtdHJhcC9mb2N1cy10cmFwL2lzc3Vlcy8zNzVcbiAgICAgICAgICB2YXIgbm9kZUlkeCA9IGZvY3VzYWJsZU5vZGVzLmZpbmRJbmRleChmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgcmV0dXJuIG4gPT09IG5vZGU7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAobm9kZUlkeCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGZvcndhcmQpIHtcbiAgICAgICAgICAgIHJldHVybiBmb2N1c2FibGVOb2Rlcy5zbGljZShub2RlSWR4ICsgMSkuZmluZChmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgICByZXR1cm4gaXNUYWJiYWJsZShuLCBjb25maWcudGFiYmFibGVPcHRpb25zKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBmb2N1c2FibGVOb2Rlcy5zbGljZSgwLCBub2RlSWR4KS5yZXZlcnNlKCkuZmluZChmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgcmV0dXJuIGlzVGFiYmFibGUobiwgY29uZmlnLnRhYmJhYmxlT3B0aW9ucyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gICAgc3RhdGUudGFiYmFibGVHcm91cHMgPSBzdGF0ZS5jb250YWluZXJHcm91cHMuZmlsdGVyKGZ1bmN0aW9uIChncm91cCkge1xuICAgICAgcmV0dXJuIGdyb3VwLnRhYmJhYmxlTm9kZXMubGVuZ3RoID4gMDtcbiAgICB9KTsgLy8gdGhyb3cgaWYgbm8gZ3JvdXBzIGhhdmUgdGFiYmFibGUgbm9kZXMgYW5kIHdlIGRvbid0IGhhdmUgYSBmYWxsYmFjayBmb2N1cyBub2RlIGVpdGhlclxuXG4gICAgaWYgKHN0YXRlLnRhYmJhYmxlR3JvdXBzLmxlbmd0aCA8PSAwICYmICFnZXROb2RlRm9yT3B0aW9uKCdmYWxsYmFja0ZvY3VzJykgLy8gcmV0dXJuaW5nIGZhbHNlIG5vdCBzdXBwb3J0ZWQgZm9yIHRoaXMgb3B0aW9uXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdXIgZm9jdXMtdHJhcCBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIGNvbnRhaW5lciB3aXRoIGF0IGxlYXN0IG9uZSB0YWJiYWJsZSBub2RlIGluIGl0IGF0IGFsbCB0aW1lcycpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgdHJ5Rm9jdXMgPSBmdW5jdGlvbiB0cnlGb2N1cyhub2RlKSB7XG4gICAgaWYgKG5vZGUgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5vZGUgPT09IGRvYy5hY3RpdmVFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFub2RlIHx8ICFub2RlLmZvY3VzKSB7XG4gICAgICB0cnlGb2N1cyhnZXRJbml0aWFsRm9jdXNOb2RlKCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG5vZGUuZm9jdXMoe1xuICAgICAgcHJldmVudFNjcm9sbDogISFjb25maWcucHJldmVudFNjcm9sbFxuICAgIH0pO1xuICAgIHN0YXRlLm1vc3RSZWNlbnRseUZvY3VzZWROb2RlID0gbm9kZTtcblxuICAgIGlmIChpc1NlbGVjdGFibGVJbnB1dChub2RlKSkge1xuICAgICAgbm9kZS5zZWxlY3QoKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGdldFJldHVybkZvY3VzTm9kZSA9IGZ1bmN0aW9uIGdldFJldHVybkZvY3VzTm9kZShwcmV2aW91c0FjdGl2ZUVsZW1lbnQpIHtcbiAgICB2YXIgbm9kZSA9IGdldE5vZGVGb3JPcHRpb24oJ3NldFJldHVybkZvY3VzJywgcHJldmlvdXNBY3RpdmVFbGVtZW50KTtcbiAgICByZXR1cm4gbm9kZSA/IG5vZGUgOiBub2RlID09PSBmYWxzZSA/IGZhbHNlIDogcHJldmlvdXNBY3RpdmVFbGVtZW50O1xuICB9OyAvLyBUaGlzIG5lZWRzIHRvIGJlIGRvbmUgb24gbW91c2Vkb3duIGFuZCB0b3VjaHN0YXJ0IGluc3RlYWQgb2YgY2xpY2tcbiAgLy8gc28gdGhhdCBpdCBwcmVjZWRlcyB0aGUgZm9jdXMgZXZlbnQuXG5cblxuICB2YXIgY2hlY2tQb2ludGVyRG93biA9IGZ1bmN0aW9uIGNoZWNrUG9pbnRlckRvd24oZSkge1xuICAgIHZhciB0YXJnZXQgPSBnZXRBY3R1YWxUYXJnZXQoZSk7XG5cbiAgICBpZiAoZmluZENvbnRhaW5lckluZGV4KHRhcmdldCkgPj0gMCkge1xuICAgICAgLy8gYWxsb3cgdGhlIGNsaWNrIHNpbmNlIGl0IG9jdXJyZWQgaW5zaWRlIHRoZSB0cmFwXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlT3JIYW5kbGVyKGNvbmZpZy5jbGlja091dHNpZGVEZWFjdGl2YXRlcywgZSkpIHtcbiAgICAgIC8vIGltbWVkaWF0ZWx5IGRlYWN0aXZhdGUgdGhlIHRyYXBcbiAgICAgIHRyYXAuZGVhY3RpdmF0ZSh7XG4gICAgICAgIC8vIGlmLCBvbiBkZWFjdGl2YXRpb24sIHdlIHNob3VsZCByZXR1cm4gZm9jdXMgdG8gdGhlIG5vZGUgb3JpZ2luYWxseS1mb2N1c2VkXG4gICAgICAgIC8vICB3aGVuIHRoZSB0cmFwIHdhcyBhY3RpdmF0ZWQgKG9yIHRoZSBjb25maWd1cmVkIGBzZXRSZXR1cm5Gb2N1c2Agbm9kZSksXG4gICAgICAgIC8vICB0aGVuIGFzc3VtZSBpdCdzIGFsc28gT0sgdG8gcmV0dXJuIGZvY3VzIHRvIHRoZSBvdXRzaWRlIG5vZGUgdGhhdCB3YXNcbiAgICAgICAgLy8gIGp1c3QgY2xpY2tlZCwgY2F1c2luZyBkZWFjdGl2YXRpb24sIGFzIGxvbmcgYXMgdGhhdCBub2RlIGlzIGZvY3VzYWJsZTtcbiAgICAgICAgLy8gIGlmIGl0IGlzbid0IGZvY3VzYWJsZSwgdGhlbiByZXR1cm4gZm9jdXMgdG8gdGhlIG9yaWdpbmFsIG5vZGUgZm9jdXNlZFxuICAgICAgICAvLyAgb24gYWN0aXZhdGlvbiAob3IgdGhlIGNvbmZpZ3VyZWQgYHNldFJldHVybkZvY3VzYCBub2RlKVxuICAgICAgICAvLyBOT1RFOiBieSBzZXR0aW5nIGByZXR1cm5Gb2N1czogZmFsc2VgLCBkZWFjdGl2YXRlKCkgd2lsbCBkbyBub3RoaW5nLFxuICAgICAgICAvLyAgd2hpY2ggd2lsbCByZXN1bHQgaW4gdGhlIG91dHNpZGUgY2xpY2sgc2V0dGluZyBmb2N1cyB0byB0aGUgbm9kZVxuICAgICAgICAvLyAgdGhhdCB3YXMgY2xpY2tlZCwgd2hldGhlciBpdCdzIGZvY3VzYWJsZSBvciBub3Q7IGJ5IHNldHRpbmdcbiAgICAgICAgLy8gIGByZXR1cm5Gb2N1czogdHJ1ZWAsIHdlJ2xsIGF0dGVtcHQgdG8gcmUtZm9jdXMgdGhlIG5vZGUgb3JpZ2luYWxseS1mb2N1c2VkXG4gICAgICAgIC8vICBvbiBhY3RpdmF0aW9uIChvciB0aGUgY29uZmlndXJlZCBgc2V0UmV0dXJuRm9jdXNgIG5vZGUpXG4gICAgICAgIHJldHVybkZvY3VzOiBjb25maWcucmV0dXJuRm9jdXNPbkRlYWN0aXZhdGUgJiYgIWlzRm9jdXNhYmxlKHRhcmdldCwgY29uZmlnLnRhYmJhYmxlT3B0aW9ucylcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gVGhpcyBpcyBuZWVkZWQgZm9yIG1vYmlsZSBkZXZpY2VzLlxuICAgIC8vIChJZiB3ZSdsbCBvbmx5IGxldCBgY2xpY2tgIGV2ZW50cyB0aHJvdWdoLFxuICAgIC8vIHRoZW4gb24gbW9iaWxlIHRoZXkgd2lsbCBiZSBibG9ja2VkIGFueXdheXMgaWYgYHRvdWNoc3RhcnRgIGlzIGJsb2NrZWQuKVxuXG5cbiAgICBpZiAodmFsdWVPckhhbmRsZXIoY29uZmlnLmFsbG93T3V0c2lkZUNsaWNrLCBlKSkge1xuICAgICAgLy8gYWxsb3cgdGhlIGNsaWNrIG91dHNpZGUgdGhlIHRyYXAgdG8gdGFrZSBwbGFjZVxuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gb3RoZXJ3aXNlLCBwcmV2ZW50IHRoZSBjbGlja1xuXG5cbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH07IC8vIEluIGNhc2UgZm9jdXMgZXNjYXBlcyB0aGUgdHJhcCBmb3Igc29tZSBzdHJhbmdlIHJlYXNvbiwgcHVsbCBpdCBiYWNrIGluLlxuXG5cbiAgdmFyIGNoZWNrRm9jdXNJbiA9IGZ1bmN0aW9uIGNoZWNrRm9jdXNJbihlKSB7XG4gICAgdmFyIHRhcmdldCA9IGdldEFjdHVhbFRhcmdldChlKTtcbiAgICB2YXIgdGFyZ2V0Q29udGFpbmVkID0gZmluZENvbnRhaW5lckluZGV4KHRhcmdldCkgPj0gMDsgLy8gSW4gRmlyZWZveCB3aGVuIHlvdSBUYWIgb3V0IG9mIGFuIGlmcmFtZSB0aGUgRG9jdW1lbnQgaXMgYnJpZWZseSBmb2N1c2VkLlxuXG4gICAgaWYgKHRhcmdldENvbnRhaW5lZCB8fCB0YXJnZXQgaW5zdGFuY2VvZiBEb2N1bWVudCkge1xuICAgICAgaWYgKHRhcmdldENvbnRhaW5lZCkge1xuICAgICAgICBzdGF0ZS5tb3N0UmVjZW50bHlGb2N1c2VkTm9kZSA9IHRhcmdldDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXNjYXBlZCEgcHVsbCBpdCBiYWNrIGluIHRvIHdoZXJlIGl0IGp1c3QgbGVmdFxuICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgIHRyeUZvY3VzKHN0YXRlLm1vc3RSZWNlbnRseUZvY3VzZWROb2RlIHx8IGdldEluaXRpYWxGb2N1c05vZGUoKSk7XG4gICAgfVxuICB9OyAvLyBIaWphY2sgVGFiIGV2ZW50cyBvbiB0aGUgZmlyc3QgYW5kIGxhc3QgZm9jdXNhYmxlIG5vZGVzIG9mIHRoZSB0cmFwLFxuICAvLyBpbiBvcmRlciB0byBwcmV2ZW50IGZvY3VzIGZyb20gZXNjYXBpbmcuIElmIGl0IGVzY2FwZXMgZm9yIGV2ZW4gYVxuICAvLyBtb21lbnQgaXQgY2FuIGVuZCB1cCBzY3JvbGxpbmcgdGhlIHBhZ2UgYW5kIGNhdXNpbmcgY29uZnVzaW9uIHNvIHdlXG4gIC8vIGtpbmQgb2YgbmVlZCB0byBjYXB0dXJlIHRoZSBhY3Rpb24gYXQgdGhlIGtleWRvd24gcGhhc2UuXG5cblxuICB2YXIgY2hlY2tUYWIgPSBmdW5jdGlvbiBjaGVja1RhYihlKSB7XG4gICAgdmFyIHRhcmdldCA9IGdldEFjdHVhbFRhcmdldChlKTtcbiAgICB1cGRhdGVUYWJiYWJsZU5vZGVzKCk7XG4gICAgdmFyIGRlc3RpbmF0aW9uTm9kZSA9IG51bGw7XG5cbiAgICBpZiAoc3RhdGUudGFiYmFibGVHcm91cHMubGVuZ3RoID4gMCkge1xuICAgICAgLy8gbWFrZSBzdXJlIHRoZSB0YXJnZXQgaXMgYWN0dWFsbHkgY29udGFpbmVkIGluIGEgZ3JvdXBcbiAgICAgIC8vIE5PVEU6IHRoZSB0YXJnZXQgbWF5IGFsc28gYmUgdGhlIGNvbnRhaW5lciBpdHNlbGYgaWYgaXQncyBmb2N1c2FibGVcbiAgICAgIC8vICB3aXRoIHRhYkluZGV4PSctMScgYW5kIHdhcyBnaXZlbiBpbml0aWFsIGZvY3VzXG4gICAgICB2YXIgY29udGFpbmVySW5kZXggPSBmaW5kQ29udGFpbmVySW5kZXgodGFyZ2V0KTtcbiAgICAgIHZhciBjb250YWluZXJHcm91cCA9IGNvbnRhaW5lckluZGV4ID49IDAgPyBzdGF0ZS5jb250YWluZXJHcm91cHNbY29udGFpbmVySW5kZXhdIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoY29udGFpbmVySW5kZXggPCAwKSB7XG4gICAgICAgIC8vIHRhcmdldCBub3QgZm91bmQgaW4gYW55IGdyb3VwOiBxdWl0ZSBwb3NzaWJsZSBmb2N1cyBoYXMgZXNjYXBlZCB0aGUgdHJhcCxcbiAgICAgICAgLy8gIHNvIGJyaW5nIGl0IGJhY2sgaW4gdG8uLi5cbiAgICAgICAgaWYgKGUuc2hpZnRLZXkpIHtcbiAgICAgICAgICAvLyAuLi50aGUgbGFzdCBub2RlIGluIHRoZSBsYXN0IGdyb3VwXG4gICAgICAgICAgZGVzdGluYXRpb25Ob2RlID0gc3RhdGUudGFiYmFibGVHcm91cHNbc3RhdGUudGFiYmFibGVHcm91cHMubGVuZ3RoIC0gMV0ubGFzdFRhYmJhYmxlTm9kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyAuLi50aGUgZmlyc3Qgbm9kZSBpbiB0aGUgZmlyc3QgZ3JvdXBcbiAgICAgICAgICBkZXN0aW5hdGlvbk5vZGUgPSBzdGF0ZS50YWJiYWJsZUdyb3Vwc1swXS5maXJzdFRhYmJhYmxlTm9kZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICAgIC8vIFJFVkVSU0VcbiAgICAgICAgLy8gaXMgdGhlIHRhcmdldCB0aGUgZmlyc3QgdGFiYmFibGUgbm9kZSBpbiBhIGdyb3VwP1xuICAgICAgICB2YXIgc3RhcnRPZkdyb3VwSW5kZXggPSBmaW5kSW5kZXgoc3RhdGUudGFiYmFibGVHcm91cHMsIGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgICAgIHZhciBmaXJzdFRhYmJhYmxlTm9kZSA9IF9yZWYyLmZpcnN0VGFiYmFibGVOb2RlO1xuICAgICAgICAgIHJldHVybiB0YXJnZXQgPT09IGZpcnN0VGFiYmFibGVOb2RlO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoc3RhcnRPZkdyb3VwSW5kZXggPCAwICYmIChjb250YWluZXJHcm91cC5jb250YWluZXIgPT09IHRhcmdldCB8fCBpc0ZvY3VzYWJsZSh0YXJnZXQsIGNvbmZpZy50YWJiYWJsZU9wdGlvbnMpICYmICFpc1RhYmJhYmxlKHRhcmdldCwgY29uZmlnLnRhYmJhYmxlT3B0aW9ucykgJiYgIWNvbnRhaW5lckdyb3VwLm5leHRUYWJiYWJsZU5vZGUodGFyZ2V0LCBmYWxzZSkpKSB7XG4gICAgICAgICAgLy8gYW4gZXhjZXB0aW9uIGNhc2Ugd2hlcmUgdGhlIHRhcmdldCBpcyBlaXRoZXIgdGhlIGNvbnRhaW5lciBpdHNlbGYsIG9yXG4gICAgICAgICAgLy8gIGEgbm9uLXRhYmJhYmxlIG5vZGUgdGhhdCB3YXMgZ2l2ZW4gZm9jdXMgKGkuZS4gdGFiaW5kZXggaXMgbmVnYXRpdmVcbiAgICAgICAgICAvLyAgYW5kIHVzZXIgY2xpY2tlZCBvbiBpdCBvciBub2RlIHdhcyBwcm9ncmFtbWF0aWNhbGx5IGdpdmVuIGZvY3VzKVxuICAgICAgICAgIC8vICBhbmQgaXMgbm90IGZvbGxvd2VkIGJ5IGFueSBvdGhlciB0YWJiYWJsZSBub2RlLCBpbiB3aGljaFxuICAgICAgICAgIC8vICBjYXNlLCB3ZSBzaG91bGQgaGFuZGxlIHNoaWZ0K3RhYiBhcyBpZiBmb2N1cyB3ZXJlIG9uIHRoZSBjb250YWluZXInc1xuICAgICAgICAgIC8vICBmaXJzdCB0YWJiYWJsZSBub2RlLCBhbmQgZ28gdG8gdGhlIGxhc3QgdGFiYmFibGUgbm9kZSBvZiB0aGUgTEFTVCBncm91cFxuICAgICAgICAgIHN0YXJ0T2ZHcm91cEluZGV4ID0gY29udGFpbmVySW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhcnRPZkdyb3VwSW5kZXggPj0gMCkge1xuICAgICAgICAgIC8vIFlFUzogdGhlbiBzaGlmdCt0YWIgc2hvdWxkIGdvIHRvIHRoZSBsYXN0IHRhYmJhYmxlIG5vZGUgaW4gdGhlXG4gICAgICAgICAgLy8gIHByZXZpb3VzIGdyb3VwIChhbmQgd3JhcCBhcm91bmQgdG8gdGhlIGxhc3QgdGFiYmFibGUgbm9kZSBvZlxuICAgICAgICAgIC8vICB0aGUgTEFTVCBncm91cCBpZiBpdCdzIHRoZSBmaXJzdCB0YWJiYWJsZSBub2RlIG9mIHRoZSBGSVJTVCBncm91cClcbiAgICAgICAgICB2YXIgZGVzdGluYXRpb25Hcm91cEluZGV4ID0gc3RhcnRPZkdyb3VwSW5kZXggPT09IDAgPyBzdGF0ZS50YWJiYWJsZUdyb3Vwcy5sZW5ndGggLSAxIDogc3RhcnRPZkdyb3VwSW5kZXggLSAxO1xuICAgICAgICAgIHZhciBkZXN0aW5hdGlvbkdyb3VwID0gc3RhdGUudGFiYmFibGVHcm91cHNbZGVzdGluYXRpb25Hcm91cEluZGV4XTtcbiAgICAgICAgICBkZXN0aW5hdGlvbk5vZGUgPSBkZXN0aW5hdGlvbkdyb3VwLmxhc3RUYWJiYWJsZU5vZGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZPUldBUkRcbiAgICAgICAgLy8gaXMgdGhlIHRhcmdldCB0aGUgbGFzdCB0YWJiYWJsZSBub2RlIGluIGEgZ3JvdXA/XG4gICAgICAgIHZhciBsYXN0T2ZHcm91cEluZGV4ID0gZmluZEluZGV4KHN0YXRlLnRhYmJhYmxlR3JvdXBzLCBmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICAgICAgICB2YXIgbGFzdFRhYmJhYmxlTm9kZSA9IF9yZWYzLmxhc3RUYWJiYWJsZU5vZGU7XG4gICAgICAgICAgcmV0dXJuIHRhcmdldCA9PT0gbGFzdFRhYmJhYmxlTm9kZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGxhc3RPZkdyb3VwSW5kZXggPCAwICYmIChjb250YWluZXJHcm91cC5jb250YWluZXIgPT09IHRhcmdldCB8fCBpc0ZvY3VzYWJsZSh0YXJnZXQsIGNvbmZpZy50YWJiYWJsZU9wdGlvbnMpICYmICFpc1RhYmJhYmxlKHRhcmdldCwgY29uZmlnLnRhYmJhYmxlT3B0aW9ucykgJiYgIWNvbnRhaW5lckdyb3VwLm5leHRUYWJiYWJsZU5vZGUodGFyZ2V0KSkpIHtcbiAgICAgICAgICAvLyBhbiBleGNlcHRpb24gY2FzZSB3aGVyZSB0aGUgdGFyZ2V0IGlzIHRoZSBjb250YWluZXIgaXRzZWxmLCBvclxuICAgICAgICAgIC8vICBhIG5vbi10YWJiYWJsZSBub2RlIHRoYXQgd2FzIGdpdmVuIGZvY3VzIChpLmUuIHRhYmluZGV4IGlzIG5lZ2F0aXZlXG4gICAgICAgICAgLy8gIGFuZCB1c2VyIGNsaWNrZWQgb24gaXQgb3Igbm9kZSB3YXMgcHJvZ3JhbW1hdGljYWxseSBnaXZlbiBmb2N1cylcbiAgICAgICAgICAvLyAgYW5kIGlzIG5vdCBmb2xsb3dlZCBieSBhbnkgb3RoZXIgdGFiYmFibGUgbm9kZSwgaW4gd2hpY2hcbiAgICAgICAgICAvLyAgY2FzZSwgd2Ugc2hvdWxkIGhhbmRsZSB0YWIgYXMgaWYgZm9jdXMgd2VyZSBvbiB0aGUgY29udGFpbmVyJ3NcbiAgICAgICAgICAvLyAgbGFzdCB0YWJiYWJsZSBub2RlLCBhbmQgZ28gdG8gdGhlIGZpcnN0IHRhYmJhYmxlIG5vZGUgb2YgdGhlIEZJUlNUIGdyb3VwXG4gICAgICAgICAgbGFzdE9mR3JvdXBJbmRleCA9IGNvbnRhaW5lckluZGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxhc3RPZkdyb3VwSW5kZXggPj0gMCkge1xuICAgICAgICAgIC8vIFlFUzogdGhlbiB0YWIgc2hvdWxkIGdvIHRvIHRoZSBmaXJzdCB0YWJiYWJsZSBub2RlIGluIHRoZSBuZXh0XG4gICAgICAgICAgLy8gIGdyb3VwIChhbmQgd3JhcCBhcm91bmQgdG8gdGhlIGZpcnN0IHRhYmJhYmxlIG5vZGUgb2YgdGhlIEZJUlNUXG4gICAgICAgICAgLy8gIGdyb3VwIGlmIGl0J3MgdGhlIGxhc3QgdGFiYmFibGUgbm9kZSBvZiB0aGUgTEFTVCBncm91cClcbiAgICAgICAgICB2YXIgX2Rlc3RpbmF0aW9uR3JvdXBJbmRleCA9IGxhc3RPZkdyb3VwSW5kZXggPT09IHN0YXRlLnRhYmJhYmxlR3JvdXBzLmxlbmd0aCAtIDEgPyAwIDogbGFzdE9mR3JvdXBJbmRleCArIDE7XG5cbiAgICAgICAgICB2YXIgX2Rlc3RpbmF0aW9uR3JvdXAgPSBzdGF0ZS50YWJiYWJsZUdyb3Vwc1tfZGVzdGluYXRpb25Hcm91cEluZGV4XTtcbiAgICAgICAgICBkZXN0aW5hdGlvbk5vZGUgPSBfZGVzdGluYXRpb25Hcm91cC5maXJzdFRhYmJhYmxlTm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBOT1RFOiB0aGUgZmFsbGJhY2tGb2N1cyBvcHRpb24gZG9lcyBub3Qgc3VwcG9ydCByZXR1cm5pbmcgZmFsc2UgdG8gb3B0LW91dFxuICAgICAgZGVzdGluYXRpb25Ob2RlID0gZ2V0Tm9kZUZvck9wdGlvbignZmFsbGJhY2tGb2N1cycpO1xuICAgIH1cblxuICAgIGlmIChkZXN0aW5hdGlvbk5vZGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRyeUZvY3VzKGRlc3RpbmF0aW9uTm9kZSk7XG4gICAgfSAvLyBlbHNlLCBsZXQgdGhlIGJyb3dzZXIgdGFrZSBjYXJlIG9mIFtzaGlmdCtddGFiIGFuZCBtb3ZlIHRoZSBmb2N1c1xuXG4gIH07XG5cbiAgdmFyIGNoZWNrS2V5ID0gZnVuY3Rpb24gY2hlY2tLZXkoZSkge1xuICAgIGlmIChpc0VzY2FwZUV2ZW50KGUpICYmIHZhbHVlT3JIYW5kbGVyKGNvbmZpZy5lc2NhcGVEZWFjdGl2YXRlcywgZSkgIT09IGZhbHNlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0cmFwLmRlYWN0aXZhdGUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNUYWJFdmVudChlKSkge1xuICAgICAgY2hlY2tUYWIoZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9O1xuXG4gIHZhciBjaGVja0NsaWNrID0gZnVuY3Rpb24gY2hlY2tDbGljayhlKSB7XG4gICAgdmFyIHRhcmdldCA9IGdldEFjdHVhbFRhcmdldChlKTtcblxuICAgIGlmIChmaW5kQ29udGFpbmVySW5kZXgodGFyZ2V0KSA+PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlT3JIYW5kbGVyKGNvbmZpZy5jbGlja091dHNpZGVEZWFjdGl2YXRlcywgZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodmFsdWVPckhhbmRsZXIoY29uZmlnLmFsbG93T3V0c2lkZUNsaWNrLCBlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICB9OyAvL1xuICAvLyBFVkVOVCBMSVNURU5FUlNcbiAgLy9cblxuXG4gIHZhciBhZGRMaXN0ZW5lcnMgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKCFzdGF0ZS5hY3RpdmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFRoZXJlIGNhbiBiZSBvbmx5IG9uZSBsaXN0ZW5pbmcgZm9jdXMgdHJhcCBhdCBhIHRpbWVcblxuXG4gICAgYWN0aXZlRm9jdXNUcmFwcy5hY3RpdmF0ZVRyYXAodHJhcCk7IC8vIERlbGF5IGVuc3VyZXMgdGhhdCB0aGUgZm9jdXNlZCBlbGVtZW50IGRvZXNuJ3QgY2FwdHVyZSB0aGUgZXZlbnRcbiAgICAvLyB0aGF0IGNhdXNlZCB0aGUgZm9jdXMgdHJhcCBhY3RpdmF0aW9uLlxuXG4gICAgc3RhdGUuZGVsYXlJbml0aWFsRm9jdXNUaW1lciA9IGNvbmZpZy5kZWxheUluaXRpYWxGb2N1cyA/IGRlbGF5KGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyeUZvY3VzKGdldEluaXRpYWxGb2N1c05vZGUoKSk7XG4gICAgfSkgOiB0cnlGb2N1cyhnZXRJbml0aWFsRm9jdXNOb2RlKCkpO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdmb2N1c2luJywgY2hlY2tGb2N1c0luLCB0cnVlKTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgY2hlY2tQb2ludGVyRG93biwge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfSk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBjaGVja1BvaW50ZXJEb3duLCB7XG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICB9KTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBjaGVja0NsaWNrLCB7XG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICB9KTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGNoZWNrS2V5LCB7XG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICB9KTtcbiAgICByZXR1cm4gdHJhcDtcbiAgfTtcblxuICB2YXIgcmVtb3ZlTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXJzKCkge1xuICAgIGlmICghc3RhdGUuYWN0aXZlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCBjaGVja0ZvY3VzSW4sIHRydWUpO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBjaGVja1BvaW50ZXJEb3duLCB0cnVlKTtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGNoZWNrUG9pbnRlckRvd24sIHRydWUpO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGNoZWNrQ2xpY2ssIHRydWUpO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgY2hlY2tLZXksIHRydWUpO1xuICAgIHJldHVybiB0cmFwO1xuICB9OyAvL1xuICAvLyBUUkFQIERFRklOSVRJT05cbiAgLy9cblxuXG4gIHRyYXAgPSB7XG4gICAgZ2V0IGFjdGl2ZSgpIHtcbiAgICAgIHJldHVybiBzdGF0ZS5hY3RpdmU7XG4gICAgfSxcblxuICAgIGdldCBwYXVzZWQoKSB7XG4gICAgICByZXR1cm4gc3RhdGUucGF1c2VkO1xuICAgIH0sXG5cbiAgICBhY3RpdmF0ZTogZnVuY3Rpb24gYWN0aXZhdGUoYWN0aXZhdGVPcHRpb25zKSB7XG4gICAgICBpZiAoc3RhdGUuYWN0aXZlKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgb25BY3RpdmF0ZSA9IGdldE9wdGlvbihhY3RpdmF0ZU9wdGlvbnMsICdvbkFjdGl2YXRlJyk7XG4gICAgICB2YXIgb25Qb3N0QWN0aXZhdGUgPSBnZXRPcHRpb24oYWN0aXZhdGVPcHRpb25zLCAnb25Qb3N0QWN0aXZhdGUnKTtcbiAgICAgIHZhciBjaGVja0NhbkZvY3VzVHJhcCA9IGdldE9wdGlvbihhY3RpdmF0ZU9wdGlvbnMsICdjaGVja0NhbkZvY3VzVHJhcCcpO1xuXG4gICAgICBpZiAoIWNoZWNrQ2FuRm9jdXNUcmFwKSB7XG4gICAgICAgIHVwZGF0ZVRhYmJhYmxlTm9kZXMoKTtcbiAgICAgIH1cblxuICAgICAgc3RhdGUuYWN0aXZlID0gdHJ1ZTtcbiAgICAgIHN0YXRlLnBhdXNlZCA9IGZhbHNlO1xuICAgICAgc3RhdGUubm9kZUZvY3VzZWRCZWZvcmVBY3RpdmF0aW9uID0gZG9jLmFjdGl2ZUVsZW1lbnQ7XG5cbiAgICAgIGlmIChvbkFjdGl2YXRlKSB7XG4gICAgICAgIG9uQWN0aXZhdGUoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGZpbmlzaEFjdGl2YXRpb24gPSBmdW5jdGlvbiBmaW5pc2hBY3RpdmF0aW9uKCkge1xuICAgICAgICBpZiAoY2hlY2tDYW5Gb2N1c1RyYXApIHtcbiAgICAgICAgICB1cGRhdGVUYWJiYWJsZU5vZGVzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBhZGRMaXN0ZW5lcnMoKTtcblxuICAgICAgICBpZiAob25Qb3N0QWN0aXZhdGUpIHtcbiAgICAgICAgICBvblBvc3RBY3RpdmF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpZiAoY2hlY2tDYW5Gb2N1c1RyYXApIHtcbiAgICAgICAgY2hlY2tDYW5Gb2N1c1RyYXAoc3RhdGUuY29udGFpbmVycy5jb25jYXQoKSkudGhlbihmaW5pc2hBY3RpdmF0aW9uLCBmaW5pc2hBY3RpdmF0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGZpbmlzaEFjdGl2YXRpb24oKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZGVhY3RpdmF0ZTogZnVuY3Rpb24gZGVhY3RpdmF0ZShkZWFjdGl2YXRlT3B0aW9ucykge1xuICAgICAgaWYgKCFzdGF0ZS5hY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHZhciBvcHRpb25zID0gX29iamVjdFNwcmVhZDIoe1xuICAgICAgICBvbkRlYWN0aXZhdGU6IGNvbmZpZy5vbkRlYWN0aXZhdGUsXG4gICAgICAgIG9uUG9zdERlYWN0aXZhdGU6IGNvbmZpZy5vblBvc3REZWFjdGl2YXRlLFxuICAgICAgICBjaGVja0NhblJldHVybkZvY3VzOiBjb25maWcuY2hlY2tDYW5SZXR1cm5Gb2N1c1xuICAgICAgfSwgZGVhY3RpdmF0ZU9wdGlvbnMpO1xuXG4gICAgICBjbGVhclRpbWVvdXQoc3RhdGUuZGVsYXlJbml0aWFsRm9jdXNUaW1lcik7IC8vIG5vb3AgaWYgdW5kZWZpbmVkXG5cbiAgICAgIHN0YXRlLmRlbGF5SW5pdGlhbEZvY3VzVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICByZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgIHN0YXRlLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgc3RhdGUucGF1c2VkID0gZmFsc2U7XG4gICAgICBhY3RpdmVGb2N1c1RyYXBzLmRlYWN0aXZhdGVUcmFwKHRyYXApO1xuICAgICAgdmFyIG9uRGVhY3RpdmF0ZSA9IGdldE9wdGlvbihvcHRpb25zLCAnb25EZWFjdGl2YXRlJyk7XG4gICAgICB2YXIgb25Qb3N0RGVhY3RpdmF0ZSA9IGdldE9wdGlvbihvcHRpb25zLCAnb25Qb3N0RGVhY3RpdmF0ZScpO1xuICAgICAgdmFyIGNoZWNrQ2FuUmV0dXJuRm9jdXMgPSBnZXRPcHRpb24ob3B0aW9ucywgJ2NoZWNrQ2FuUmV0dXJuRm9jdXMnKTtcbiAgICAgIHZhciByZXR1cm5Gb2N1cyA9IGdldE9wdGlvbihvcHRpb25zLCAncmV0dXJuRm9jdXMnLCAncmV0dXJuRm9jdXNPbkRlYWN0aXZhdGUnKTtcblxuICAgICAgaWYgKG9uRGVhY3RpdmF0ZSkge1xuICAgICAgICBvbkRlYWN0aXZhdGUoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGZpbmlzaERlYWN0aXZhdGlvbiA9IGZ1bmN0aW9uIGZpbmlzaERlYWN0aXZhdGlvbigpIHtcbiAgICAgICAgZGVsYXkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChyZXR1cm5Gb2N1cykge1xuICAgICAgICAgICAgdHJ5Rm9jdXMoZ2V0UmV0dXJuRm9jdXNOb2RlKHN0YXRlLm5vZGVGb2N1c2VkQmVmb3JlQWN0aXZhdGlvbikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvblBvc3REZWFjdGl2YXRlKSB7XG4gICAgICAgICAgICBvblBvc3REZWFjdGl2YXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGlmIChyZXR1cm5Gb2N1cyAmJiBjaGVja0NhblJldHVybkZvY3VzKSB7XG4gICAgICAgIGNoZWNrQ2FuUmV0dXJuRm9jdXMoZ2V0UmV0dXJuRm9jdXNOb2RlKHN0YXRlLm5vZGVGb2N1c2VkQmVmb3JlQWN0aXZhdGlvbikpLnRoZW4oZmluaXNoRGVhY3RpdmF0aW9uLCBmaW5pc2hEZWFjdGl2YXRpb24pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgZmluaXNoRGVhY3RpdmF0aW9uKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHBhdXNlOiBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICAgIGlmIChzdGF0ZS5wYXVzZWQgfHwgIXN0YXRlLmFjdGl2ZSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgc3RhdGUucGF1c2VkID0gdHJ1ZTtcbiAgICAgIHJlbW92ZUxpc3RlbmVycygpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICB1bnBhdXNlOiBmdW5jdGlvbiB1bnBhdXNlKCkge1xuICAgICAgaWYgKCFzdGF0ZS5wYXVzZWQgfHwgIXN0YXRlLmFjdGl2ZSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgc3RhdGUucGF1c2VkID0gZmFsc2U7XG4gICAgICB1cGRhdGVUYWJiYWJsZU5vZGVzKCk7XG4gICAgICBhZGRMaXN0ZW5lcnMoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgdXBkYXRlQ29udGFpbmVyRWxlbWVudHM6IGZ1bmN0aW9uIHVwZGF0ZUNvbnRhaW5lckVsZW1lbnRzKGNvbnRhaW5lckVsZW1lbnRzKSB7XG4gICAgICB2YXIgZWxlbWVudHNBc0FycmF5ID0gW10uY29uY2F0KGNvbnRhaW5lckVsZW1lbnRzKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgICBzdGF0ZS5jb250YWluZXJzID0gZWxlbWVudHNBc0FycmF5Lm1hcChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnID8gZG9jLnF1ZXJ5U2VsZWN0b3IoZWxlbWVudCkgOiBlbGVtZW50O1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChzdGF0ZS5hY3RpdmUpIHtcbiAgICAgICAgdXBkYXRlVGFiYmFibGVOb2RlcygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07IC8vIGluaXRpYWxpemUgY29udGFpbmVyIGVsZW1lbnRzXG5cbiAgdHJhcC51cGRhdGVDb250YWluZXJFbGVtZW50cyhlbGVtZW50cyk7XG4gIHJldHVybiB0cmFwO1xufTtcblxuZXhwb3J0IHsgY3JlYXRlRm9jdXNUcmFwIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy10cmFwLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJ0YWJiYWJsZSIsImZvY3VzYWJsZSIsImlzVGFiYmFibGUiLCJpc0ZvY3VzYWJsZSIsIm93bktleXMiLCJvYmplY3QiLCJlbnVtZXJhYmxlT25seSIsImtleXMiLCJPYmplY3QiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzeW1ib2xzIiwiZmlsdGVyIiwic3ltIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsInB1c2giLCJhcHBseSIsIl9vYmplY3RTcHJlYWQyIiwidGFyZ2V0IiwiaSIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNvdXJjZSIsImZvckVhY2giLCJrZXkiLCJfZGVmaW5lUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsImRlZmluZVByb3BlcnR5Iiwib2JqIiwidmFsdWUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsImFjdGl2ZUZvY3VzVHJhcHMiLCJ0cmFwUXVldWUiLCJhY3RpdmF0ZVRyYXAiLCJ0cmFwIiwiYWN0aXZlVHJhcCIsInBhdXNlIiwidHJhcEluZGV4IiwiaW5kZXhPZiIsInNwbGljZSIsImRlYWN0aXZhdGVUcmFwIiwidW5wYXVzZSIsImlzU2VsZWN0YWJsZUlucHV0Iiwibm9kZSIsInRhZ05hbWUiLCJ0b0xvd2VyQ2FzZSIsInNlbGVjdCIsImlzRXNjYXBlRXZlbnQiLCJlIiwia2V5Q29kZSIsImlzVGFiRXZlbnQiLCJkZWxheSIsImZuIiwic2V0VGltZW91dCIsImZpbmRJbmRleCIsImFyciIsImlkeCIsImV2ZXJ5IiwidmFsdWVPckhhbmRsZXIiLCJfbGVuIiwicGFyYW1zIiwiQXJyYXkiLCJfa2V5IiwiZ2V0QWN0dWFsVGFyZ2V0IiwiZXZlbnQiLCJzaGFkb3dSb290IiwiY29tcG9zZWRQYXRoIiwiY3JlYXRlRm9jdXNUcmFwIiwiZWxlbWVudHMiLCJ1c2VyT3B0aW9ucyIsImRvYyIsImRvY3VtZW50IiwiY29uZmlnIiwicmV0dXJuRm9jdXNPbkRlYWN0aXZhdGUiLCJlc2NhcGVEZWFjdGl2YXRlcyIsImRlbGF5SW5pdGlhbEZvY3VzIiwic3RhdGUiLCJjb250YWluZXJzIiwiY29udGFpbmVyR3JvdXBzIiwidGFiYmFibGVHcm91cHMiLCJub2RlRm9jdXNlZEJlZm9yZUFjdGl2YXRpb24iLCJtb3N0UmVjZW50bHlGb2N1c2VkTm9kZSIsImFjdGl2ZSIsInBhdXNlZCIsImRlbGF5SW5pdGlhbEZvY3VzVGltZXIiLCJ1bmRlZmluZWQiLCJnZXRPcHRpb24iLCJjb25maWdPdmVycmlkZU9wdGlvbnMiLCJvcHRpb25OYW1lIiwiY29uZmlnT3B0aW9uTmFtZSIsImZpbmRDb250YWluZXJJbmRleCIsImVsZW1lbnQiLCJfcmVmIiwiY29udGFpbmVyIiwidGFiYmFibGVOb2RlcyIsImNvbnRhaW5zIiwiZmluZCIsImdldE5vZGVGb3JPcHRpb24iLCJvcHRpb25WYWx1ZSIsIl9sZW4yIiwiX2tleTIiLCJFcnJvciIsImNvbmNhdCIsInF1ZXJ5U2VsZWN0b3IiLCJnZXRJbml0aWFsRm9jdXNOb2RlIiwiYWN0aXZlRWxlbWVudCIsImZpcnN0VGFiYmFibGVHcm91cCIsImZpcnN0VGFiYmFibGVOb2RlIiwidXBkYXRlVGFiYmFibGVOb2RlcyIsIm1hcCIsInRhYmJhYmxlT3B0aW9ucyIsImZvY3VzYWJsZU5vZGVzIiwibGFzdFRhYmJhYmxlTm9kZSIsIm5leHRUYWJiYWJsZU5vZGUiLCJmb3J3YXJkIiwibm9kZUlkeCIsIm4iLCJzbGljZSIsInJldmVyc2UiLCJncm91cCIsInRyeUZvY3VzIiwiZm9jdXMiLCJwcmV2ZW50U2Nyb2xsIiwiZ2V0UmV0dXJuRm9jdXNOb2RlIiwicHJldmlvdXNBY3RpdmVFbGVtZW50IiwiY2hlY2tQb2ludGVyRG93biIsImNsaWNrT3V0c2lkZURlYWN0aXZhdGVzIiwiZGVhY3RpdmF0ZSIsInJldHVybkZvY3VzIiwiYWxsb3dPdXRzaWRlQ2xpY2siLCJwcmV2ZW50RGVmYXVsdCIsImNoZWNrRm9jdXNJbiIsInRhcmdldENvbnRhaW5lZCIsIkRvY3VtZW50Iiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwiY2hlY2tUYWIiLCJkZXN0aW5hdGlvbk5vZGUiLCJjb250YWluZXJJbmRleCIsImNvbnRhaW5lckdyb3VwIiwic2hpZnRLZXkiLCJzdGFydE9mR3JvdXBJbmRleCIsIl9yZWYyIiwiZGVzdGluYXRpb25Hcm91cEluZGV4IiwiZGVzdGluYXRpb25Hcm91cCIsImxhc3RPZkdyb3VwSW5kZXgiLCJfcmVmMyIsIl9kZXN0aW5hdGlvbkdyb3VwSW5kZXgiLCJfZGVzdGluYXRpb25Hcm91cCIsImNoZWNrS2V5IiwiY2hlY2tDbGljayIsImFkZExpc3RlbmVycyIsImFkZEV2ZW50TGlzdGVuZXIiLCJjYXB0dXJlIiwicGFzc2l2ZSIsInJlbW92ZUxpc3RlbmVycyIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJhY3RpdmF0ZSIsImFjdGl2YXRlT3B0aW9ucyIsIm9uQWN0aXZhdGUiLCJvblBvc3RBY3RpdmF0ZSIsImNoZWNrQ2FuRm9jdXNUcmFwIiwiZmluaXNoQWN0aXZhdGlvbiIsInRoZW4iLCJkZWFjdGl2YXRlT3B0aW9ucyIsIm9wdGlvbnMiLCJvbkRlYWN0aXZhdGUiLCJvblBvc3REZWFjdGl2YXRlIiwiY2hlY2tDYW5SZXR1cm5Gb2N1cyIsImNsZWFyVGltZW91dCIsImZpbmlzaERlYWN0aXZhdGlvbiIsInVwZGF0ZUNvbnRhaW5lckVsZW1lbnRzIiwiY29udGFpbmVyRWxlbWVudHMiLCJlbGVtZW50c0FzQXJyYXkiLCJCb29sZWFuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/focus-trap/dist/focus-trap.esm.js\n");

/***/ })

};
;